(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    "use strict";
    require('../');
    var yaga = require('@yaga/leaflet-driver');
    angular.module('org.yagajs.leaflet-driver', [])
        .factory('$yagaDriver', function () {
            return yaga;
        });
    var TestAppController = (function () {
        function TestAppController($scope) {
            $scope.center = {
                lat: 50.7380324,
                lng: 7.1104686
            };
            $scope.zoom = 1;
            $scope.layers = [

                {
                    type: 'tile',
                    name: 'TopoMap',
                    attribution: '&copy; OpenTopo-Map',
                    url: 'http://b.tile.opentopomap.org/{z}/{x}/{y}.png',
                    opacity: 1
                },{
                    type: 'tile',
                    name: 'OSM',
                    attribution: '&copy; OSM-Layer',
                    url: 'http://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    opacity: 1
                }
            ];
            $scope.layerTypes = ['tile'];
            $scope.geojson = {
                "type": "FeatureCollection",
                "features": [
                    {
                        "type": "Feature",
                        "properties": {
                            "name": "Bonn"
                        },
                        "geometry": {
                            "type": "Point",
                            "coordinates": [7.1104686, 50.7380324]
                        }
                    }
                ]
            };
            $scope.newLayer = {
                addLayer: function () {
                    if ($scope.newLayer.type === 'wms') {
                        $scope.layers.push({
                            type: $scope.newLayer.type,
                            name: $scope.newLayer.name,
                            attribution: $scope.newLayer.attribution,
                            url: $scope.newLayer.url,
                            opacity: $scope.newLayer.opacity,
                            layers: $scope.newLayer.layers.map(function (arr) {
                                return arr.name;
                            })
                        });
                        return;
                    }
                    $scope.layers.push({
                        type: $scope.newLayer.type,
                        name: $scope.newLayer.name,
                        attribution: $scope.newLayer.attribution,
                        url: $scope.newLayer.url,
                        opacity: $scope.newLayer.opacity
                    });
                },
                type: 'wms',
                name: 'DOP',
                attribution: '&copy; GeoNRW',
                url: 'http://www.wms.nrw.de/geobasis/wms_nw_dop40?',
                opacity: 1,
                layers: [{ name: 'nw_dop40' }],
                addWmsLayer: function () {
                    $scope.newLayer.layers.push({ name: '' });
                }
            };
            $scope.removeLayer = function (layer) {
                $scope.layers.splice($scope.layers.indexOf(layer), 1);
            };
        }
        TestAppController.$inject = ['$scope'];
        return TestAppController;
    }());
    angular.module('org.yagajs.angular-test', ['org.yagajs.leaflet-driver', 'yaga'])
        .controller('TestAppController', TestAppController);
    document.addEventListener('DOMContentLoaded', function () {
        angular.bootstrap(document, ['org.yagajs.angular-test']);
    });

},{"../":3,"@yaga/leaflet-driver":19}],2:[function(require,module,exports){
    "use strict";
    var GeojsonLayerDirectiveController = (function () {
        function GeojsonLayerDirectiveController() {
        }
        GeojsonLayerDirectiveController.$inject = ['$scope'];
        return GeojsonLayerDirectiveController;
    }());
    exports.GeojsonLayerDirectiveController = GeojsonLayerDirectiveController;
    var GeojsonLayerDirective = (function () {
        function GeojsonLayerDirective() {
            this.restrict = 'E';
            this.require = '^^yagaMap';
            this.replace = false;
            this.scope = {
                attribution: '=?',
                data: '=',
                name: '=',
                opacity: '=?'
            };
        }
        GeojsonLayerDirective.factory = function () {
            return new GeojsonLayerDirective();
        };
        GeojsonLayerDirective.prototype.compile = function () {
            return {
                pre: function (scope, element, attributes, mapController) {
                    var geojsonLayer = new mapController.yagaDriverService['geojson-layer'].GeojsonLayer({
                        attribution: scope.attribution,
                        name: scope.name,
                        opacity: scope.opacity,
                        type: 'geojson',
                        data: scope.data
                    });
                    geojsonLayer.on('watch:data', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.data = value;
                                });
                            }, 0);
                        }
                    });
                    geojsonLayer.on('watch:attribution', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.attribution = value;
                                });
                            }, 0);
                        }
                    });
                    geojsonLayer.on('watch:opacity', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.opacity = value;
                                });
                            }, 0);
                        }
                    });
                    scope.$watch('data', function () {
                        geojsonLayer.setData(scope.data, [scope]);
                    });
                    scope.$watch('attribution', function () {
                        geojsonLayer.setAttribution(scope.attribution, [scope]);
                    });
                    scope.$watch('opacity', function () {
                        geojsonLayer.setOpacity(scope.opacity, [scope]);
                    });
                    scope.$on('$destroy', function () {
                        geojsonLayer.map.removeLayer(geojsonLayer);
                    });
                    mapController.map.addLayer(geojsonLayer);
                }
            };
        };
        return GeojsonLayerDirective;
    }());
    exports.GeojsonLayerDirective = GeojsonLayerDirective;
    GeojsonLayerDirective.factory.$inject = [];
    angular.module('org.yagajs.geojson-layer', ['org.yagajs.map'])
        .directive('yagaGeojsonLayer', GeojsonLayerDirective.factory);

},{}],3:[function(require,module,exports){
    "use strict";
    var abstraction = require('@yaga/base/abstraction');
    var bounds = require('@yaga/base/bounds');
    var crs = require('@yaga/base/crs');
    var driver = require('@yaga/base/driver');
    var geojsonLayer = require('@yaga/base/geojson-layer');
    var latlng = require('@yaga/base/latlng');
    var layer = require('@yaga/base/layer');
    var map = require('@yaga/base/map');
    var point = require('@yaga/base/point');
    var projection = require('@yaga/base/projection');
    var tileLayer = require('@yaga/base/tile-layer');
    var transformation = require('@yaga/base/transformation');
    var wmsLayer = require('@yaga/base/wms-layer');
    require('./map');
    require('./tile-layer');
    require('./wms-layer');
    require('./geojson-layer');
    angular.module('yaga', [
        'org.yagajs.map',
        'org.yagajs.tile-layer',
        'org.yagajs.wms-layer',
        'org.yagajs.geojson-layer'
    ]);
    module.exports = {
        abstraction: abstraction,
        bounds: bounds,
        crs: crs,
        driver: driver,
        'geojson-layer': geojsonLayer,
        latlng: latlng,
        layer: layer,
        map: map,
        point: point,
        projection: projection,
        'tile-layer': tileLayer,
        transformation: transformation,
        'wms-layer': wmsLayer
    };

},{"./geojson-layer":2,"./map":4,"./tile-layer":85,"./wms-layer":86,"@yaga/base/abstraction":5,"@yaga/base/bounds":6,"@yaga/base/crs":7,"@yaga/base/driver":8,"@yaga/base/geojson-layer":9,"@yaga/base/latlng":10,"@yaga/base/layer":11,"@yaga/base/map":12,"@yaga/base/point":13,"@yaga/base/projection":14,"@yaga/base/tile-layer":15,"@yaga/base/transformation":16,"@yaga/base/wms-layer":17}],4:[function(require,module,exports){
    "use strict";
    var MapDirectiveController = (function () {
        function MapDirectiveController($scope, $timeout, $yagaDriver) {
            this.scope = $scope;
            this.timeoutServiceHelper = $timeout;
            this.yagaDriverService = $yagaDriver;
        }
        MapDirectiveController.$inject = ['$scope', '$timeout', '$yagaDriver'];
        return MapDirectiveController;
    }());
    exports.MapDirectiveController = MapDirectiveController;
    var MapDirective = (function () {
        function MapDirective($yagaDriver) {
            this.restrict = 'E';
            this.replace = true;
            this.scope = {
                center: '=?',
                zoom: '=?',
                layers: '=?'
            };
            this.template = "<div data-yaga-map><span style=\"display: none\" ng-transclude></span></div>";
            this.transclude = true;
            this.driver = $yagaDriver;
            this.controller = MapDirectiveController;
        }
        MapDirective.factory = function ($yagaDriver) {
            return new MapDirective($yagaDriver);
        };
        MapDirective.prototype.compile = function () {
            var _this = this;
            return {
                pre: function (scope, element, attributes, mapController) {
                    scope.center = scope.center || { lat: 0, lng: 0 };
                    scope.zoom = scope.zoom || 0;
                    scope.layers = scope.layers || [];
                    var map = new _this.driver.map.Map({
                        center: scope.center,
                        zoom: scope.zoom,
                        layers: scope.layers,
                        domRoot: element[0],
                    });
                    mapController.map = map;
                    scope.$watchCollection('center', function () {
                        map.setCenter(scope.center, [scope]);
                    });
                    map.on('watch:center', function (latlng, origin) {
                        if (origin.indexOf(scope) !== -1) {
                            return;
                        }
                        mapController.timeoutServiceHelper(function () {
                            scope.$apply(function () {
                                scope.center.lat = latlng.lat;
                                scope.center.lng = latlng.lng;
                            });
                        }, 0);
                    });
                    scope.$watch('zoom', function () {
                        map.setZoom(scope.zoom, [scope]);
                    });
                    map.on('watch:zoom', function (level, origin) {
                        if (origin.indexOf(scope) !== -1) {
                            return;
                        }
                        mapController.timeoutServiceHelper(function () {
                            scope.$apply(function () {
                                scope.zoom = level;
                            });
                        }, 0);
                    });
                    scope.$watch('layers', function () {
                        map.setLayers(scope.layers, [scope]);
                    });
                    map.on('watch:layers', function (layers, origin) {
                        if (origin.indexOf(scope) !== -1) {
                            return;
                        }
                        mapController.timeoutServiceHelper(function () {
                            scope.$apply(function () {
                                scope.layers = map.layers;
                            });
                        }, 0);
                    });
                }
            };
        };
        return MapDirective;
    }());
    exports.MapDirective = MapDirective;
    MapDirective.factory.$inject = ['$yagaDriver'];
    angular.module('org.yagajs.map', [])
        .directive('yagaMap', MapDirective.factory);

},{}],5:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var events_1 = require('events');
    var Abstraction = (function (_super) {
        __extends(Abstraction, _super);
        function Abstraction() {
            _super.apply(this, arguments);
        }
        return Abstraction;
    }(events_1.EventEmitter));
    exports.Abstraction = Abstraction;
    function emitterHelper(self, action, attribute, value, origin) {
        'use strict';
        origin.push(self);
        self.emit(action, attribute, value, origin);
        self.emit('watch', attribute, value, origin);
        self.emit(action + ':' + attribute, value, origin);
        self.emit('watch:' + attribute, value, origin);
    }
    exports.emitterHelper = emitterHelper;
    function getterHelper(self, attribute) {
        'use strict';
        return self[attribute];
    }
    exports.getterHelper = getterHelper;
    function setterHelper(self, attribute, value, origin) {
        'use strict';
        if (origin === void 0) { origin = []; }
        if (origin.indexOf(self) !== -1) {
            return;
        }
        emitterHelper(self, 'set', attribute, value, origin);
        self[attribute] = value;
        return self;
    }
    exports.setterHelper = setterHelper;
    function adderHelper(self, attribute, value, origin) {
        'use strict';
        if (origin === void 0) { origin = []; }
        if (origin.indexOf(self) !== -1) {
            return self;
        }
        emitterHelper(self, 'add', attribute, value, origin);
        self[attribute].push(value);
        return self;
    }
    exports.adderHelper = adderHelper;
    function removerHelper(self, attribute, value, origin) {
        'use strict';
        if (origin === void 0) { origin = []; }
        if (origin.indexOf(self) !== -1) {
            return self;
        }
        emitterHelper(self, 'remove', attribute, value, origin);
        self[attribute].splice(self[attribute].indexOf(value), 1);
        return self;
    }
    exports.removerHelper = removerHelper;
    function enableHelper(self, attribute, origin) {
        'use strict';
        if (origin === void 0) { origin = []; }
        if (origin.indexOf(self) !== -1) {
            return self;
        }
        emitterHelper(self, 'enable', attribute, true, origin);
        self[attribute] = true;
        return self;
    }
    exports.enableHelper = enableHelper;
    function disableHelper(self, attribute, origin) {
        'use strict';
        if (origin === void 0) { origin = []; }
        if (origin.indexOf(self) !== -1) {
            return self;
        }
        emitterHelper(self, 'disable', attribute, false, origin);
        self[attribute] = false;
        return self;
    }
    exports.disableHelper = disableHelper;

},{"events":92}],6:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var point_1 = require('../point');
    var Bounds = (function (_super) {
        __extends(Bounds, _super);
        function Bounds(opts) {
            _super.call(this);
            if (!opts.min && !opts.max) {
                this.empty = true;
            }
            if (opts.max) {
                this.extend(opts.max);
            }
            if (opts.min) {
                this.extend(opts.min);
            }
            if (opts.max && !opts.min) {
                opts.min = opts.max;
            }
            else if (!opts.max && opts.min) {
                opts.max = opts.min;
            }
            if (!point_1.Point.prototype.isPrototypeOf(opts.max)) {
                this.max = new point_1.Point(opts.max);
            }
            else {
                var typeChange = opts.max;
                this.max = typeChange;
            }
            if (!point_1.Point.prototype.isPrototypeOf(opts.min)) {
                this.min = new point_1.Point(opts.min);
            }
            else {
                var typeChange = opts.min;
                this.min = typeChange;
            }
        }
        Bounds.prototype.extend = function (point) {
            this.emit('extend', point);
            if (this.empty) {
                this.empty = false;
                this.max = new point_1.Point(point);
                this.min = new point_1.Point(point);
                return this;
            }
            this.min.setX(Math.min(point.x, this.min.x), [this]);
            this.max.setX(Math.max(point.x, this.max.x), [this]);
            this.min.setY(Math.min(point.y, this.min.y), [this]);
            this.max.setY(Math.max(point.y, this.max.y), [this]);
            return this;
        };
        Bounds.prototype.getCenter = function () {
            return new point_1.Point({
                x: (this.min.getX() + this.max.getX()) / 2,
                y: (this.min.getY() + this.max.getY()) / 2
            });
        };
        Bounds.prototype.getBottomLeft = function () {
            return new point_1.Point({
                x: this.min.getX(),
                y: this.max.getY()
            });
        };
        Bounds.prototype.getTopRight = function () {
            return new point_1.Point({
                x: this.max.getX(),
                y: this.min.getY()
            });
        };
        Bounds.prototype.getTopLeft = function () {
            return new point_1.Point(this.max);
        };
        Bounds.prototype.getBottomRight = function () {
            return new point_1.Point(this.min);
        };
        Bounds.prototype.getSize = function () {
            return new point_1.Point({
                x: this.max.getX(),
                y: this.max.getY()
            });
        };
        Bounds.prototype.setMax = function (point, origin) {
            if (origin === void 0) { origin = []; }
            var typeChange = point;
            if (!point_1.Point.prototype.isPrototypeOf(point)) {
                typeChange = new point_1.Point(point);
            }
            else {
                typeChange = point;
            }
            abstraction_1.setterHelper(this, 'max', typeChange, origin);
            return this;
        };
        Bounds.prototype.setMin = function (point, origin) {
            if (origin === void 0) { origin = []; }
            var typeChange = point;
            if (!point_1.Point.prototype.isPrototypeOf(point)) {
                this.min = new point_1.Point(point);
            }
            else {
                typeChange = point;
            }
            abstraction_1.setterHelper(this, 'min', typeChange, origin);
            return this;
        };
        Bounds.prototype.getMax = function () {
            return abstraction_1.getterHelper(this, 'max');
        };
        Bounds.prototype.getMin = function () {
            return abstraction_1.getterHelper(this, 'min');
        };
        Bounds.prototype.contains = function (point) {
            throw new Error('Not implemented');
        };
        Bounds.prototype.intersects = function (point) {
            throw new Error('Not implemented');
        };
        Bounds.prototype.overlaps = function (point) {
            throw new Error('Not implemented');
        };
        return Bounds;
    }(abstraction_1.Abstraction));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Bounds;

},{"../abstraction":5,"../point":13}],7:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var projection_1 = require('../projection');
    var transformation_1 = require('../transformation');
    var Crs = (function (_super) {
        __extends(Crs, _super);
        function Crs(opts) {
            _super.call(this);
            this.code = opts.code;
            if (transformation_1.Transformation.prototype.isPrototypeOf(opts.transformation)) {
                var typeChange = opts.transformation;
                this.transformation = typeChange;
            }
            else {
                this.transformation = new transformation_1.Transformation(opts.transformation);
            }
            this.projection = opts.projection;
        }
        return Crs;
    }(abstraction_1.Abstraction));
    exports.Crs = Crs;
    var crsDict = {};
    function registerCrs(type, crs) {
        'use strict';
        crsDict[type] = crs;
    }
    exports.registerCrs = registerCrs;
    function hasCrs(name) {
        'use strict';
        return crsDict.hasOwnProperty(name);
    }
    exports.hasCrs = hasCrs;
    function getCrs(name) {
        'use strict';
        return crsDict[name];
    }
    exports.getCrs = getCrs;
    registerCrs('EPSG:3395', new Crs({
        code: 'EPSG:3395',
        projection: projection_1.mercator,
        transformation: {
            a: 0.5 / (Math.PI * projection_1.Mercator.R),
            b: 0.5,
            c: -(0.5 / (Math.PI * projection_1.Mercator.R)),
            d: 0.5
        }
    }));
    registerCrs('EPSG:3857', new Crs({
        code: 'EPSG:3857',
        projection: projection_1.sphericalMercator,
        transformation: {
            a: 0.5 / (Math.PI * projection_1.SphericalMercator.R),
            b: 0.5,
            c: -(0.5 / (Math.PI * projection_1.SphericalMercator.R)),
            d: 0.5
        }
    }));
    registerCrs('EPSG:900913', new Crs({
        code: 'EPSG:900913',
        projection: projection_1.sphericalMercator,
        transformation: {
            a: 0.5 / (Math.PI * projection_1.SphericalMercator.R),
            b: 0.5,
            c: -(0.5 / (Math.PI * projection_1.SphericalMercator.R)),
            d: 0.5
        }
    }));
    registerCrs('EPSG:4326', new Crs({
        code: 'EPSG:4326',
        projection: projection_1.sphericalMercator,
        transformation: {
            a: 0.5 / (Math.PI * projection_1.SphericalMercator.R),
            b: 0.5,
            c: -(0.5 / (Math.PI * projection_1.SphericalMercator.R)),
            d: 0.5
        }
    }));

},{"../abstraction":5,"../projection":14,"../transformation":16}],8:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var Driver = (function (_super) {
        __extends(Driver, _super);
        function Driver() {
            _super.apply(this, arguments);
        }
        Driver.prototype.propagateChange = function () {
            var _this = this;
            this.changePropagated = true;
            setTimeout(function () {
                _this.changePropagated = false;
            }, 0);
        };
        return Driver;
    }(abstraction_1.Abstraction));
    exports.Driver = Driver;

},{"../abstraction":5}],9:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var layer_1 = require('../layer');
    var GeojsonLayer = (function (_super) {
        __extends(GeojsonLayer, _super);
        function GeojsonLayer(opts) {
            opts.type = opts.type || 'geojson';
            _super.call(this, opts);
            this.style = opts.style || {};
            this.data = opts.data || {
                    features: [],
                    type: 'FeatureCollection'
                };
            this.styler = opts.styler || (function (feature, defaultStyle) {
                    return defaultStyle;
                });
        }
        GeojsonLayer.prototype.setData = function (data, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'data', data, origin);
            return this;
        };
        GeojsonLayer.prototype.addData = function (data, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.emitterHelper(this, 'add', 'data', data, [this]);
            this.data.features.push.apply(this.data.features, data.features);
            return this;
        };
        GeojsonLayer.prototype.removeData = function (data, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.emitterHelper(this, 'remove', 'data', data, [this]);
            for (var i = 0; i < data.features.length; i += 1) {
                var position = this.data.features.indexOf(data.features[i]);
                if (position !== -1) {
                    this.data.features.splice(position, 1);
                }
            }
            return this;
        };
        GeojsonLayer.prototype.getData = function () {
            return abstraction_1.getterHelper(this, 'data');
        };
        GeojsonLayer.prototype.setStyle = function (data, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'style', data, origin);
            return this;
        };
        GeojsonLayer.prototype.getStyle = function () {
            return abstraction_1.getterHelper(this, 'style');
        };
        GeojsonLayer.prototype.setStyler = function (data, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'styler', data, origin);
            return this;
        };
        GeojsonLayer.prototype.getStyler = function () {
            return abstraction_1.getterHelper(this, 'styler');
        };
        return GeojsonLayer;
    }(layer_1.Layer));
    exports.GeojsonLayer = GeojsonLayer;
    layer_1.registerLayerType('geojson', GeojsonLayer);

},{"../abstraction":5,"../layer":11}],10:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var LatLng = (function (_super) {
        __extends(LatLng, _super);
        function LatLng(opts) {
            _super.call(this);
            this.timestamp = opts.timestamp || Date.now();
            this.accuracy = opts.accuracy;
            this.altitudeAccuracy = opts.altitudeAccuracy;
            this.lat = opts.lat;
            this.lng = opts.lng;
            this.altitude = opts.altitude;
        }
        LatLng.prototype.setLat = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'lat', value, origin);
            return this;
        };
        LatLng.prototype.getLat = function () {
            return abstraction_1.getterHelper(this, 'lat');
        };
        LatLng.prototype.setLng = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'lng', value, origin);
            return this;
        };
        LatLng.prototype.getLng = function () {
            return abstraction_1.getterHelper(this, 'lng');
        };
        LatLng.prototype.setAltitude = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'altitide', value, origin);
            return this;
        };
        LatLng.prototype.getAltitude = function () {
            return abstraction_1.getterHelper(this, 'altitide');
        };
        LatLng.prototype.distanceTo = function (otherLatLng) {
            var earthRadius = 6371000, rad = Math.PI / 180, lat1 = this.lat * rad, lat2 = otherLatLng.lat * rad, a = Math.sin(lat1) * Math.sin(lat2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.cos((otherLatLng.lng - this.lng) * rad);
            return earthRadius * Math.acos(Math.min(a, 1));
        };
        LatLng.prototype.equals = function (otherLatLng, maxMargin) {
            if (maxMargin === void 0) { maxMargin = 1.0E-9; }
            var margin = Math.max(Math.abs(this.lat - otherLatLng.lat), Math.abs(this.lng - otherLatLng.lng));
            return margin <= maxMargin;
        };
        return LatLng;
    }(abstraction_1.Abstraction));
    exports.LatLng = LatLng;

},{"../abstraction":5}],11:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var Layer = (function (_super) {
        __extends(Layer, _super);
        function Layer(opts) {
            _super.call(this);
            if (!opts.hasOwnProperty('opacity') || opts.opacity === undefined) {
                opts.opacity = 1;
            }
            this.type = opts.type;
            this.name = opts.name;
            this.attribution = opts.attribution;
            this.opacity = opts.opacity;
            this.minZoom = opts.minZoom;
            this.maxZoom = opts.maxZoom;
        }
        Layer.prototype.setName = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'name', value, origin);
            return this;
        };
        Layer.prototype.setAttribution = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'attribution', value, origin);
            return this;
        };
        Layer.prototype.setOpacity = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'opacity', value, origin);
            return this;
        };
        Layer.prototype.setMaxZoom = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'maxZoom', value, origin);
            return this;
        };
        Layer.prototype.setMinZoom = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'minZoom', value, origin);
            return this;
        };
        Layer.prototype.setMaxNativeZoom = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'maxNativeZoom', value, origin);
            return this;
        };
        Layer.prototype.getName = function () {
            return abstraction_1.getterHelper(this, 'name');
        };
        Layer.prototype.getAttribution = function () {
            return abstraction_1.getterHelper(this, 'attribution');
        };
        Layer.prototype.getOpacity = function () {
            return abstraction_1.getterHelper(this, 'opacity');
        };
        Layer.prototype.getMaxZoom = function () {
            return abstraction_1.getterHelper(this, 'maxZoom');
        };
        Layer.prototype.getMinZoom = function () {
            return abstraction_1.getterHelper(this, 'minZoom');
        };
        Layer.prototype.getType = function () {
            return abstraction_1.getterHelper(this, 'type');
        };
        Layer.prototype.getMaxNativeZoom = function () {
            return abstraction_1.getterHelper(this, 'maxNativeZoom');
        };
        return Layer;
    }(abstraction_1.Abstraction));
    exports.Layer = Layer;
    var layerDict = {};
    function createLayer(opts, map) {
        'use strict';
        var tmp;
        if (!layerDict[opts.type]) {
            console.log(opts, layerDict);
            throw new Error('There is no registered layer for type "' + opts.type + '"');
        }
        if (layerDict[opts.type].prototype.isPrototypeOf(opts)) {
            tmp = opts;
        }
        else {
            tmp = new layerDict[opts.type](opts);
        }
        tmp.map = map;
        return tmp;
    }
    exports.createLayer = createLayer;
    function registerLayerType(type, driver) {
        'use strict';
        layerDict[type] = driver;
    }
    exports.registerLayerType = registerLayerType;
    function hasLayerType(type) {
        'use strict';
        return !!layerDict[type];
    }
    exports.hasLayerType = hasLayerType;
    function getLayerType(type) {
        'use strict';
        return layerDict[type];
    }
    exports.getLayerType = getLayerType;

},{"../abstraction":5}],12:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var latlng_1 = require('../latlng');
    var layer_1 = require('../layer');
    var Map = (function (_super) {
        __extends(Map, _super);
        function Map(opts) {
            _super.call(this);
            var fallbackDom = null;
            if (typeof document === 'object' && typeof document.createElement === 'function') {
                fallbackDom = document.createElement('div');
            }
            this.center = new latlng_1.LatLng(opts.center || { lat: 0, lng: 0 });
            this.domRoot = opts.domRoot || fallbackDom;
            this.layers = opts.layers || [];
            this.zoom = opts.zoom || 1;
        }
        Map.prototype.setCenter = function (value, origin) {
            if (origin === void 0) { origin = []; }
            this.center.setLat(value.lat);
            this.center.setLng(value.lng);
            abstraction_1.setterHelper(this, 'center', this.center, origin);
        };
        Map.prototype.getCenter = function () {
            return abstraction_1.getterHelper(this, 'center');
        };
        Map.prototype.setZoom = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'zoom', value, origin);
        };
        Map.prototype.getZoom = function () {
            return abstraction_1.getterHelper(this, 'zoom');
        };
        Map.prototype.getDomRoot = function () {
            return abstraction_1.getterHelper(this, 'domRoot');
        };
        Map.prototype.addLayer = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.adderHelper(this, 'layers', layer_1.createLayer(value, this), origin);
        };
        ;
        Map.prototype.removeLayer = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.removerHelper(this, 'layers', value, origin);
        };
        ;
        Map.prototype.getLayers = function () {
            return abstraction_1.getterHelper(this, 'layers');
        };
        ;
        Map.prototype.setLayers = function (value, origin) {
            if (value === void 0) { value = []; }
            if (origin === void 0) { origin = []; }
            var i, layers = [];
            for (i = 0; i < value.length; i += 1) {
                layers.push(layer_1.createLayer(value[i], this));
            }
            abstraction_1.setterHelper(this, 'layers', layers, origin);
        };
        ;
        return Map;
    }(abstraction_1.Abstraction));
    exports.Map = Map;

},{"../abstraction":5,"../latlng":10,"../layer":11}],13:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var Point = (function (_super) {
        __extends(Point, _super);
        function Point(opts, round) {
            _super.call(this);
            this.x = (round ? Math.round(opts.x) : opts.x);
            this.y = (round ? Math.round(opts.y) : opts.y);
        }
        Point.prototype.setX = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'x', value, origin);
            return this;
        };
        Point.prototype.getX = function () {
            return abstraction_1.getterHelper(this, 'x');
        };
        Point.prototype.setY = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'y', value, origin);
            return this;
        };
        Point.prototype.getY = function () {
            return abstraction_1.getterHelper(this, 'y');
        };
        Point.prototype.clone = function () {
            this.emit('clone');
            return new Point(this);
        };
        Point.prototype.add = function (point, origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('add', point, origin);
            this.silentAdd(point);
            this.emit('change');
            return this;
        };
        Point.prototype.silentAdd = function (point) {
            this.x += point.x;
            this.y += point.y;
            return this;
        };
        Point.prototype.subtract = function (point, origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('subtract', point, origin);
            this.silentSubtract(point);
            this.emit('change');
            return this;
        };
        Point.prototype.silentSubtract = function (point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
        };
        Point.prototype.scaleBy = function (point, origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('scaleBy', point, origin);
            this.silentScaleBy(point);
            this.emit('change');
            return this;
        };
        Point.prototype.silentScaleBy = function (point) {
            this.x *= point.x;
            this.y *= point.y;
            return this;
        };
        Point.prototype.unscaleBy = function (point, origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('unscaleBy', point, origin);
            this.silentUnscaleBy(point);
            this.emit('change');
            return this;
        };
        Point.prototype.silentUnscaleBy = function (point) {
            this.x = this.x / point.x;
            this.y = this.y / point.y;
            return this;
        };
        Point.prototype.divideBy = function (num, origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('divideBy', num, origin);
            this.silentDivideBy(num);
            this.emit('change');
            return this;
        };
        Point.prototype.silentDivideBy = function (num) {
            this.x /= num;
            this.y /= num;
            return this;
        };
        Point.prototype.multiplyBy = function (num, origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('multiplyBy', num, origin);
            this.silentMultiplyBy(num);
            this.emit('change');
            return this;
        };
        Point.prototype.silentMultiplyBy = function (num) {
            this.x *= num;
            this.y *= num;
            return this;
        };
        Point.prototype.round = function (origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('round', this, origin);
            this.silentRound();
            this.emit('change');
            return this;
        };
        Point.prototype.silentRound = function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        };
        Point.prototype.floor = function (origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('floor', this, origin);
            this.silentFloor();
            this.emit('change');
            return this;
        };
        Point.prototype.silentFloor = function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        };
        Point.prototype.ceil = function (origin) {
            if (origin === void 0) { origin = []; }
            origin.push(this);
            this.emit('ceil', this, origin);
            this.silentCeil();
            this.emit('change');
            return this;
        };
        Point.prototype.silentCeil = function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        };
        Point.prototype.distanceTo = function (point, withAltitude) {
            var x = point.x - this.x, y = point.y - this.y;
            return Math.sqrt(x * x + y * y);
        };
        Point.prototype.equals = function (point) {
            return point.x === this.x && point.y === this.y;
        };
        Point.prototype.contains = function (point) {
            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
        };
        return Point;
    }(abstraction_1.Abstraction));
    exports.Point = Point;

},{"../abstraction":5}],14:[function(require,module,exports){
    "use strict";
    var latlng_1 = require('../latlng');
    var point_1 = require('../point');
    var LonLat = (function () {
        function LonLat() {
        }
        LonLat.prototype.project = function (latlng) {
            return new point_1.Point({ x: latlng.lng, y: latlng.lat });
        };
        LonLat.prototype.unproject = function (point) {
            return new latlng_1.LatLng({ lat: point.y, lng: point.x });
        };
        return LonLat;
    }());
    exports.LonLat = LonLat;
    var Mercator = (function () {
        function Mercator() {
        }
        Mercator.prototype.project = function (latlng) {
            var d = Math.PI / 180, r = Mercator.R, y = latlng.lat * d, tmp = Mercator.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y), ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y = -r * Math.log(Math.max(ts, 1E-10));
            return new point_1.Point({ x: latlng.lng * d * r, y: y });
        };
        Mercator.prototype.unproject = function (point) {
            var d = 180 / Math.PI, r = Mercator.R, tmp = Mercator.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i = 0, dphi = 0.1, con = void 0; i < 15 && Math.abs(dphi) > 1e-7; i += 1) {
                con = e * Math.sin(phi);
                con = Math.pow((1 - con) / (1 + con), e / 2);
                dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
                phi += dphi;
            }
            return new latlng_1.LatLng({ lat: phi * d, lng: point.x * d / r });
        };
        Mercator.R = 6378137;
        Mercator.R_MINOR = 6356752.314245179;
        return Mercator;
    }());
    exports.Mercator = Mercator;
    exports.mercator = new Mercator();
    var SphericalMercator = (function () {
        function SphericalMercator() {
        }
        SphericalMercator.prototype.project = function (latlng) {
            var d = Math.PI / 180, max = SphericalMercator.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
            return new point_1.Point({
                x: SphericalMercator.R * latlng.lng * d,
                y: SphericalMercator.R * Math.log((1 + sin) / (1 - sin)) / 2
            });
        };
        SphericalMercator.prototype.unproject = function (point) {
            var d = 180 / Math.PI;
            return new latlng_1.LatLng({
                lat: (2 * Math.atan(Math.exp(point.y / SphericalMercator.R)) - (Math.PI / 2)) * d,
                lng: point.x * d / SphericalMercator.R
            });
        };
        SphericalMercator.R = 6378137;
        SphericalMercator.MAX_LATITUDE = 85.0511287798;
        return SphericalMercator;
    }());
    exports.SphericalMercator = SphericalMercator;
    exports.sphericalMercator = new SphericalMercator();

},{"../latlng":10,"../point":13}],15:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var layer_1 = require('../layer');
    var TileLayer = (function (_super) {
        __extends(TileLayer, _super);
        function TileLayer(opts) {
            opts.type = 'tile';
            _super.call(this, opts);
            this.url = opts.url;
        }
        TileLayer.prototype.setUrl = function (url, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'url', url, origin);
            return this;
        };
        TileLayer.prototype.getUrl = function () {
            return abstraction_1.getterHelper(this, 'url');
        };
        return TileLayer;
    }(layer_1.Layer));
    exports.TileLayer = TileLayer;
    layer_1.registerLayerType('tile', TileLayer);

},{"../abstraction":5,"../layer":11}],16:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var Transformation = (function (_super) {
        __extends(Transformation, _super);
        function Transformation(opts) {
            _super.call(this);
            this.a = opts.a || 1;
            this.b = opts.b || 0;
            this.c = opts.c || 1;
            this.d = opts.d || 0;
        }
        Transformation.prototype.transform = function (point, scale, clone) {
            if (scale === void 0) { scale = 1; }
            if (clone === void 0) { clone = false; }
            var result = clone ? point.clone() : point;
            this.emit('beforeTransform', result, scale, clone);
            point.x = scale * (this.a * point.x + this.b);
            point.y = scale * (this.c * point.y + this.d);
            this.emit('afterTransform', result, scale, clone);
            return result;
        };
        Transformation.prototype.untransform = function (point, scale, clone) {
            if (scale === void 0) { scale = 1; }
            if (clone === void 0) { clone = false; }
            var result = clone ? point.clone() : point;
            this.emit('beforeUntransform', result, scale, clone);
            point.x = (point.x / scale - this.b) / this.a;
            point.y = (point.y / scale - this.d) / this.c;
            this.emit('afterUntransform', result, scale, clone);
            return result;
        };
        Transformation.prototype.setA = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'a', value, origin);
        };
        Transformation.prototype.setB = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'b', value, origin);
        };
        Transformation.prototype.setC = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'c', value, origin);
        };
        Transformation.prototype.setD = function (value, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'd', value, origin);
        };
        Transformation.prototype.getA = function () {
            return abstraction_1.getterHelper(this, 'a');
        };
        Transformation.prototype.getB = function () {
            return abstraction_1.getterHelper(this, 'b');
        };
        Transformation.prototype.getC = function () {
            return abstraction_1.getterHelper(this, 'c');
        };
        Transformation.prototype.getD = function () {
            return abstraction_1.getterHelper(this, 'd');
        };
        return Transformation;
    }(abstraction_1.Abstraction));
    exports.Transformation = Transformation;

},{"../abstraction":5}],17:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var abstraction_1 = require('../abstraction');
    var layer_1 = require('../layer');
    var cheerio = require('cheerio');
    var WmsLayer = (function (_super) {
        __extends(WmsLayer, _super);
        function WmsLayer(opts) {
            opts.type = 'wms';
            _super.call(this, opts);
            this.url = opts.url;
            this.layers = opts.layers || [];
        }
        WmsLayer.prototype.setUrl = function (url, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'url', url, origin);
        };
        WmsLayer.prototype.getUrl = function () {
            return abstraction_1.getterHelper(this, 'url');
        };
        WmsLayer.prototype.setLayers = function (layers, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.setterHelper(this, 'layers', layers, origin);
        };
        WmsLayer.prototype.addLayer = function (layer, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.adderHelper(this, 'layers', layer, origin);
        };
        WmsLayer.prototype.removeLayer = function (layer, origin) {
            if (origin === void 0) { origin = []; }
            abstraction_1.removerHelper(this, 'layers', layer, origin);
        };
        WmsLayer.prototype.getLayers = function () {
            return abstraction_1.getterHelper(this, 'layers');
        };
        WmsLayer.prototype.parseCapabilities = function (xml) {
            var _this = this;
            var $ = cheerio.load(xml);
            this.availableLayers = [];
            $('Layer > Name').each(function (i, elem) {
                _this.availableLayers.push($(elem).text());
            });
            $('Layer').each(function (i, elem) {
                var $elem = $(elem);
                $elem.find('Name');
                $elem.find('Layer');
            });
            if (!this.layers.length) {
                this.layers.push.apply(this.layers, this.availableLayers);
            }
        };
        return WmsLayer;
    }(layer_1.Layer));
    exports.WmsLayer = WmsLayer;
    layer_1.registerLayerType('wms', WmsLayer);

},{"../abstraction":5,"../layer":11,"cheerio":27}],18:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var leaflet_1 = require('leaflet');
    var geojson_layer_1 = require('@yaga/base/geojson-layer');
    var layer_1 = require('../layer');
    var GeojsonLayer = (function (_super) {
        __extends(GeojsonLayer, _super);
        function GeojsonLayer(opts) {
            var _this = this;
            var refreshData = function () {
                if (!_this.changePropagated) {
                    _this.setData(_this.target.toGeoJSON(), [_this.target]);
                }
            };
            opts.type = opts.type || 'geojson';
            _super.call(this, opts);
            var self = this;
            this.target = leaflet_1.geoJson(this.data, {
                onEachFeature: function (data, layer) {
                    layer.on('move', function () {
                        refreshData();
                    });
                    self.emit('feature', { data: data, layer: layer });
                },
                style: function (feature) {
                    return self.getStyler()(feature, self.getStyle());
                }
            });
            this.target.on('layeradd', refreshData);
            this.target.on('layerremove', refreshData);
        }
        GeojsonLayer.prototype.setData = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setData.call(this, value, origin);
            if (origin.indexOf(this.target) === -1) {
                this.refresh();
            }
            return this;
        };
        GeojsonLayer.prototype.addData = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.addData.call(this, value, origin);
            if (origin.indexOf(this.target) === -1) {
                this.refresh();
            }
            return this;
        };
        GeojsonLayer.prototype.removeData = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.removeData.call(this, value, origin);
            if (origin.indexOf(this.target) === -1) {
                this.refresh();
            }
            return this;
        };
        GeojsonLayer.prototype.setOpacity = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setOpacity.call(this, value, origin);
            for (var hash in this.target['_layers']) {
                if (this.target['_layers'].hasOwnProperty(hash)) {
                    if (this.target['_layers'][hash]._container) {
                        this.target['_layers'][hash]._container.style.opacity = value.toString();
                    }
                    else {
                        console.warn('No DOM-Element available to change opacity');
                    }
                }
            }
            return this;
        };
        GeojsonLayer.prototype.setStyle = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setStyle.call(this, value, origin);
            this.refresh();
            return this;
        };
        GeojsonLayer.prototype.propagateChange = function () {
            var _this = this;
            this.changePropagated = true;
            setTimeout(function () {
                _this.changePropagated = false;
            }, 0);
        };
        GeojsonLayer.prototype.refresh = function () {
            this.propagateChange();
            this.target.clearLayers();
            this.target.addData(this.data);
        };
        return GeojsonLayer;
    }(geojson_layer_1.GeojsonLayer));
    exports.GeojsonLayer = GeojsonLayer;
    layer_1.registerLayerType('geojson', GeojsonLayer);

},{"../layer":21,"@yaga/base/geojson-layer":9,"leaflet":80}],19:[function(require,module,exports){
    "use strict";
    var abstraction = require('@yaga/base/abstraction');
    var bounds = require('@yaga/base/bounds');
    var crs = require('@yaga/base/crs');
    var driver = require('@yaga/base/driver');
    var geojsonLayer = require('./geojson-layer');
    var latlng = require('./latlng');
    var layer = require('./layer');
    var map = require('./map');
    var point = require('./point');
    var projection = require('@yaga/base/projection');
    var tileLayer = require('./tile-layer');
    var transformation = require('@yaga/base/transformation');
    var wmsLayer = require('./wms-layer');
    module.exports = {
        abstraction: abstraction,
        bounds: bounds,
        crs: crs,
        driver: driver,
        'geojson-layer': geojsonLayer,
        latlng: latlng,
        layer: layer,
        map: map,
        point: point,
        projection: projection,
        'tile-layer': tileLayer,
        transformation: transformation,
        'wms-layer': wmsLayer
    };

},{"./geojson-layer":18,"./latlng":20,"./layer":21,"./map":22,"./point":23,"./tile-layer":24,"./wms-layer":25,"@yaga/base/abstraction":5,"@yaga/base/bounds":6,"@yaga/base/crs":7,"@yaga/base/driver":8,"@yaga/base/projection":14,"@yaga/base/transformation":16}],20:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var leaflet_1 = require('leaflet');
    var latlng_1 = require('@yaga/base/latlng');
    var LatLng = (function (_super) {
        __extends(LatLng, _super);
        function LatLng(opts) {
            _super.call(this, opts);
            this.target = leaflet_1.latLng({ lat: this.lat, lng: this.lng });
        }
        LatLng.prototype.setLat = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setLat.call(this, value, origin);
            this.target.lat = this.lat;
            return this;
        };
        LatLng.prototype.setLng = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setLng.call(this, value, origin);
            this.target.lng = this.lng;
            return this;
        };
        return LatLng;
    }(latlng_1.LatLng));
    exports.LatLng = LatLng;

},{"@yaga/base/latlng":10,"leaflet":80}],21:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var layer_1 = require('@yaga/base/layer');
    var Layer = (function (_super) {
        __extends(Layer, _super);
        function Layer(opts) {
            _super.call(this, opts);
        }
        return Layer;
    }(layer_1.Layer));
    exports.Layer = Layer;
    var layerDict = {};
    function createLayer(opts, map) {
        var tmp;
        if (!layerDict[opts.type]) {
            throw new Error('There is no registered layer for type "' + opts.type + '"');
        }
        if (layerDict[opts.type].prototype.isPrototypeOf(opts)) {
            tmp = opts;
        }
        else {
            tmp = new layerDict[opts.type](opts);
        }
        tmp.map = map;
        return tmp;
    }
    exports.createLayer = createLayer;
    function registerLayerType(type, driver) {
        layerDict[type] = driver;
    }
    exports.registerLayerType = registerLayerType;
    function hasLayerType(type) {
        return !!layerDict[type];
    }
    exports.hasLayerType = hasLayerType;
    function getLayerType(type) {
        return layerDict[type];
    }
    exports.getLayerType = getLayerType;

},{"@yaga/base/layer":11}],22:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var leaflet_1 = require('leaflet');
    var map_1 = require('@yaga/base/map');
    var latlng_1 = require('../latlng');
    var layer_1 = require('../layer');
    var Map = (function (_super) {
        __extends(Map, _super);
        function Map(opts) {
            var _this = this;
            opts.domRoot = opts.domRoot || document.createElement('div');
            _super.call(this, opts);
            var layers = [];
            for (var i = 0; i < this.layers.length; i += 1) {
                if (!layer_1.Layer.prototype.isPrototypeOf(this.layers[i])) {
                    this.layers[i] = layer_1.createLayer(this.layers[i], this);
                }
                layers.push(this.layers[i].target);
            }
            this.center = new latlng_1.LatLng(this.center);
            var declarationOnlyAcceptsStrings = opts.domRoot;
            this.target = leaflet_1.map(declarationOnlyAcceptsStrings, {
                center: this.center.target,
                layers: layers,
                zoom: this.zoom
            });
            this.target.on('zoomend', function () {
                _this.setZoom(_this.target.getZoom(), [_this.target]);
            });
            this.target.on('move', function () {
                var tmpLatLng = _this.target.getCenter(), options = {
                    lat: tmpLatLng.lat,
                    lng: tmpLatLng.lng
                };
                _this.setCenter(options, [_this.target]);
            });
            opts.domRoot.addEventListener('DOMNodeInserted', function () {
                _this.target.invalidateSize(true);
            });
        }
        Map.prototype.setCenter = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setCenter.call(this, value, origin);
            if (origin.indexOf(this.target) === -1) {
                this.target.panTo(this.center.target);
            }
        };
        Map.prototype.getCenter = function () {
            var tmp = _super.prototype.getCenter.call(this);
            return tmp;
        };
        Map.prototype.setZoom = function (zoom, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setZoom.call(this, zoom, origin);
            if (origin.indexOf(this.target) === -1) {
                this.target.setZoom(zoom);
            }
        };
        Map.prototype.addLayer = function (layer, origin) {
            if (origin === void 0) { origin = []; }
            var drivenLayer = layer_1.createLayer(layer, this);
            _super.prototype.addLayer.call(this, drivenLayer, origin);
            var self = this;
            setTimeout(function(){self.target.addLayer(drivenLayer.target);}, 0);
        };
        Map.prototype.removeLayer = function (layer, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.removeLayer.call(this, layer, origin);
            this.target.removeLayer(layer.target);
        };
        Map.prototype.setLayers = function (layers, origin) {
            var _this = this;
            if (origin === void 0) { origin = []; }
            var drivenLayers = [];
            for (var i = 0; i < layers.length; i += 1) {
                drivenLayers.push(layer_1.createLayer(layers[i], this));
            }
            _super.prototype.setLayers.call(this, drivenLayers, origin);
            this.target.eachLayer(function (layer) {
                _this.target.removeLayer(layer);
            });
            for (var i = 0; i < this.layers.length; i += 1) {
                this.target.addLayer(this.layers[i].target);
            }
        };
        return Map;
    }(map_1.Map));
    exports.Map = Map;

},{"../latlng":20,"../layer":21,"@yaga/base/map":12,"leaflet":80}],23:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var leaflet_1 = require('leaflet');
    var point_1 = require('@yaga/base/point');
    var Point = (function (_super) {
        __extends(Point, _super);
        function Point(opts) {
            _super.call(this, opts);
            this.target = leaflet_1.point(this.x, this.y);
        }
        Point.prototype.setX = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setX.call(this, value, origin);
            this.target.x = this.x;
            return this;
        };
        Point.prototype.setY = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setY.call(this, value, origin);
            this.target.y = this.y;
            return this;
        };
        return Point;
    }(point_1.Point));
    exports.Point = Point;

},{"@yaga/base/point":13,"leaflet":80}],24:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var leaflet_1 = require('leaflet');
    var tile_layer_1 = require('@yaga/base/tile-layer');
    var layer_1 = require('../layer');
    var TileLayer = (function (_super) {
        __extends(TileLayer, _super);
        function TileLayer(opts) {
            _super.call(this, opts);
            this.target = leaflet_1.tileLayer(this.url, {
                attribution: this.attribution,
                maxZoom: this.maxZoom,
                minZoom: this.minZoom,
                opacity: this.opacity
            });
        }
        TileLayer.prototype.setOpacity = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setOpacity.call(this, value, origin);
            if (origin.indexOf(this.target) === -1) {
                this.target.setOpacity(value);
            }
            return this;
        };
        TileLayer.prototype.setUrl = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setUrl.call(this, value, origin);
            if (origin.indexOf(this.target) === -1) {
                this.target.setUrl(value);
            }
            return this;
        };
        TileLayer.prototype.setAttribution = function (value, origin) {
            if (origin === void 0) { origin = []; }
            var oldAttribution = this.getAttribution(), num;
            _super.prototype.setAttribution.call(this, value, origin);
            if (!this.map) {
                console.warn('There is no map!');
                return this;
            }
            num = this.map.target.attributionControl['_attributions'][oldAttribution];
            delete this.map.target.attributionControl['_attributions'][oldAttribution];
            this.map.target.attributionControl['_attributions'][value] = num;
            this.map.target.attributionControl['_update']();
            return this;
        };
        return TileLayer;
    }(tile_layer_1.TileLayer));
    exports.TileLayer = TileLayer;
    layer_1.registerLayerType('tile', TileLayer);

},{"../layer":21,"@yaga/base/tile-layer":15,"leaflet":80}],25:[function(require,module,exports){
    "use strict";
    var __extends = (this && this.__extends) || function (d, b) {
            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    var leaflet_1 = require('leaflet');
    var wms_layer_1 = require('@yaga/base/wms-layer');
    var layer_1 = require('../layer');
    var WmsLayer = (function (_super) {
        __extends(WmsLayer, _super);
        function WmsLayer(opts) {
            opts.type = opts.type || 'wms';
            _super.call(this, opts);
            this.layers = this.layers || [];
            this.target = leaflet_1.tileLayer.wms(this.url, {
                layers: this.layers.join(','),
            });
        }
        WmsLayer.prototype.refreshWmsParams = function () {
            console.log('asdasdasdasd', this.layers, this);
            var incompatibleDeclarationHelper = {
                layers: this.layers.join(','),
            };

            this.target.setParams(incompatibleDeclarationHelper);
        };
        WmsLayer.prototype.setOpacity = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setOpacity.call(this, value, origin);
            if (origin.indexOf(this.target) === -1) {
                this.target.setOpacity(value);
            }
            return this;
        };
        WmsLayer.prototype.setUrl = function (value, origin) {
            if (origin === void 0) { origin = []; }
            _super.prototype.setUrl.call(this, value, origin);
            if (origin.indexOf(this.target) === -1) {
                this.target.setUrl(value);
            }
            return this;
        };
        WmsLayer.prototype.setAttribution = function (value, origin) {
            if (origin === void 0) { origin = []; }
            var oldAttribution = this.getAttribution(), num;
            _super.prototype.setAttribution.call(this, value, origin);
            if (!this.map) {
                console.warn('There is no map!');
                return this;
            }
            num = this.map.target.attributionControl['_attributions'][oldAttribution];
            delete this.map.target.attributionControl['_attributions'][oldAttribution];
            this.map.target.attributionControl['_attributions'][value] = num;
            this.map.target.attributionControl['_update']();
            return this;
        };
        WmsLayer.prototype.setLayers = function (value, origin) {
            if (origin === void 0) { origin = []; }
            console.log('set', 'layers2', value, this.layers);
            _super.prototype.setLayers.call(this, value, origin);
            this.refreshWmsParams();
            console.log('set', 'layers3', value, this.layers);
            return this;
        };
        WmsLayer.prototype.requestCapabilities = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var ajax = new XMLHttpRequest();
                ajax.open('GET', _this.url);
                ajax.send();
                ajax.onreadystatechange = function () {
                    if (ajax.readyState === 4) {
                        if (ajax.status === 200) {
                            _this.parseCapabilities(ajax.responseText);
                            resolve(_this.availableLayers);
                        }
                        else {
                            reject(new Error('Wrong HTTP Status-Code: ' + ajax.status));
                        }
                    }
                };
            });
        };
        return WmsLayer;
    }(wms_layer_1.WmsLayer));
    exports.WmsLayer = WmsLayer;
    layer_1.registerLayerType('wms', WmsLayer);

},{"../layer":21,"@yaga/base/wms-layer":17,"leaflet":80}],26:[function(require,module,exports){
    module.exports = {
        trueFunc: function trueFunc(){
            return true;
        },
        falseFunc: function falseFunc(){
            return false;
        }
    };
},{}],27:[function(require,module,exports){
    /**
     * Export cheerio (with )
     */

    exports = module.exports = require('./lib/cheerio');

    /*
     Export the version
     */

    exports.version = require('./package').version;

},{"./lib/cheerio":33,"./package":37}],28:[function(require,module,exports){
    var _ = require('lodash'),
        $ = require('../static'),
        utils = require('../utils'),
        isTag = utils.isTag,
        domEach = utils.domEach,
        hasOwn = Object.prototype.hasOwnProperty,
        camelCase = utils.camelCase,
        cssCase = utils.cssCase,
        rspace = /\s+/,
        dataAttrPrefix = 'data-',

    // Lookup table for coercing string data-* attributes to their corresponding
    // JavaScript primitives
        primitives = {
            null: null,
            true: true,
            false: false
        },

    // Attributes that are booleans
        rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
    // Matches strings that look like JSON objects or arrays
        rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/;


    var getAttr = function(elem, name) {
        if (!elem || !isTag(elem)) return;

        if (!elem.attribs) {
            elem.attribs = {};
        }

        // Return the entire attribs object if no attribute specified
        if (!name) {
            return elem.attribs;
        }

        if (hasOwn.call(elem.attribs, name)) {
            // Get the (decoded) attribute
            return rboolean.test(name) ? name : elem.attribs[name];
        }

        // Mimic the DOM and return text content as value for `option's`
        if (elem.name === 'option' && name === 'value') {
            return $.text(elem.children);
        }
    };

    var setAttr = function(el, name, value) {

        if (value === null) {
            removeAttribute(el, name);
        } else {
            el.attribs[name] = value+'';
        }
    };

    exports.attr = function(name, value) {
        // Set the value (with attr map support)
        if (typeof name === 'object' || value !== undefined) {
            if (typeof value === 'function') {
                return domEach(this, function(i, el) {
                    setAttr(el, name, value.call(el, i, el.attribs[name]));
                });
            }
            return domEach(this, function(i, el) {
                if (!isTag(el)) return;

                if (typeof name === 'object') {
                    _.each(name, function(value, name) {
                        setAttr(el, name, value);
                    });
                } else {
                    setAttr(el, name, value);
                }
            });
        }

        return getAttr(this[0], name);
    };

    var getProp = function (el, name) {
        return el.hasOwnProperty(name)
            ? el[name]
            : rboolean.test(name)
            ? getAttr(el, name) !== undefined
            : getAttr(el, name);
    };

    var setProp = function (el, name, value) {
        el[name] = rboolean.test(name) ? !!value : value;
    };

    exports.prop = function (name, value) {
        var i = 0,
            property;

        if (typeof name === 'string' && value === undefined) {

            switch (name) {
                case 'style':
                    property = this.css();

                    _.each(property, function (v, p) {
                        property[i++] = p;
                    });

                    property.length = i;

                    break;
                case 'tagName':
                case 'nodeName':
                    property = this[0].name.toUpperCase();
                    break;
                default:
                    property = getProp(this[0], name);
            }

            return property;
        }

        if (typeof name === 'object' || value !== undefined) {

            if (typeof value === 'function') {
                return domEach(this, function(i, el) {
                    setProp(el, name, value.call(el, i, getProp(el, name)));
                });
            }

            return domEach(this, function(i, el) {
                if (!isTag(el)) return;

                if (typeof name === 'object') {

                    _.each(name, function(val, name) {
                        setProp(el, name, val);
                    });

                } else {
                    setProp(el, name, value);
                }
            });

        }
    };

    var setData = function(el, name, value) {
        if (!el.data) {
            el.data = {};
        }

        if (typeof name === 'object') return _.extend(el.data, name);
        if (typeof name === 'string' && value !== undefined) {
            el.data[name] = value;
        } else if (typeof name === 'object') {
            _.exend(el.data, name);
        }
    };

// Read the specified attribute from the equivalent HTML5 `data-*` attribute,
// and (if present) cache the value in the node's internal data store. If no
// attribute name is specified, read *all* HTML5 `data-*` attributes in this
// manner.
    var readData = function(el, name) {
        var readAll = arguments.length === 1;
        var domNames, domName, jsNames, jsName, value, idx, length;

        if (readAll) {
            domNames = Object.keys(el.attribs).filter(function(attrName) {
                return attrName.slice(0, dataAttrPrefix.length) === dataAttrPrefix;
            });
            jsNames = domNames.map(function(domName) {
                return camelCase(domName.slice(dataAttrPrefix.length));
            });
        } else {
            domNames = [dataAttrPrefix + cssCase(name)];
            jsNames = [name];
        }

        for (idx = 0, length = domNames.length; idx < length; ++idx) {
            domName = domNames[idx];
            jsName = jsNames[idx];
            if (hasOwn.call(el.attribs, domName)) {
                value = el.attribs[domName];

                if (hasOwn.call(primitives, value)) {
                    value = primitives[value];
                } else if (value === String(Number(value))) {
                    value = Number(value);
                } else if (rbrace.test(value)) {
                    try {
                        value = JSON.parse(value);
                    } catch(e){ }
                }

                el.data[jsName] = value;
            }
        }

        return readAll ? el.data : value;
    };

    exports.data = function(name, value) {
        var elem = this[0];

        if (!elem || !isTag(elem)) return;

        if (!elem.data) {
            elem.data = {};
        }

        // Return the entire data object if no data specified
        if (!name) {
            return readData(elem);
        }

        // Set the value (with attr map support)
        if (typeof name === 'object' || value !== undefined) {
            domEach(this, function(i, el) {
                setData(el, name, value);
            });
            return this;
        } else if (hasOwn.call(elem.data, name)) {
            return elem.data[name];
        }

        return readData(elem, name);
    };

    /**
     * Get the value of an element
     */

    exports.val = function(value) {
        var querying = arguments.length === 0,
            element = this[0];

        if(!element) return;

        switch (element.name) {
            case 'textarea':
                return this.text(value);
            case 'input':
                switch (this.attr('type')) {
                    case 'radio':
                        if (querying) {
                            return this.attr('value');
                        } else {
                            this.attr('value', value);
                            return this;
                        }
                        break;
                    default:
                        return this.attr('value', value);
                }
                return;
            case 'select':
                var option = this.find('option:selected'),
                    returnValue;
                if (option === undefined) return undefined;
                if (!querying) {
                    if (!this.attr().hasOwnProperty('multiple') && typeof value == 'object') {
                        return this;
                    }
                    if (typeof value != 'object') {
                        value = [value];
                    }
                    this.find('option').removeAttr('selected');
                    for (var i = 0; i < value.length; i++) {
                        this.find('option[value="' + value[i] + '"]').attr('selected', '');
                    }
                    return this;
                }
                returnValue = option.attr('value');
                if (this.attr().hasOwnProperty('multiple')) {
                    returnValue = [];
                    domEach(option, function(i, el) {
                        returnValue.push(getAttr(el, 'value'));
                    });
                }
                return returnValue;
            case 'option':
                if (!querying) {
                    this.attr('value', value);
                    return this;
                }
                return this.attr('value');
        }
    };

    /**
     * Remove an attribute
     */

    var removeAttribute = function(elem, name) {
        if (!elem.attribs || !hasOwn.call(elem.attribs, name))
            return;

        delete elem.attribs[name];
    };


    exports.removeAttr = function(name) {
        domEach(this, function(i, elem) {
            removeAttribute(elem, name);
        });

        return this;
    };

    exports.hasClass = function(className) {
        return _.some(this, function(elem) {
            var attrs = elem.attribs,
                clazz = attrs && attrs['class'],
                idx = -1,
                end;

            if (clazz) {
                while ((idx = clazz.indexOf(className, idx+1)) > -1) {
                    end = idx + className.length;

                    if ((idx === 0 || rspace.test(clazz[idx-1]))
                        && (end === clazz.length || rspace.test(clazz[end]))) {
                        return true;
                    }
                }
            }
        });
    };

    exports.addClass = function(value) {
        // Support functions
        if (typeof value === 'function') {
            return domEach(this, function(i, el) {
                var className = el.attribs['class'] || '';
                exports.addClass.call([el], value.call(el, i, className));
            });
        }

        // Return if no value or not a string or function
        if (!value || typeof value !== 'string') return this;

        var classNames = value.split(rspace),
            numElements = this.length;


        for (var i = 0; i < numElements; i++) {
            // If selected element isn't a tag, move on
            if (!isTag(this[i])) continue;

            // If we don't already have classes
            var className = getAttr(this[i], 'class'),
                numClasses,
                setClass;

            if (!className) {
                setAttr(this[i], 'class', classNames.join(' ').trim());
            } else {
                setClass = ' ' + className + ' ';
                numClasses = classNames.length;

                // Check if class already exists
                for (var j = 0; j < numClasses; j++) {
                    var appendClass = classNames[j] + ' ';
                    if (setClass.indexOf(' ' + appendClass) < 0)
                        setClass += appendClass;
                }

                setAttr(this[i], 'class', setClass.trim());
            }
        }

        return this;
    };

    var splitClass = function(className) {
        return className ? className.trim().split(rspace) : [];
    };

    exports.removeClass = function(value) {
        var classes,
            numClasses,
            removeAll;

        // Handle if value is a function
        if (typeof value === 'function') {
            return domEach(this, function(i, el) {
                exports.removeClass.call(
                    [el], value.call(el, i, el.attribs['class'] || '')
                );
            });
        }

        classes = splitClass(value);
        numClasses = classes.length;
        removeAll = arguments.length === 0;

        return domEach(this, function(i, el) {
            if (!isTag(el)) return;

            if (removeAll) {
                // Short circuit the remove all case as this is the nice one
                el.attribs.class = '';
            } else {
                var elClasses = splitClass(el.attribs.class),
                    index,
                    changed;

                for (var j = 0; j < numClasses; j++) {
                    index = elClasses.indexOf(classes[j]);

                    if (index >= 0) {
                        elClasses.splice(index, 1);
                        changed = true;

                        // We have to do another pass to ensure that there are not duplicate
                        // classes listed
                        j--;
                    }
                }
                if (changed) {
                    el.attribs.class = elClasses.join(' ');
                }
            }
        });
    };

    exports.toggleClass = function(value, stateVal) {
        // Support functions
        if (typeof value === 'function') {
            return domEach(this, function(i, el) {
                exports.toggleClass.call(
                    [el],
                    value.call(el, i, el.attribs['class'] || '', stateVal),
                    stateVal
                );
            });
        }

        // Return if no value or not a string or function
        if (!value || typeof value !== 'string') return this;

        var classNames = value.split(rspace),
            numClasses = classNames.length,
            state = typeof stateVal === 'boolean' ? stateVal ? 1 : -1 : 0,
            numElements = this.length,
            elementClasses,
            index;

        for (var i = 0; i < numElements; i++) {
            // If selected element isn't a tag, move on
            if (!isTag(this[i])) continue;

            elementClasses = splitClass(this[i].attribs.class);

            // Check if class already exists
            for (var j = 0; j < numClasses; j++) {
                // Check if the class name is currently defined
                index = elementClasses.indexOf(classNames[j]);

                // Add if stateValue === true or we are toggling and there is no value
                if (state >= 0 && index < 0) {
                    elementClasses.push(classNames[j]);
                } else if (state <= 0 && index >= 0) {
                    // Otherwise remove but only if the item exists
                    elementClasses.splice(index, 1);
                }
            }

            this[i].attribs.class = elementClasses.join(' ');
        }

        return this;
    };

    exports.is = function (selector) {
        if (selector) {
            return this.filter(selector).length > 0;
        }
        return false;
    };


},{"../static":35,"../utils":36,"lodash":81}],29:[function(require,module,exports){
    var _ = require('lodash'),
        domEach = require('../utils').domEach;
    var toString = Object.prototype.toString;

    /**
     * Set / Get css.
     *
     * @param {String|Object} prop
     * @param {String} val
     * @return {self}
     * @api public
     */

    exports.css = function(prop, val) {
        if (arguments.length === 2 ||
            // When `prop` is a "plain" object
            (toString.call(prop) === '[object Object]')) {
            return domEach(this, function(idx, el) {
                setCss(el, prop, val, idx);
            });
        } else {
            return getCss(this[0], prop);
        }
    };

    /**
     * Set styles of all elements.
     *
     * @param {String|Object} prop
     * @param {String} val
     * @param {Number} idx - optional index within the selection
     * @return {self}
     * @api private
     */

    function setCss(el, prop, val, idx) {
        if ('string' == typeof prop) {
            var styles = getCss(el);
            if (typeof val === 'function') {
                val = val.call(el, idx, styles[prop]);
            }

            if (val === '') {
                delete styles[prop];
            } else if (val != null) {
                styles[prop] = val;
            }

            el.attribs.style = stringify(styles);
        } else if ('object' == typeof prop) {
            Object.keys(prop).forEach(function(k){
                setCss(el, k, prop[k]);
            });
        }
    }

    /**
     * Get parsed styles of the first element.
     *
     * @param {String} prop
     * @return {Object}
     * @api private
     */

    function getCss(el, prop) {
        var styles = parse(el.attribs.style);
        if (typeof prop === 'string') {
            return styles[prop];
        } else if (Array.isArray(prop)) {
            return _.pick(styles, prop);
        } else {
            return styles;
        }
    }

    /**
     * Stringify `obj` to styles.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function stringify(obj) {
        return Object.keys(obj || {})
            .reduce(function(str, prop){
                return str += ''
                    + (str ? ' ' : '')
                    + prop
                    + ': '
                    + obj[prop]
                    + ';';
            }, '');
    }

    /**
     * Parse `styles`.
     *
     * @param {String} styles
     * @return {Object}
     * @api private
     */

    function parse(styles) {
        styles = (styles || '').trim();

        if (!styles) return {};

        return styles
            .split(';')
            .reduce(function(obj, str){
                var n = str.indexOf(':');
                // skip if there is no :, or if it is the first/last character
                if (n < 1 || n === str.length-1) return obj;
                obj[str.slice(0,n).trim()] = str.slice(n+1).trim();
                return obj;
            }, {});
    }

},{"../utils":36,"lodash":81}],30:[function(require,module,exports){
// https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js
// https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js
    var _ = require('lodash'),
        submittableSelector = 'input,select,textarea,keygen',
        rCRLF = /\r?\n/g;

    exports.serializeArray = function() {
        // Resolve all form elements from either forms or collections of form elements
        var Cheerio = this.constructor;
        return this.map(function() {
            var elem = this;
            var $elem = Cheerio(elem);
            if (elem.name === 'form') {
                return $elem.find(submittableSelector).toArray();
            } else {
                return $elem.filter(submittableSelector).toArray();
            }
        }).filter(
            // Verify elements have a name (`attr.name`) and are not disabled (`:disabled`)
            '[name!=""]:not(:disabled)'
            // and cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)
            + ':not(:submit, :button, :image, :reset, :file)'
            // and are either checked/don't have a checkable state
            + ':matches([checked], :not(:checkbox, :radio))'
            // Convert each of the elements to its value(s)
        ).map(function(i, elem) {
            var $elem = Cheerio(elem);
            var name = $elem.attr('name');
            var val = $elem.val();

            // If there is no value set (e.g. `undefined`, `null`), then return nothing
            if (val == null) {
                return null;
            } else {
                // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs
                if (Array.isArray(val)) {
                    return _.map(val, function(val) {
                        // We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
                        //   These can occur inside of `<textarea>'s`
                        return {name: name, value: val.replace( rCRLF, '\r\n' )};
                    });
                    // Otherwise (e.g. `<input type="text">`, return only one key/value pair
                } else {
                    return {name: name, value: val.replace( rCRLF, '\r\n' )};
                }
            }
            // Convert our result to an array
        }).get();
    };

},{"lodash":81}],31:[function(require,module,exports){
    var _ = require('lodash'),
        parse = require('../parse'),
        $ = require('../static'),
        updateDOM = parse.update,
        evaluate = parse.evaluate,
        utils = require('../utils'),
        domEach = utils.domEach,
        cloneDom = utils.cloneDom,
        isHtml = utils.isHtml,
        slice = Array.prototype.slice;

// Create an array of nodes, recursing into arrays and parsing strings if
// necessary
    exports._makeDomArray = function makeDomArray(elem, clone) {
        if (elem == null) {
            return [];
        } else if (elem.cheerio) {
            return clone ? cloneDom(elem.get(), elem.options) : elem.get();
        } else if (Array.isArray(elem)) {
            return _.flatten(elem.map(function(el) {
                return this._makeDomArray(el, clone);
            }, this));
        } else if (typeof elem === 'string') {
            return evaluate(elem, this.options);
        } else {
            return clone ? cloneDom([elem]) : [elem];
        }
    };

    var _insert = function(concatenator) {
        return function() {
            var elems = slice.call(arguments),
                lastIdx = this.length - 1;

            return domEach(this, function(i, el) {
                var dom, domSrc;

                if (typeof elems[0] === 'function') {
                    domSrc = elems[0].call(el, i, $.html(el.children));
                } else {
                    domSrc = elems;
                }

                dom = this._makeDomArray(domSrc, i < lastIdx);
                concatenator(dom, el.children, el);
            });
        };
    };

    /*
     * Modify an array in-place, removing some number of elements and adding new
     * elements directly following them.
     *
     * @param {Array} array Target array to splice.
     * @param {Number} spliceIdx Index at which to begin changing the array.
     * @param {Number} spliceCount Number of elements to remove from the array.
     * @param {Array} newElems Elements to insert into the array.
     *
     * @api private
     */
    var uniqueSplice = function(array, spliceIdx, spliceCount, newElems, parent) {
        var spliceArgs = [spliceIdx, spliceCount].concat(newElems),
            prev = array[spliceIdx - 1] || null,
            next = array[spliceIdx] || null;
        var idx, len, prevIdx, node, oldParent;

        // Before splicing in new elements, ensure they do not already appear in the
        // current array.
        for (idx = 0, len = newElems.length; idx < len; ++idx) {
            node = newElems[idx];
            oldParent = node.parent || node.root;
            prevIdx = oldParent && oldParent.children.indexOf(newElems[idx]);

            if (oldParent && prevIdx > -1) {
                oldParent.children.splice(prevIdx, 1);
                if (parent === oldParent && spliceIdx > prevIdx) {
                    spliceArgs[0]--;
                }
            }

            node.root = null;
            node.parent = parent;

            if (node.prev) {
                node.prev.next = node.next || null;
            }

            if (node.next) {
                node.next.prev = node.prev || null;
            }

            node.prev = newElems[idx - 1] || prev;
            node.next = newElems[idx + 1] || next;
        }

        if (prev) {
            prev.next = newElems[0];
        }
        if (next) {
            next.prev = newElems[newElems.length - 1];
        }
        return array.splice.apply(array, spliceArgs);
    };

    exports.appendTo = function(target) {
        if (!target.cheerio) {
            target = this.constructor.call(this.constructor, target, null, this._originalRoot);
        }

        target.append(this);

        return this;
    };

    exports.prependTo = function(target) {
        if (!target.cheerio) {
            target = this.constructor.call(this.constructor, target, null, this._originalRoot);
        }

        target.prepend(this);

        return this;
    };

    exports.append = _insert(function(dom, children, parent) {
        uniqueSplice(children, children.length, 0, dom, parent);
    });

    exports.prepend = _insert(function(dom, children, parent) {
        uniqueSplice(children, 0, 0, dom, parent);
    });

    exports.wrap = function(wrapper) {
        var wrapperFn = typeof wrapper === 'function' && wrapper,
            lastIdx = this.length - 1;

        _.forEach(this, _.bind(function(el, i) {
            var parent = el.parent || el.root,
                siblings = parent.children,
                dom, index;

            if (!parent) {
                return;
            }

            if (wrapperFn) {
                wrapper = wrapperFn.call(el, i);
            }

            if (typeof wrapper === 'string' && !isHtml(wrapper)) {
                wrapper = this.parents().last().find(wrapper).clone();
            }

            dom = this._makeDomArray(wrapper, i < lastIdx).slice(0, 1);
            index = siblings.indexOf(el);

            updateDOM([el], dom[0]);
            // The previous operation removed the current element from the `siblings`
            // array, so the `dom` array can be inserted without removing any
            // additional elements.
            uniqueSplice(siblings, index, 0, dom, parent);
        }, this));

        return this;
    };

    exports.after = function() {
        var elems = slice.call(arguments),
            lastIdx = this.length - 1;

        domEach(this, function(i, el) {
            var parent = el.parent || el.root;
            if (!parent) {
                return;
            }

            var siblings = parent.children,
                index = siblings.indexOf(el),
                domSrc, dom;

            // If not found, move on
            if (index < 0) return;

            if (typeof elems[0] === 'function') {
                domSrc = elems[0].call(el, i, $.html(el.children));
            } else {
                domSrc = elems;
            }
            dom = this._makeDomArray(domSrc, i < lastIdx);

            // Add element after `this` element
            uniqueSplice(siblings, index + 1, 0, dom, parent);
        });

        return this;
    };

    exports.insertAfter = function(target) {
        var clones = [],
            self = this;
        if (typeof target === 'string') {
            target = this.constructor.call(this.constructor, target, null, this._originalRoot);
        }
        target = this._makeDomArray(target);
        self.remove();
        domEach(target, function(i, el) {
            var clonedSelf = self._makeDomArray(self.clone());
            var parent = el.parent || el.root;
            if (!parent) {
                return;
            }

            var siblings = parent.children,
                index = siblings.indexOf(el);

            // If not found, move on
            if (index < 0) return;

            // Add cloned `this` element(s) after target element
            uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
            clones.push(clonedSelf);
        });
        return this.constructor.call(this.constructor, this._makeDomArray(clones));
    };

    exports.before = function() {
        var elems = slice.call(arguments),
            lastIdx = this.length - 1;

        domEach(this, function(i, el) {
            var parent = el.parent || el.root;
            if (!parent) {
                return;
            }

            var siblings = parent.children,
                index = siblings.indexOf(el),
                domSrc, dom;

            // If not found, move on
            if (index < 0) return;

            if (typeof elems[0] === 'function') {
                domSrc = elems[0].call(el, i, $.html(el.children));
            } else {
                domSrc = elems;
            }

            dom = this._makeDomArray(domSrc, i < lastIdx);

            // Add element before `el` element
            uniqueSplice(siblings, index, 0, dom, parent);
        });

        return this;
    };

    exports.insertBefore = function(target) {
        var clones = [],
            self = this;
        if (typeof target === 'string') {
            target = this.constructor.call(this.constructor, target, null, this._originalRoot);
        }
        target = this._makeDomArray(target);
        self.remove();
        domEach(target, function(i, el) {
            var clonedSelf = self._makeDomArray(self.clone());
            var parent = el.parent || el.root;
            if (!parent) {
                return;
            }

            var siblings = parent.children,
                index = siblings.indexOf(el);

            // If not found, move on
            if (index < 0) return;

            // Add cloned `this` element(s) after target element
            uniqueSplice(siblings, index, 0, clonedSelf, parent);
            clones.push(clonedSelf);
        });
        return this.constructor.call(this.constructor, this._makeDomArray(clones));
    };

    /*
     remove([selector])
     */
    exports.remove = function(selector) {
        var elems = this;

        // Filter if we have selector
        if (selector)
            elems = elems.filter(selector);

        domEach(elems, function(i, el) {
            var parent = el.parent || el.root;
            if (!parent) {
                return;
            }

            var siblings = parent.children,
                index = siblings.indexOf(el);

            if (index < 0) return;

            siblings.splice(index, 1);
            if (el.prev) {
                el.prev.next = el.next;
            }
            if (el.next) {
                el.next.prev = el.prev;
            }
            el.prev = el.next = el.parent = el.root = null;
        });

        return this;
    };

    exports.replaceWith = function(content) {
        var self = this;

        domEach(this, function(i, el) {
            var parent = el.parent || el.root;
            if (!parent) {
                return;
            }

            var siblings = parent.children,
                dom = self._makeDomArray(typeof content === 'function' ? content.call(el, i, el) : content),
                index;

            // In the case that `dom` contains nodes that already exist in other
            // structures, ensure those nodes are properly removed.
            updateDOM(dom, null);

            index = siblings.indexOf(el);

            // Completely remove old element
            uniqueSplice(siblings, index, 1, dom, parent);
            el.parent = el.prev = el.next = el.root = null;
        });

        return this;
    };

    exports.empty = function() {
        domEach(this, function(i, el) {
            _.each(el.children, function(el) {
                el.next = el.prev = el.parent = null;
            });

            el.children.length = 0;
        });
        return this;
    };

    /**
     * Set/Get the HTML
     */
    exports.html = function(str) {
        if (str === undefined) {
            if (!this[0] || !this[0].children) return null;
            return $.html(this[0].children, this.options);
        }

        var opts = this.options;

        domEach(this, function(i, el) {
            _.each(el.children, function(el) {
                el.next = el.prev = el.parent = null;
            });

            var content = str.cheerio ? str.clone().get() : evaluate('' + str, opts);

            updateDOM(content, el);
        });

        return this;
    };

    exports.toString = function() {
        return $.html(this, this.options);
    };

    exports.text = function(str) {
        // If `str` is undefined, act as a "getter"
        if (str === undefined) {
            return $.text(this);
        } else if (typeof str === 'function') {
            // Function support
            return domEach(this, function(i, el) {
                var $el = [el];
                return exports.text.call($el, str.call(el, i, $.text($el)));
            });
        }

        // Append text node to each selected elements
        domEach(this, function(i, el) {
            _.each(el.children, function(el) {
                el.next = el.prev = el.parent = null;
            });

            var elem = {
                data: '' + str,
                type: 'text',
                parent: el,
                prev: null,
                next: null,
                children: []
            };

            updateDOM(elem, el);
        });

        return this;
    };

    exports.clone = function() {
        return this._make(cloneDom(this.get(), this.options));
    };

},{"../parse":34,"../static":35,"../utils":36,"lodash":81}],32:[function(require,module,exports){
    var _ = require('lodash'),
        select = require('css-select'),
        utils = require('../utils'),
        domEach = utils.domEach,
        uniqueSort = require('htmlparser2').DomUtils.uniqueSort,
        isTag = utils.isTag;

    exports.find = function(selectorOrHaystack) {
        var elems = _.reduce(this, function(memo, elem) {
            return memo.concat(_.filter(elem.children, isTag));
        }, []);
        var contains = this.constructor.contains;
        var haystack;

        if (selectorOrHaystack && typeof selectorOrHaystack !== 'string') {
            if (selectorOrHaystack.cheerio) {
                haystack = selectorOrHaystack.get();
            } else {
                haystack = [selectorOrHaystack];
            }

            return this._make(haystack.filter(function(elem) {
                var idx, len;
                for (idx = 0, len = this.length; idx < len; ++idx) {
                    if (contains(this[idx], elem)) {
                        return true;
                    }
                }
            }, this));
        }

        var options = {__proto__: this.options, context: this.toArray()};

        return this._make(select(selectorOrHaystack, elems, options));
    };

// Get the parent of each element in the current set of matched elements,
// optionally filtered by a selector.
    exports.parent = function(selector) {
        var set = [];

        domEach(this, function(idx, elem) {
            var parentElem = elem.parent;
            if (parentElem && set.indexOf(parentElem) < 0) {
                set.push(parentElem);
            }
        });

        if (arguments.length) {
            set = exports.filter.call(set, selector, this);
        }

        return this._make(set);
    };

    exports.parents = function(selector) {
        var parentNodes = [];

        // When multiple DOM elements are in the original set, the resulting set will
        // be in *reverse* order of the original elements as well, with duplicates
        // removed.
        this.get().reverse().forEach(function(elem) {
            traverseParents(this, elem.parent, selector, Infinity)
                .forEach(function(node) {
                        if (parentNodes.indexOf(node) === -1) {
                            parentNodes.push(node);
                        }
                    }
                );
        }, this);

        return this._make(parentNodes);
    };

    exports.parentsUntil = function(selector, filter) {
        var parentNodes = [], untilNode, untilNodes;

        if (typeof selector === 'string') {
            untilNode = select(selector, this.parents().toArray(), this.options)[0];
        } else if (selector && selector.cheerio) {
            untilNodes = selector.toArray();
        } else if (selector) {
            untilNode = selector;
        }

        // When multiple DOM elements are in the original set, the resulting set will
        // be in *reverse* order of the original elements as well, with duplicates
        // removed.

        this.toArray().reverse().forEach(function(elem) {
            while ((elem = elem.parent)) {
                if ((untilNode && elem !== untilNode) ||
                    (untilNodes && untilNodes.indexOf(elem) === -1) ||
                    (!untilNode && !untilNodes)) {
                    if (isTag(elem) && parentNodes.indexOf(elem) === -1) { parentNodes.push(elem); }
                } else {
                    break;
                }
            }
        }, this);

        return this._make(filter ? select(filter, parentNodes, this.options) : parentNodes);
    };

// For each element in the set, get the first element that matches the selector
// by testing the element itself and traversing up through its ancestors in the
// DOM tree.
    exports.closest = function(selector) {
        var set = [];

        if (!selector) {
            return this._make(set);
        }

        domEach(this, function(idx, elem) {
            var closestElem = traverseParents(this, elem, selector, 1)[0];

            // Do not add duplicate elements to the set
            if (closestElem && set.indexOf(closestElem) < 0) {
                set.push(closestElem);
            }
        }.bind(this));

        return this._make(set);
    };

    exports.next = function(selector) {
        if (!this[0]) { return this; }
        var elems = [];

        _.forEach(this, function(elem) {
            while ((elem = elem.next)) {
                if (isTag(elem)) {
                    elems.push(elem);
                    return;
                }
            }
        });

        return selector ?
            exports.filter.call(elems, selector, this) :
            this._make(elems);
    };

    exports.nextAll = function(selector) {
        if (!this[0]) { return this; }
        var elems = [];

        _.forEach(this, function(elem) {
            while ((elem = elem.next)) {
                if (isTag(elem) && elems.indexOf(elem) === -1) {
                    elems.push(elem);
                }
            }
        });

        return selector ?
            exports.filter.call(elems, selector, this) :
            this._make(elems);
    };

    exports.nextUntil = function(selector, filterSelector) {
        if (!this[0]) { return this; }
        var elems = [], untilNode, untilNodes;

        if (typeof selector === 'string') {
            untilNode = select(selector, this.nextAll().get(), this.options)[0];
        } else if (selector && selector.cheerio) {
            untilNodes = selector.get();
        } else if (selector) {
            untilNode = selector;
        }

        _.forEach(this, function(elem) {
            while ((elem = elem.next)) {
                if ((untilNode && elem !== untilNode) ||
                    (untilNodes && untilNodes.indexOf(elem) === -1) ||
                    (!untilNode && !untilNodes)) {
                    if (isTag(elem) && elems.indexOf(elem) === -1) {
                        elems.push(elem);
                    }
                } else {
                    break;
                }
            }
        });

        return filterSelector ?
            exports.filter.call(elems, filterSelector, this) :
            this._make(elems);
    };

    exports.prev = function(selector) {
        if (!this[0]) { return this; }
        var elems = [];

        _.forEach(this, function(elem) {
            while ((elem = elem.prev)) {
                if (isTag(elem)) {
                    elems.push(elem);
                    return;
                }
            }
        });

        return selector ?
            exports.filter.call(elems, selector, this) :
            this._make(elems);
    };

    exports.prevAll = function(selector) {
        if (!this[0]) { return this; }
        var elems = [];

        _.forEach(this, function(elem) {
            while ((elem = elem.prev)) {
                if (isTag(elem) && elems.indexOf(elem) === -1) {
                    elems.push(elem);
                }
            }
        });

        return selector ?
            exports.filter.call(elems, selector, this) :
            this._make(elems);
    };

    exports.prevUntil = function(selector, filterSelector) {
        if (!this[0]) { return this; }
        var elems = [], untilNode, untilNodes;

        if (typeof selector === 'string') {
            untilNode = select(selector, this.prevAll().get(), this.options)[0];
        } else if (selector && selector.cheerio) {
            untilNodes = selector.get();
        } else if (selector) {
            untilNode = selector;
        }

        _.forEach(this, function(elem) {
            while ((elem = elem.prev)) {
                if ((untilNode && elem !== untilNode) ||
                    (untilNodes && untilNodes.indexOf(elem) === -1) ||
                    (!untilNode && !untilNodes)) {
                    if (isTag(elem) && elems.indexOf(elem) === -1) {
                        elems.push(elem);
                    }
                } else {
                    break;
                }
            }
        });

        return filterSelector ?
            exports.filter.call(elems, filterSelector, this) :
            this._make(elems);
    };

    exports.siblings = function(selector) {
        var parent = this.parent();

        var elems = _.filter(
            parent ? parent.children() : this.siblingsAndMe(),
            _.bind(function(elem) { return isTag(elem) && !this.is(elem); }, this)
        );

        if (selector !== undefined) {
            return exports.filter.call(elems, selector, this);
        } else {
            return this._make(elems);
        }
    };

    exports.children = function(selector) {

        var elems = _.reduce(this, function(memo, elem) {
            return memo.concat(_.filter(elem.children, isTag));
        }, []);

        if (selector === undefined) return this._make(elems);

        return exports.filter.call(elems, selector, this);
    };

    exports.contents = function() {
        return this._make(_.reduce(this, function(all, elem) {
            all.push.apply(all, elem.children);
            return all;
        }, []));
    };

    exports.each = function(fn) {
        var i = 0, len = this.length;
        while (i < len && fn.call(this[i], i, this[i]) !== false) ++i;
        return this;
    };

    exports.map = function(fn) {
        return this._make(_.reduce(this, function(memo, el, i) {
            var val = fn.call(el, i, el);
            return val == null ? memo : memo.concat(val);
        }, []));
    };

    var makeFilterMethod = function(filterFn) {
        return function(match, container) {
            var testFn;
            container = container || this;

            if (typeof match === 'string') {
                testFn = select.compile(match, container.options);
            } else if (typeof match === 'function') {
                testFn = function(el, i) {
                    return match.call(el, i, el);
                };
            } else if (match.cheerio) {
                testFn = match.is.bind(match);
            } else {
                testFn = function(el) {
                    return match === el;
                };
            }

            return container._make(filterFn(this, testFn));
        };
    };

    exports.filter = makeFilterMethod(_.filter);
    exports.not = makeFilterMethod(_.reject);

    exports.has = function(selectorOrHaystack) {
        var that = this;
        return exports.filter.call(this, function() {
            return that._make(this).find(selectorOrHaystack).length > 0;
        });
    };

    exports.first = function() {
        return this.length > 1 ? this._make(this[0]) : this;
    };

    exports.last = function() {
        return this.length > 1 ? this._make(this[this.length - 1]) : this;
    };

// Reduce the set of matched elements to the one at the specified index.
    exports.eq = function(i) {
        i = +i;

        // Use the first identity optimization if possible
        if (i === 0 && this.length <= 1) return this;

        if (i < 0) i = this.length + i;
        return this[i] ? this._make(this[i]) : this._make([]);
    };

// Retrieve the DOM elements matched by the jQuery object.
    exports.get = function(i) {
        if (i == null) {
            return Array.prototype.slice.call(this);
        } else {
            return this[i < 0 ? (this.length + i) : i];
        }
    };

// Search for a given element from among the matched elements.
    exports.index = function(selectorOrNeedle) {
        var $haystack, needle;

        if (arguments.length === 0) {
            $haystack = this.parent().children();
            needle = this[0];
        } else if (typeof selectorOrNeedle === 'string') {
            $haystack = this._make(selectorOrNeedle);
            needle = this[0];
        } else {
            $haystack = this;
            needle = selectorOrNeedle.cheerio ? selectorOrNeedle[0] : selectorOrNeedle;
        }

        return $haystack.get().indexOf(needle);
    };

    exports.slice = function() {
        return this._make([].slice.apply(this, arguments));
    };

    function traverseParents(self, elem, selector, limit) {
        var elems = [];
        while (elem && elems.length < limit) {
            if (!selector || exports.filter.call([elem], selector, self).length) {
                elems.push(elem);
            }
            elem = elem.parent;
        }
        return elems;
    }

// End the most recent filtering operation in the current chain and return the
// set of matched elements to its previous state.
    exports.end = function() {
        return this.prevObject || this._make([]);
    };

    exports.add = function(other, context) {
        var selection = this._make(other, context);
        var contents = uniqueSort(selection.get().concat(this.get()));

        for (var i = 0; i < contents.length; ++i) {
            selection[i] = contents[i];
        }
        selection.length = contents.length;

        return selection;
    };

// Add the previous set of elements on the stack to the current set, optionally
// filtered by a selector.
    exports.addBack = function(selector) {
        return this.add(
            arguments.length ? this.prevObject.filter(selector) : this.prevObject
        );
    };

},{"../utils":36,"css-select":38,"htmlparser2":74,"lodash":81}],33:[function(require,module,exports){
    /*
     Module dependencies
     */

    var parse = require('./parse'),
        isHtml = require('./utils').isHtml,
        _ = require('lodash');

    /*
     * The API
     */

    var api = [
        require('./api/attributes'),
        require('./api/traversing'),
        require('./api/manipulation'),
        require('./api/css'),
        require('./api/forms')
    ];

    /*
     * Instance of cheerio
     */

    var Cheerio = module.exports = function(selector, context, root, options) {
        if (!(this instanceof Cheerio)) return new Cheerio(selector, context, root, options);

        this.options = _.defaults(options || {}, this.options);

        // $(), $(null), $(undefined), $(false)
        if (!selector) return this;

        if (root) {
            if (typeof root === 'string') root = parse(root, this.options);
            this._root = Cheerio.call(this, root);
        }

        // $($)
        if (selector.cheerio) return selector;

        // $(dom)
        if (isNode(selector))
            selector = [selector];

        // $([dom])
        if (Array.isArray(selector)) {
            _.forEach(selector, _.bind(function(elem, idx) {
                this[idx] = elem;
            }, this));
            this.length = selector.length;
            return this;
        }

        // $(<html>)
        if (typeof selector === 'string' && isHtml(selector)) {
            return Cheerio.call(this, parse(selector, this.options).children);
        }

        // If we don't have a context, maybe we have a root, from loading
        if (!context) {
            context = this._root;
        } else if (typeof context === 'string') {
            if (isHtml(context)) {
                // $('li', '<ul>...</ul>')
                context = parse(context, this.options);
                context = Cheerio.call(this, context);
            } else {
                // $('li', 'ul')
                selector = [context, selector].join(' ');
                context = this._root;
            }
            // $('li', node), $('li', [nodes])
        } else if (!context.cheerio) {
            context = Cheerio.call(this, context);
        }

        // If we still don't have a context, return
        if (!context) return this;

        // #id, .class, tag
        return context.find(selector);
    };

    /**
     * Mix in `static`
     */

    _.extend(Cheerio, require('./static'));

    /*
     * Set a signature of the object
     */

    Cheerio.prototype.cheerio = '[cheerio object]';

    /*
     * Cheerio default options
     */

    Cheerio.prototype.options = {
        withDomLvl1: true,
        normalizeWhitespace: false,
        xmlMode: false,
        decodeEntities: true
    };

    /*
     * Make cheerio an array-like object
     */

    Cheerio.prototype.length = 0;
    Cheerio.prototype.splice = Array.prototype.splice;

    /*
     * Make a cheerio object
     *
     * @api private
     */

    Cheerio.prototype._make = function(dom, context) {
        var cheerio = new this.constructor(dom, context, this._root, this.options);
        cheerio.prevObject = this;
        return cheerio;
    };

    /**
     * Turn a cheerio object into an array
     */

    Cheerio.prototype.toArray = function() {
        return this.get();
    };

    /**
     * Plug in the API
     */
    api.forEach(function(mod) {
        _.extend(Cheerio.prototype, mod);
    });

    var isNode = function(obj) {
        return obj.name || obj.type === 'text' || obj.type === 'comment';
    };

},{"./api/attributes":28,"./api/css":29,"./api/forms":30,"./api/manipulation":31,"./api/traversing":32,"./parse":34,"./static":35,"./utils":36,"lodash":81}],34:[function(require,module,exports){
    (function (Buffer){
        /*
         Module Dependencies
         */
        var htmlparser = require('htmlparser2');

        /*
         Parser
         */
        exports = module.exports = function(content, options) {
            var dom = exports.evaluate(content, options),
            // Generic root element
                root = exports.evaluate('<root></root>', options)[0];

            root.type = 'root';

            // Update the dom using the root
            exports.update(dom, root);

            return root;
        };

        exports.evaluate = function(content, options) {
            // options = options || $.fn.options;

            var dom;

            if (typeof content === 'string' || Buffer.isBuffer(content)) {
                dom = htmlparser.parseDOM(content, options);
            } else {
                dom = content;
            }

            return dom;
        };

        /*
         Update the dom structure, for one changed layer
         */
        exports.update = function(arr, parent) {
            // normalize
            if (!Array.isArray(arr)) arr = [arr];

            // Update parent
            if (parent) {
                parent.children = arr;
            } else {
                parent = null;
            }

            // Update neighbors
            for (var i = 0; i < arr.length; i++) {
                var node = arr[i];

                // Cleanly remove existing nodes from their previous structures.
                var oldParent = node.parent || node.root,
                    oldSiblings = oldParent && oldParent.children;
                if (oldSiblings && oldSiblings !== arr) {
                    oldSiblings.splice(oldSiblings.indexOf(node), 1);
                    if (node.prev) {
                        node.prev.next = node.next;
                    }
                    if (node.next) {
                        node.next.prev = node.prev;
                    }
                }

                if (parent) {
                    node.prev = arr[i - 1] || null;
                    node.next = arr[i + 1] || null;
                } else {
                    node.prev = node.next = null;
                }

                if (parent && parent.type === 'root') {
                    node.root = parent;
                    node.parent = null;
                } else {
                    node.root = null;
                    node.parent = parent;
                }
            }

            return parent;
        };

// module.exports = $.extend(exports);

    }).call(this,{"isBuffer":require("../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":95,"htmlparser2":74}],35:[function(require,module,exports){
    /**
     * Module dependencies
     */

    var select = require('css-select'),
        parse = require('./parse'),
        serialize = require('dom-serializer'),
        _ = require('lodash');

    /**
     * $.load(str)
     */

    exports.load = function(content, options) {
        var Cheerio = require('./cheerio');

        options = _.defaults(options || {}, Cheerio.prototype.options);

        var root = parse(content, options);

        var initialize = function(selector, context, r, opts) {
            if (!(this instanceof initialize)) {
                return new initialize(selector, context, r, opts);
            }
            opts = _.defaults(opts || {}, options);
            return Cheerio.call(this, selector, context, r || root, opts);
        };

        // Ensure that selections created by the "loaded" `initialize` function are
        // true Cheerio instances.
        initialize.prototype = Object.create(Cheerio.prototype);
        initialize.prototype.constructor = initialize;

        // Mimic jQuery's prototype alias for plugin authors.
        initialize.fn = initialize.prototype;

        // Keep a reference to the top-level scope so we can chain methods that implicitly 
        // resolve selectors; e.g. $("<span>").(".bar"), which otherwise loses ._root
        initialize.prototype._originalRoot = root;

        // Add in the static methods
        _.merge(initialize, exports);

        // Add in the root
        initialize._root = root;
        // store options
        initialize._options = options;

        return initialize;
    };

    /*
     * Helper function
     */

    function render(that, dom, options) {
        if (!dom) {
            if (that._root && that._root.children) {
                dom = that._root.children;
            } else {
                return '';
            }
        } else if (typeof dom === 'string') {
            dom = select(dom, that._root, options);
        }

        return serialize(dom, options);
    }

    /**
     * $.html([selector | dom], [options])
     */

    exports.html = function(dom, options) {
        var Cheerio = require('./cheerio');

        // be flexible about parameters, sometimes we call html(),
        // with options as only parameter
        // check dom argument for dom element specific properties
        // assume there is no 'length' or 'type' properties in the options object
        if (Object.prototype.toString.call(dom) === '[object Object]' && !options && !('length' in dom) && !('type' in dom))
        {
            options = dom;
            dom = undefined;
        }

        // sometimes $.html() used without preloading html
        // so fallback non existing options to the default ones
        options = _.defaults(options || {}, this._options, Cheerio.prototype.options);

        return render(this, dom, options);
    };

    /**
     * $.xml([selector | dom])
     */

    exports.xml = function(dom) {
        var options = _.defaults({xmlMode: true}, this._options);

        return render(this, dom, options);
    };

    /**
     * $.text(dom)
     */

    exports.text = function(elems) {
        if (!elems) return '';

        var ret = '',
            len = elems.length,
            elem;

        for (var i = 0; i < len; i++) {
            elem = elems[i];
            if (elem.type === 'text') ret += elem.data;
            else if (elem.children && elem.type !== 'comment') {
                ret += exports.text(elem.children);
            }
        }

        return ret;
    };

    /**
     * $.parseHTML(data [, context ] [, keepScripts ])
     * Parses a string into an array of DOM nodes. The `context` argument has no
     * meaning for Cheerio, but it is maintained for API compatibility with jQuery.
     */
    exports.parseHTML = function(data, context, keepScripts) {
        var parsed;

        if (!data || typeof data !== 'string') {
            return null;
        }

        if (typeof context === 'boolean') {
            keepScripts = context;
        }

        parsed = this.load(data);
        if (!keepScripts) {
            parsed('script').remove();
        }

        // The `children` array is used by Cheerio internally to group elements that
        // share the same parents. When nodes created through `parseHTML` are
        // inserted into previously-existing DOM structures, they will be removed
        // from the `children` array. The results of `parseHTML` should remain
        // constant across these operations, so a shallow copy should be returned.
        return parsed.root()[0].children.slice();
    };

    /**
     * $.root()
     */
    exports.root = function() {
        return this(this._root);
    };

    /**
     * $.contains()
     */
    exports.contains = function(container, contained) {

        // According to the jQuery API, an element does not "contain" itself
        if (contained === container) {
            return false;
        }

        // Step up the descendants, stopping when the root element is reached
        // (signaled by `.parent` returning a reference to the same object)
        while (contained && contained !== contained.parent) {
            contained = contained.parent;
            if (contained === container) {
                return true;
            }
        }

        return false;
    };

},{"./cheerio":33,"./parse":34,"css-select":38,"dom-serializer":46,"lodash":81}],36:[function(require,module,exports){
    var parse = require('./parse'),
        render = require('dom-serializer');

    /**
     * HTML Tags
     */

    var tags = { tag: true, script: true, style: true };

    /**
     * Check if the DOM element is a tag
     *
     * isTag(type) includes <script> and <style> tags
     */

    exports.isTag = function(type) {
        if (type.type) type = type.type;
        return tags[type] || false;
    };

    /**
     * Convert a string to camel case notation.
     * @param  {String} str String to be converted.
     * @return {String}     String in camel case notation.
     */

    exports.camelCase = function(str) {
        return str.replace(/[_.-](\w|$)/g, function(_, x) {
            return x.toUpperCase();
        });
    };

    /**
     * Convert a string from camel case to "CSS case", where word boundaries are
     * described by hyphens ("-") and all characters are lower-case.
     * @param  {String} str String to be converted.
     * @return {string}     String in "CSS case".
     */
    exports.cssCase = function(str) {
        return str.replace(/[A-Z]/g, '-$&').toLowerCase();
    };

    /**
     * Iterate over each DOM element without creating intermediary Cheerio instances.
     *
     * This is indented for use internally to avoid otherwise unnecessary memory pressure introduced
     * by _make.
     */

    exports.domEach = function(cheerio, fn) {
        var i = 0, len = cheerio.length;
        while (i < len && fn.call(cheerio, i, cheerio[i]) !== false) ++i;
        return cheerio;
    };

    /**
     * Create a deep copy of the given DOM structure by first rendering it to a
     * string and then parsing the resultant markup.
     *
     * @argument {Object} dom - The htmlparser2-compliant DOM structure
     * @argument {Object} options - The parsing/rendering options
     */
    exports.cloneDom = function(dom, options) {
        return parse(render(dom, options), options).children;
    };

    /*
     * A simple way to check for HTML strings or ID strings
     */

    var quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;

    /*
     * Check if string is HTML
     */
    exports.isHtml = function(str) {
        // Faster than running regex, if str starts with `<` and ends with `>`, assume it's HTML
        if (str.charAt(0) === '<' && str.charAt(str.length - 1) === '>' && str.length >= 3) return true;

        // Run the regex
        var match = quickExpr.exec(str);
        return !!(match && match[1]);
    };

},{"./parse":34,"dom-serializer":46}],37:[function(require,module,exports){
    module.exports={
        "_args": [
            [
                "cheerio@^0.20.0",
                "/Users/atd/Documents/Projekte/github/angular-driver/node_modules/@yaga/base"
            ]
        ],
        "_from": "cheerio@>=0.20.0 <0.21.0",
        "_id": "cheerio@0.20.0",
        "_inCache": true,
        "_installable": true,
        "_location": "/cheerio",
        "_nodeVersion": "5.5.0",
        "_npmUser": {
            "email": "me@feedic.com",
            "name": "feedic"
        },
        "_npmVersion": "3.6.0",
        "_phantomChildren": {},
        "_requested": {
            "name": "cheerio",
            "raw": "cheerio@^0.20.0",
            "rawSpec": "^0.20.0",
            "scope": null,
            "spec": ">=0.20.0 <0.21.0",
            "type": "range"
        },
        "_requiredBy": [
            "/@yaga/base"
        ],
        "_resolved": "https://registry.npmjs.org/cheerio/-/cheerio-0.20.0.tgz",
        "_shasum": "5c710f2bab95653272842ba01c6ea61b3545ec35",
        "_shrinkwrap": null,
        "_spec": "cheerio@^0.20.0",
        "_where": "/Users/atd/Documents/Projekte/github/angular-driver/node_modules/@yaga/base",
        "author": {
            "email": "mattmuelle@gmail.com",
            "name": "Matt Mueller",
            "url": "mat.io"
        },
        "bugs": {
            "url": "https://github.com/cheeriojs/cheerio/issues"
        },
        "dependencies": {
            "css-select": "~1.2.0",
            "dom-serializer": "~0.1.0",
            "entities": "~1.1.1",
            "htmlparser2": "~3.8.1",
            "jsdom": "^7.0.2",
            "lodash": "^4.1.0"
        },
        "description": "Tiny, fast, and elegant implementation of core jQuery designed specifically for the server",
        "devDependencies": {
            "benchmark": "~1.0.0",
            "coveralls": "~2.10",
            "expect.js": "~0.3.1",
            "istanbul": "~0.2",
            "jshint": "~2.5.1",
            "mocha": "*",
            "xyz": "~0.5.0"
        },
        "directories": {},
        "dist": {
            "shasum": "5c710f2bab95653272842ba01c6ea61b3545ec35",
            "tarball": "https://registry.npmjs.org/cheerio/-/cheerio-0.20.0.tgz"
        },
        "engines": {
            "node": ">= 0.6"
        },
        "files": [
            "index.js",
            "lib"
        ],
        "gitHead": "c3ec1cd7bff41da0033bdc45375d77844f0f81c0",
        "homepage": "https://github.com/cheeriojs/cheerio#readme",
        "keywords": [
            "htmlparser",
            "jquery",
            "selector",
            "scraper",
            "parser",
            "html"
        ],
        "license": "MIT",
        "main": "./index.js",
        "maintainers": [
            {
                "email": "mattmuelle@gmail.com",
                "name": "mattmueller"
            },
            {
                "email": "dc@davidchambers.me",
                "name": "davidchambers"
            },
            {
                "email": "mike@mikepennisi.com",
                "name": "jugglinmike"
            },
            {
                "email": "me@feedic.com",
                "name": "feedic"
            }
        ],
        "name": "cheerio",
        "optionalDependencies": {
            "jsdom": "^7.0.2"
        },
        "readme": "ERROR: No README data found!",
        "repository": {
            "type": "git",
            "url": "git://github.com/cheeriojs/cheerio.git"
        },
        "scripts": {
            "test": "make test"
        },
        "version": "0.20.0"
    }

},{}],38:[function(require,module,exports){
    "use strict";

    module.exports = CSSselect;

    var Pseudos       = require("./lib/pseudos.js"),
        DomUtils      = require("domutils"),
        findOne       = DomUtils.findOne,
        findAll       = DomUtils.findAll,
        getChildren   = DomUtils.getChildren,
        removeSubsets = DomUtils.removeSubsets,
        falseFunc     = require("boolbase").falseFunc,
        compile       = require("./lib/compile.js"),
        compileUnsafe = compile.compileUnsafe,
        compileToken  = compile.compileToken;

    function getSelectorFunc(searchFunc){
        return function select(query, elems, options){
            if(typeof query !== "function") query = compileUnsafe(query, options, elems);
            if(!Array.isArray(elems)) elems = getChildren(elems);
            else elems = removeSubsets(elems);
            return searchFunc(query, elems);
        };
    }

    var selectAll = getSelectorFunc(function selectAll(query, elems){
        return (query === falseFunc || !elems || elems.length === 0) ? [] : findAll(query, elems);
    });

    var selectOne = getSelectorFunc(function selectOne(query, elems){
        return (query === falseFunc || !elems || elems.length === 0) ? null : findOne(query, elems);
    });

    function is(elem, query, options){
        return (typeof query === "function" ? query : compile(query, options))(elem);
    }

    /*
     the exported interface
     */
    function CSSselect(query, elems, options){
        return selectAll(query, elems, options);
    }

    CSSselect.compile = compile;
    CSSselect.filters = Pseudos.filters;
    CSSselect.pseudos = Pseudos.pseudos;

    CSSselect.selectAll = selectAll;
    CSSselect.selectOne = selectOne;

    CSSselect.is = is;

//legacy methods (might be removed)
    CSSselect.parse = compile;
    CSSselect.iterate = selectAll;

//hooks
    CSSselect._compileUnsafe = compileUnsafe;
    CSSselect._compileToken = compileToken;

},{"./lib/compile.js":40,"./lib/pseudos.js":43,"boolbase":26,"domutils":52}],39:[function(require,module,exports){
    var DomUtils  = require("domutils"),
        hasAttrib = DomUtils.hasAttrib,
        getAttributeValue = DomUtils.getAttributeValue,
        falseFunc = require("boolbase").falseFunc;

//https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js#L469
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;

    /*
     attribute selectors
     */

    var attributeRules = {
        __proto__: null,
        equals: function(next, data){
            var name  = data.name,
                value = data.value;

            if(data.ignoreCase){
                value = value.toLowerCase();

                return function equalsIC(elem){
                    var attr = getAttributeValue(elem, name);
                    return attr != null && attr.toLowerCase() === value && next(elem);
                };
            }

            return function equals(elem){
                return getAttributeValue(elem, name) === value && next(elem);
            };
        },
        hyphen: function(next, data){
            var name  = data.name,
                value = data.value,
                len = value.length;

            if(data.ignoreCase){
                value = value.toLowerCase();

                return function hyphenIC(elem){
                    var attr = getAttributeValue(elem, name);
                    return attr != null &&
                        (attr.length === len || attr.charAt(len) === "-") &&
                        attr.substr(0, len).toLowerCase() === value &&
                        next(elem);
                };
            }

            return function hyphen(elem){
                var attr = getAttributeValue(elem, name);
                return attr != null &&
                    attr.substr(0, len) === value &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    next(elem);
            };
        },
        element: function(next, data){
            var name = data.name,
                value = data.value;

            if(/\s/.test(value)){
                return falseFunc;
            }

            value = value.replace(reChars, "\\$&");

            var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
                flags = data.ignoreCase ? "i" : "",
                regex = new RegExp(pattern, flags);

            return function element(elem){
                var attr = getAttributeValue(elem, name);
                return attr != null && regex.test(attr) && next(elem);
            };
        },
        exists: function(next, data){
            var name = data.name;
            return function exists(elem){
                return hasAttrib(elem, name) && next(elem);
            };
        },
        start: function(next, data){
            var name  = data.name,
                value = data.value,
                len = value.length;

            if(len === 0){
                return falseFunc;
            }

            if(data.ignoreCase){
                value = value.toLowerCase();

                return function startIC(elem){
                    var attr = getAttributeValue(elem, name);
                    return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
                };
            }

            return function start(elem){
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.substr(0, len) === value && next(elem);
            };
        },
        end: function(next, data){
            var name  = data.name,
                value = data.value,
                len   = -value.length;

            if(len === 0){
                return falseFunc;
            }

            if(data.ignoreCase){
                value = value.toLowerCase();

                return function endIC(elem){
                    var attr = getAttributeValue(elem, name);
                    return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
                };
            }

            return function end(elem){
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.substr(len) === value && next(elem);
            };
        },
        any: function(next, data){
            var name  = data.name,
                value = data.value;

            if(value === ""){
                return falseFunc;
            }

            if(data.ignoreCase){
                var regex = new RegExp(value.replace(reChars, "\\$&"), "i");

                return function anyIC(elem){
                    var attr = getAttributeValue(elem, name);
                    return attr != null && regex.test(attr) && next(elem);
                };
            }

            return function any(elem){
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.indexOf(value) >= 0 && next(elem);
            };
        },
        not: function(next, data){
            var name  = data.name,
                value = data.value;

            if(value === ""){
                return function notEmpty(elem){
                    return !!getAttributeValue(elem, name) && next(elem);
                };
            } else if(data.ignoreCase){
                value = value.toLowerCase();

                return function notIC(elem){
                    var attr = getAttributeValue(elem, name);
                    return attr != null && attr.toLowerCase() !== value && next(elem);
                };
            }

            return function not(elem){
                return getAttributeValue(elem, name) !== value && next(elem);
            };
        }
    };

    module.exports = {
        compile: function(next, data, options){
            if(options && options.strict && (
                    data.ignoreCase || data.action === "not"
                )) throw SyntaxError("Unsupported attribute selector");
            return attributeRules[data.action](next, data);
        },
        rules: attributeRules
    };

},{"boolbase":26,"domutils":52}],40:[function(require,module,exports){
    /*
     compiles a selector to an executable function
     */

    module.exports = compile;
    module.exports.compileUnsafe = compileUnsafe;
    module.exports.compileToken = compileToken;

    var parse       = require("css-what"),
        DomUtils    = require("domutils"),
        isTag       = DomUtils.isTag,
        Rules       = require("./general.js"),
        sortRules   = require("./sort.js"),
        BaseFuncs   = require("boolbase"),
        trueFunc    = BaseFuncs.trueFunc,
        falseFunc   = BaseFuncs.falseFunc,
        procedure   = require("./procedure.json");

    function compile(selector, options, context){
        var next = compileUnsafe(selector, options, context);
        return wrap(next);
    }

    function wrap(next){
        return function base(elem){
            return isTag(elem) && next(elem);
        };
    }

    function compileUnsafe(selector, options, context){
        var token = parse(selector, options);
        return compileToken(token, options, context);
    }

    function includesScopePseudo(t){
        return t.type === "pseudo" && (
                t.name === "scope" || (
                    Array.isArray(t.data) &&
                    t.data.some(function(data){
                        return data.some(includesScopePseudo);
                    })
                )
            );
    }

    var DESCENDANT_TOKEN = {type: "descendant"},
        SCOPE_TOKEN = {type: "pseudo", name: "scope"},
        PLACEHOLDER_ELEMENT = {},
        getParent = DomUtils.getParent;

//CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
//http://www.w3.org/TR/selectors4/#absolutizing
    function absolutize(token, context){
        //TODO better check if context is document
        var hasContext = !!context && !!context.length && context.every(function(e){
                return e === PLACEHOLDER_ELEMENT || !!getParent(e);
            });


        token.forEach(function(t){
            if(t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant"){
                //don't return in else branch
            } else if(hasContext && !includesScopePseudo(t)){
                t.unshift(DESCENDANT_TOKEN);
            } else {
                return;
            }

            t.unshift(SCOPE_TOKEN);
        });
    }

    function compileToken(token, options, context){
        token = token.filter(function(t){ return t.length > 0; });

        token.forEach(sortRules);

        var isArrayContext = Array.isArray(context);

        context = (options && options.context) || context;

        if(context && !isArrayContext) context = [context];

        absolutize(token, context);

        return token
            .map(function(rules){ return compileRules(rules, options, context, isArrayContext); })
            .reduce(reduceRules, falseFunc);
    }

    function isTraversal(t){
        return procedure[t.type] < 0;
    }

    function compileRules(rules, options, context, isArrayContext){
        var acceptSelf = (isArrayContext && rules[0].name === "scope" && rules[1].type === "descendant");
        return rules.reduce(function(func, rule, index){
            if(func === falseFunc) return func;
            return Rules[rule.type](func, rule, options, context, acceptSelf && index === 1);
        }, options && options.rootFunc || trueFunc);
    }

    function reduceRules(a, b){
        if(b === falseFunc || a === trueFunc){
            return a;
        }
        if(a === falseFunc || b === trueFunc){
            return b;
        }

        return function combine(elem){
            return a(elem) || b(elem);
        };
    }

//:not, :has and :matches have to compile selectors
//doing this in lib/pseudos.js would lead to circular dependencies,
//so we add them here

    var Pseudos     = require("./pseudos.js"),
        filters     = Pseudos.filters,
        existsOne   = DomUtils.existsOne,
        isTag       = DomUtils.isTag,
        getChildren = DomUtils.getChildren;


    function containsTraversal(t){
        return t.some(isTraversal);
    }

    filters.not = function(next, token, options, context){
        var opts = {
            xmlMode: !!(options && options.xmlMode),
            strict: !!(options && options.strict)
        };

        if(opts.strict){
            if(token.length > 1 || token.some(containsTraversal)){
                throw new SyntaxError("complex selectors in :not aren't allowed in strict mode");
            }
        }

        var func = compileToken(token, opts, context);

        if(func === falseFunc) return next;
        if(func === trueFunc)  return falseFunc;

        return function(elem){
            return !func(elem) && next(elem);
        };
    };

    filters.has = function(next, token, options){
        var opts = {
            xmlMode: !!(options && options.xmlMode),
            strict: !!(options && options.strict)
        };

        //FIXME: Uses an array as a pointer to the current element (side effects)
        var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;

        var func = compileToken(token, opts, context);

        if(func === falseFunc) return falseFunc;
        if(func === trueFunc)  return function(elem){
            return getChildren(elem).some(isTag) && next(elem);
        };

        func = wrap(func);

        if(context){
            return function has(elem){
                return next(elem) && (
                        (context[0] = elem), existsOne(func, getChildren(elem))
                    );
            };
        }

        return function has(elem){
            return next(elem) && existsOne(func, getChildren(elem));
        };
    };

    filters.matches = function(next, token, options, context){
        var opts = {
            xmlMode: !!(options && options.xmlMode),
            strict: !!(options && options.strict),
            rootFunc: next
        };

        return compileToken(token, opts, context);
    };

},{"./general.js":41,"./procedure.json":42,"./pseudos.js":43,"./sort.js":44,"boolbase":26,"css-what":45,"domutils":52}],41:[function(require,module,exports){
    var DomUtils    = require("domutils"),
        isTag       = DomUtils.isTag,
        getParent   = DomUtils.getParent,
        getChildren = DomUtils.getChildren,
        getSiblings = DomUtils.getSiblings,
        getName     = DomUtils.getName;

    /*
     all available rules
     */
    module.exports = {
        __proto__: null,

        attribute: require("./attributes.js").compile,
        pseudo: require("./pseudos.js").compile,

        //tags
        tag: function(next, data){
            var name = data.name;
            return function tag(elem){
                return getName(elem) === name && next(elem);
            };
        },

        //traversal
        descendant: function(next, rule, options, context, acceptSelf){
            return function descendant(elem){

                if (acceptSelf && next(elem)) return true;

                var found = false;

                while(!found && (elem = getParent(elem))){
                    found = next(elem);
                }

                return found;
            };
        },
        parent: function(next, data, options){
            if(options && options.strict) throw SyntaxError("Parent selector isn't part of CSS3");

            return function parent(elem){
                return getChildren(elem).some(test);
            };

            function test(elem){
                return isTag(elem) && next(elem);
            }
        },
        child: function(next){
            return function child(elem){
                var parent = getParent(elem);
                return !!parent && next(parent);
            };
        },
        sibling: function(next){
            return function sibling(elem){
                var siblings = getSiblings(elem);

                for(var i = 0; i < siblings.length; i++){
                    if(isTag(siblings[i])){
                        if(siblings[i] === elem) break;
                        if(next(siblings[i])) return true;
                    }
                }

                return false;
            };
        },
        adjacent: function(next){
            return function adjacent(elem){
                var siblings = getSiblings(elem),
                    lastElement;

                for(var i = 0; i < siblings.length; i++){
                    if(isTag(siblings[i])){
                        if(siblings[i] === elem) break;
                        lastElement = siblings[i];
                    }
                }

                return !!lastElement && next(lastElement);
            };
        },
        universal: function(next){
            return next;
        }
    };
},{"./attributes.js":39,"./pseudos.js":43,"domutils":52}],42:[function(require,module,exports){
    module.exports={
        "universal": 50,
        "tag": 30,
        "attribute": 1,
        "pseudo": 0,
        "descendant": -1,
        "child": -1,
        "parent": -1,
        "sibling": -1,
        "adjacent": -1
    }

},{}],43:[function(require,module,exports){
    /*
     pseudo selectors

     ---

     they are available in two forms:
     * filters called when the selector
     is compiled and return a function
     that needs to return next()
     * pseudos get called on execution
     they need to return a boolean
     */

    var DomUtils    = require("domutils"),
        isTag       = DomUtils.isTag,
        getText     = DomUtils.getText,
        getParent   = DomUtils.getParent,
        getChildren = DomUtils.getChildren,
        getSiblings = DomUtils.getSiblings,
        hasAttrib   = DomUtils.hasAttrib,
        getName     = DomUtils.getName,
        getAttribute= DomUtils.getAttributeValue,
        getNCheck   = require("nth-check"),
        checkAttrib = require("./attributes.js").rules.equals,
        BaseFuncs   = require("boolbase"),
        trueFunc    = BaseFuncs.trueFunc,
        falseFunc   = BaseFuncs.falseFunc;

//helper methods
    function getFirstElement(elems){
        for(var i = 0; elems && i < elems.length; i++){
            if(isTag(elems[i])) return elems[i];
        }
    }

    function getAttribFunc(name, value){
        var data = {name: name, value: value};
        return function attribFunc(next){
            return checkAttrib(next, data);
        };
    }

    function getChildFunc(next){
        return function(elem){
            return !!getParent(elem) && next(elem);
        };
    }

    var filters = {
        contains: function(next, text){
            return function contains(elem){
                return next(elem) && getText(elem).indexOf(text) >= 0;
            };
        },
        icontains: function(next, text){
            var itext = text.toLowerCase();
            return function icontains(elem){
                return next(elem) &&
                    getText(elem).toLowerCase().indexOf(itext) >= 0;
            };
        },

        //location specific methods
        "nth-child": function(next, rule){
            var func = getNCheck(rule);

            if(func === falseFunc) return func;
            if(func === trueFunc)  return getChildFunc(next);

            return function nthChild(elem){
                var siblings = getSiblings(elem);

                for(var i = 0, pos = 0; i < siblings.length; i++){
                    if(isTag(siblings[i])){
                        if(siblings[i] === elem) break;
                        else pos++;
                    }
                }

                return func(pos) && next(elem);
            };
        },
        "nth-last-child": function(next, rule){
            var func = getNCheck(rule);

            if(func === falseFunc) return func;
            if(func === trueFunc)  return getChildFunc(next);

            return function nthLastChild(elem){
                var siblings = getSiblings(elem);

                for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
                    if(isTag(siblings[i])){
                        if(siblings[i] === elem) break;
                        else pos++;
                    }
                }

                return func(pos) && next(elem);
            };
        },
        "nth-of-type": function(next, rule){
            var func = getNCheck(rule);

            if(func === falseFunc) return func;
            if(func === trueFunc)  return getChildFunc(next);

            return function nthOfType(elem){
                var siblings = getSiblings(elem);

                for(var pos = 0, i = 0; i < siblings.length; i++){
                    if(isTag(siblings[i])){
                        if(siblings[i] === elem) break;
                        if(getName(siblings[i]) === getName(elem)) pos++;
                    }
                }

                return func(pos) && next(elem);
            };
        },
        "nth-last-of-type": function(next, rule){
            var func = getNCheck(rule);

            if(func === falseFunc) return func;
            if(func === trueFunc)  return getChildFunc(next);

            return function nthLastOfType(elem){
                var siblings = getSiblings(elem);

                for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
                    if(isTag(siblings[i])){
                        if(siblings[i] === elem) break;
                        if(getName(siblings[i]) === getName(elem)) pos++;
                    }
                }

                return func(pos) && next(elem);
            };
        },

        //TODO determine the actual root element
        root: function(next){
            return function(elem){
                return !getParent(elem) && next(elem);
            };
        },

        scope: function(next, rule, options, context){
            if(!context || context.length === 0){
                //equivalent to :root
                return filters.root(next);
            }

            if(context.length === 1){
                //NOTE: can't be unpacked, as :has uses this for side-effects
                return function(elem){
                    return context[0] === elem && next(elem);
                };
            }

            return function(elem){
                return context.indexOf(elem) >= 0 && next(elem);
            };
        },

        //jQuery extensions (others follow as pseudos)
        checkbox: getAttribFunc("type", "checkbox"),
        file: getAttribFunc("type", "file"),
        password: getAttribFunc("type", "password"),
        radio: getAttribFunc("type", "radio"),
        reset: getAttribFunc("type", "reset"),
        image: getAttribFunc("type", "image"),
        submit: getAttribFunc("type", "submit")
    };

//while filters are precompiled, pseudos get called when they are needed
    var pseudos = {
        empty: function(elem){
            return !getChildren(elem).some(function(elem){
                return isTag(elem) || elem.type === "text";
            });
        },

        "first-child": function(elem){
            return getFirstElement(getSiblings(elem)) === elem;
        },
        "last-child": function(elem){
            var siblings = getSiblings(elem);

            for(var i = siblings.length - 1; i >= 0; i--){
                if(siblings[i] === elem) return true;
                if(isTag(siblings[i])) break;
            }

            return false;
        },
        "first-of-type": function(elem){
            var siblings = getSiblings(elem);

            for(var i = 0; i < siblings.length; i++){
                if(isTag(siblings[i])){
                    if(siblings[i] === elem) return true;
                    if(getName(siblings[i]) === getName(elem)) break;
                }
            }

            return false;
        },
        "last-of-type": function(elem){
            var siblings = getSiblings(elem);

            for(var i = siblings.length-1; i >= 0; i--){
                if(isTag(siblings[i])){
                    if(siblings[i] === elem) return true;
                    if(getName(siblings[i]) === getName(elem)) break;
                }
            }

            return false;
        },
        "only-of-type": function(elem){
            var siblings = getSiblings(elem);

            for(var i = 0, j = siblings.length; i < j; i++){
                if(isTag(siblings[i])){
                    if(siblings[i] === elem) continue;
                    if(getName(siblings[i]) === getName(elem)) return false;
                }
            }

            return true;
        },
        "only-child": function(elem){
            var siblings = getSiblings(elem);

            for(var i = 0; i < siblings.length; i++){
                if(isTag(siblings[i]) && siblings[i] !== elem) return false;
            }

            return true;
        },

        //:matches(a, area, link)[href]
        link: function(elem){
            return hasAttrib(elem, "href");
        },
        visited: falseFunc, //seems to be a valid implementation
        //TODO: :any-link once the name is finalized (as an alias of :link)

        //forms
        //to consider: :target

        //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
        selected: function(elem){
            if(hasAttrib(elem, "selected")) return true;
            else if(getName(elem) !== "option") return false;

            //the first <option> in a <select> is also selected
            var parent = getParent(elem);

            if(
                !parent ||
                getName(parent) !== "select" ||
                hasAttrib(parent, "multiple")
            ) return false;

            var siblings = getChildren(parent),
                sawElem  = false;

            for(var i = 0; i < siblings.length; i++){
                if(isTag(siblings[i])){
                    if(siblings[i] === elem){
                        sawElem = true;
                    } else if(!sawElem){
                        return false;
                    } else if(hasAttrib(siblings[i], "selected")){
                        return false;
                    }
                }
            }

            return sawElem;
        },
        //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        //:matches(
        //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
        //  optgroup[disabled] > option),
        // fieldset[disabled] * //TODO not child of first <legend>
        //)
        disabled: function(elem){
            return hasAttrib(elem, "disabled");
        },
        enabled: function(elem){
            return !hasAttrib(elem, "disabled");
        },
        //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
        checked: function(elem){
            return hasAttrib(elem, "checked") || pseudos.selected(elem);
        },
        //:matches(input, select, textarea)[required]
        required: function(elem){
            return hasAttrib(elem, "required");
        },
        //:matches(input, select, textarea):not([required])
        optional: function(elem){
            return !hasAttrib(elem, "required");
        },

        //jQuery extensions

        //:not(:empty)
        parent: function(elem){
            return !pseudos.empty(elem);
        },
        //:matches(h1, h2, h3, h4, h5, h6)
        header: function(elem){
            var name = getName(elem);
            return name === "h1" ||
                name === "h2" ||
                name === "h3" ||
                name === "h4" ||
                name === "h5" ||
                name === "h6";
        },

        //:matches(button, input[type=button])
        button: function(elem){
            var name = getName(elem);
            return name === "button" ||
                name === "input" &&
                getAttribute(elem, "type") === "button";
        },
        //:matches(input, textarea, select, button)
        input: function(elem){
            var name = getName(elem);
            return name === "input" ||
                name === "textarea" ||
                name === "select" ||
                name === "button";
        },
        //input:matches(:not([type!='']), [type='text' i])
        text: function(elem){
            var attr;
            return getName(elem) === "input" && (
                    !(attr = getAttribute(elem, "type")) ||
                    attr.toLowerCase() === "text"
                );
        }
    };

    function verifyArgs(func, name, subselect){
        if(subselect === null){
            if(func.length > 1 && name !== "scope"){
                throw new SyntaxError("pseudo-selector :" + name + " requires an argument");
            }
        } else {
            if(func.length === 1){
                throw new SyntaxError("pseudo-selector :" + name + " doesn't have any arguments");
            }
        }
    }

//FIXME this feels hacky
    var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;

    module.exports = {
        compile: function(next, data, options, context){
            var name = data.name,
                subselect = data.data;

            if(options && options.strict && !re_CSS3.test(name)){
                throw SyntaxError(":" + name + " isn't part of CSS3");
            }

            if(typeof filters[name] === "function"){
                verifyArgs(filters[name], name,  subselect);
                return filters[name](next, subselect, options, context);
            } else if(typeof pseudos[name] === "function"){
                var func = pseudos[name];
                verifyArgs(func, name, subselect);

                if(next === trueFunc) return func;

                return function pseudoArgs(elem){
                    return func(elem, subselect) && next(elem);
                };
            } else {
                throw new SyntaxError("unmatched pseudo-class :" + name);
            }
        },
        filters: filters,
        pseudos: pseudos
    };

},{"./attributes.js":39,"boolbase":26,"domutils":52,"nth-check":83}],44:[function(require,module,exports){
    module.exports = sortByProcedure;

    /*
     sort the parts of the passed selector,
     as there is potential for optimization
     (some types of selectors are faster than others)
     */

    var procedure = require("./procedure.json");

    var attributes = {
        __proto__: null,
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
    };

    function sortByProcedure(arr){
        var procs = arr.map(getProcedure);
        for(var i = 1; i < arr.length; i++){
            var procNew = procs[i];

            if(procNew < 0) continue;

            for(var j = i - 1; j >= 0 && procNew < procs[j]; j--){
                var token = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = token;
                procs[j + 1] = procs[j];
                procs[j] = procNew;
            }
        }
    }

    function getProcedure(token){
        var proc = procedure[token.type];

        if(proc === procedure.attribute){
            proc = attributes[token.action];

            if(proc === attributes.equals && token.name === "id"){
                //prefer ID selectors (eg. #ID)
                proc = 9;
            }

            if(token.ignoreCase){
                //ignoreCase adds some overhead, prefer "normal" token
                //this is a binary operation, to ensure it's still an int
                proc >>= 1;
            }
        } else if(proc === procedure.pseudo){
            if(!token.data){
                proc = 3;
            } else if(token.name === "has" || token.name === "contains"){
                proc = 0; //expensive in any case
            } else if(token.name === "matches" || token.name === "not"){
                proc = 0;
                for(var i = 0; i < token.data.length; i++){
                    //TODO better handling of complex selectors
                    if(token.data[i].length !== 1) continue;
                    var cur = getProcedure(token.data[i][0]);
                    //avoid executing :has or :contains
                    if(cur === 0){
                        proc = 0;
                        break;
                    }
                    if(cur > proc) proc = cur;
                }
                if(token.data.length > 1 && proc > 0) proc -= 1;
            } else {
                proc = 1;
            }
        }
        return proc;
    }

},{"./procedure.json":42}],45:[function(require,module,exports){
    "use strict";

    module.exports = parse;

    var re_name = /^(?:\\.|[\w\-\u00c0-\uFFFF])+/,
        re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/ig,
    //modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87
        re_attr = /^\s*((?:\\.|[\w\u00c0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])(.*?)\3|(#?(?:\\.|[\w\u00c0-\uFFFF\-])*)|)|)\s*(i)?\]/;

    var actionTypes = {
        __proto__: null,
        "undefined": "exists",
        "":  "equals",
        "~": "element",
        "^": "start",
        "$": "end",
        "*": "any",
        "!": "not",
        "|": "hyphen"
    };

    var simpleSelectors = {
        __proto__: null,
        ">": "child",
        "<": "parent",
        "~": "sibling",
        "+": "adjacent"
    };

    var attribSelectors = {
        __proto__: null,
        "#": ["id", "equals"],
        ".": ["class", "element"]
    };

//pseudos, whose data-property is parsed as well
    var unpackPseudos = {
        __proto__: null,
        "has": true,
        "not": true,
        "matches": true
    };

    var stripQuotesFromPseudos = {
        __proto__: null,
        "contains": true,
        "icontains": true
    };

    var quotes = {
        __proto__: null,
        "\"": true,
        "'": true
    };

//unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L139
    function funescape( _, escaped, escapedWhitespace ) {
        var high = "0x" + escaped - 0x10000;
        // NaN means non-codepoint
        // Support: Firefox
        // Workaround erroneous numeric interpretation of +"0x"
        return high !== high || escapedWhitespace ?
            escaped :
            // BMP codepoint
            high < 0 ?
                String.fromCharCode( high + 0x10000 ) :
                // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
    }

    function unescapeCSS(str){
        return str.replace(re_escape, funescape);
    }

    function isWhitespace(c){
        return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
    }

    function parse(selector, options){
        var subselects = [];

        selector = parseSelector(subselects, selector + "", options);

        if(selector !== ""){
            throw new SyntaxError("Unmatched selector: " + selector);
        }

        return subselects;
    }

    function parseSelector(subselects, selector, options){
        var tokens = [],
            sawWS = false,
            data, firstChar, name, quot;

        function getName(){
            var sub = selector.match(re_name)[0];
            selector = selector.substr(sub.length);
            return unescapeCSS(sub);
        }

        function stripWhitespace(start){
            while(isWhitespace(selector.charAt(start))) start++;
            selector = selector.substr(start);
        }

        stripWhitespace(0);

        while(selector !== ""){
            firstChar = selector.charAt(0);

            if(isWhitespace(firstChar)){
                sawWS = true;
                stripWhitespace(1);
            } else if(firstChar in simpleSelectors){
                tokens.push({type: simpleSelectors[firstChar]});
                sawWS = false;

                stripWhitespace(1);
            } else if(firstChar === ","){
                if(tokens.length === 0){
                    throw new SyntaxError("empty sub-selector");
                }
                subselects.push(tokens);
                tokens = [];
                sawWS = false;
                stripWhitespace(1);
            } else {
                if(sawWS){
                    if(tokens.length > 0){
                        tokens.push({type: "descendant"});
                    }
                    sawWS = false;
                }

                if(firstChar === "*"){
                    selector = selector.substr(1);
                    tokens.push({type: "universal"});
                } else if(firstChar in attribSelectors){
                    selector = selector.substr(1);
                    tokens.push({
                        type: "attribute",
                        name: attribSelectors[firstChar][0],
                        action: attribSelectors[firstChar][1],
                        value: getName(),
                        ignoreCase: false
                    });
                } else if(firstChar === "["){
                    selector = selector.substr(1);
                    data = selector.match(re_attr);
                    if(!data){
                        throw new SyntaxError("Malformed attribute selector: " + selector);
                    }
                    selector = selector.substr(data[0].length);
                    name = unescapeCSS(data[1]);

                    if(
                        !options || (
                            "lowerCaseAttributeNames" in options ?
                                options.lowerCaseAttributeNames :
                                !options.xmlMode
                        )
                    ){
                        name = name.toLowerCase();
                    }

                    tokens.push({
                        type: "attribute",
                        name: name,
                        action: actionTypes[data[2]],
                        value: unescapeCSS(data[4] || data[5] || ""),
                        ignoreCase: !!data[6]
                    });

                } else if(firstChar === ":"){
                    if(selector.charAt(1) === ":"){
                        selector = selector.substr(2);
                        tokens.push({type: "pseudo-element", name: getName().toLowerCase()});
                        continue;
                    }

                    selector = selector.substr(1);

                    name = getName().toLowerCase();
                    data = null;

                    if(selector.charAt(0) === "("){
                        if(name in unpackPseudos){
                            quot = selector.charAt(1);
                            var quoted = quot in quotes;

                            selector = selector.substr(quoted + 1);

                            data = [];
                            selector = parseSelector(data, selector, options);

                            if(quoted){
                                if(selector.charAt(0) !== quot){
                                    throw new SyntaxError("unmatched quotes in :" + name);
                                } else {
                                    selector = selector.substr(1);
                                }
                            }

                            if(selector.charAt(0) !== ")"){
                                throw new SyntaxError("missing closing parenthesis in :" + name + " " + selector);
                            }

                            selector = selector.substr(1);
                        } else {
                            var pos = 1, counter = 1;

                            for(; counter > 0 && pos < selector.length; pos++){
                                if(selector.charAt(pos) === "(") counter++;
                                else if(selector.charAt(pos) === ")") counter--;
                            }

                            if(counter){
                                throw new SyntaxError("parenthesis not matched");
                            }

                            data = selector.substr(1, pos - 2);
                            selector = selector.substr(pos);

                            if(name in stripQuotesFromPseudos){
                                quot = data.charAt(0);

                                if(quot === data.slice(-1) && quot in quotes){
                                    data = data.slice(1, -1);
                                }

                                data = unescapeCSS(data);
                            }
                        }
                    }

                    tokens.push({type: "pseudo", name: name, data: data});
                } else if(re_name.test(selector)){
                    name = getName();

                    if(!options || ("lowerCaseTags" in options ? options.lowerCaseTags : !options.xmlMode)){
                        name = name.toLowerCase();
                    }

                    tokens.push({type: "tag", name: name});
                } else {
                    if(tokens.length && tokens[tokens.length - 1].type === "descendant"){
                        tokens.pop();
                    }
                    addToken(subselects, tokens);
                    return selector;
                }
            }
        }

        addToken(subselects, tokens);

        return selector;
    }

    function addToken(subselects, tokens){
        if(subselects.length > 0 && tokens.length === 0){
            throw new SyntaxError("empty sub-selector");
        }

        subselects.push(tokens);
    }

},{}],46:[function(require,module,exports){
    /*
     Module dependencies
     */
    var ElementType = require('domelementtype');
    var entities = require('entities');

    /*
     Boolean Attributes
     */
    var booleanAttributes = {
        __proto__: null,
        allowfullscreen: true,
        async: true,
        autofocus: true,
        autoplay: true,
        checked: true,
        controls: true,
        default: true,
        defer: true,
        disabled: true,
        hidden: true,
        ismap: true,
        loop: true,
        multiple: true,
        muted: true,
        open: true,
        readonly: true,
        required: true,
        reversed: true,
        scoped: true,
        seamless: true,
        selected: true,
        typemustmatch: true
    };

    var unencodedElements = {
        __proto__: null,
        style: true,
        script: true,
        xmp: true,
        iframe: true,
        noembed: true,
        noframes: true,
        plaintext: true,
        noscript: true
    };

    /*
     Format attributes
     */
    function formatAttrs(attributes, opts) {
        if (!attributes) return;

        var output = '',
            value;

        // Loop through the attributes
        for (var key in attributes) {
            value = attributes[key];
            if (output) {
                output += ' ';
            }

            if (!value && booleanAttributes[key]) {
                output += key;
            } else {
                output += key + '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
            }
        }

        return output;
    }

    /*
     Self-enclosing tags (stolen from node-htmlparser)
     */
    var singleTag = {
        __proto__: null,
        area: true,
        base: true,
        basefont: true,
        br: true,
        col: true,
        command: true,
        embed: true,
        frame: true,
        hr: true,
        img: true,
        input: true,
        isindex: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true,
    };


    var render = module.exports = function(dom, opts) {
        if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
        opts = opts || {};

        var output = '';

        for(var i = 0; i < dom.length; i++){
            var elem = dom[i];

            if (elem.type === 'root')
                output += render(elem.children, opts);
            else if (ElementType.isTag(elem))
                output += renderTag(elem, opts);
            else if (elem.type === ElementType.Directive)
                output += renderDirective(elem);
            else if (elem.type === ElementType.Comment)
                output += renderComment(elem);
            else if (elem.type === ElementType.CDATA)
                output += renderCdata(elem);
            else
                output += renderText(elem, opts);
        }

        return output;
    };

    function renderTag(elem, opts) {
        // Handle SVG
        if (elem.name === "svg") opts = {decodeEntities: opts.decodeEntities, xmlMode: true};

        var tag = '<' + elem.name,
            attribs = formatAttrs(elem.attribs, opts);

        if (attribs) {
            tag += ' ' + attribs;
        }

        if (
            opts.xmlMode
            && (!elem.children || elem.children.length === 0)
        ) {
            tag += '/>';
        } else {
            tag += '>';
            if (elem.children) {
                tag += render(elem.children, opts);
            }

            if (!singleTag[elem.name] || opts.xmlMode) {
                tag += '</' + elem.name + '>';
            }
        }

        return tag;
    }

    function renderDirective(elem) {
        return '<' + elem.data + '>';
    }

    function renderText(elem, opts) {
        var data = elem.data || '';

        // if entities weren't decoded, no need to encode them back
        if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
            data = entities.encodeXML(data);
        }

        return data;
    }

    function renderCdata(elem) {
        return '<![CDATA[' + elem.children[0].data + ']]>';
    }

    function renderComment(elem) {
        return '<!--' + elem.data + '-->';
    }

},{"domelementtype":47,"entities":59}],47:[function(require,module,exports){
//Types of elements found in the DOM
    module.exports = {
        Text: "text", //Text
        Directive: "directive", //<? ... ?>
        Comment: "comment", //<!-- ... -->
        Script: "script", //<script> tags
        Style: "style", //<style> tags
        Tag: "tag", //Any tag
        CDATA: "cdata", //<![CDATA[ ... ]]>

        isTag: function(elem){
            return elem.type === "tag" || elem.type === "script" || elem.type === "style";
        }
    };
},{}],48:[function(require,module,exports){
//Types of elements found in the DOM
    module.exports = {
        Text: "text", //Text
        Directive: "directive", //<? ... ?>
        Comment: "comment", //<!-- ... -->
        Script: "script", //<script> tags
        Style: "style", //<style> tags
        Tag: "tag", //Any tag
        CDATA: "cdata", //<![CDATA[ ... ]]>
        Doctype: "doctype",

        isTag: function(elem){
            return elem.type === "tag" || elem.type === "script" || elem.type === "style";
        }
    };

},{}],49:[function(require,module,exports){
    var ElementType = require("domelementtype");

    var re_whitespace = /\s+/g;
    var NodePrototype = require("./lib/node");
    var ElementPrototype = require("./lib/element");

    function DomHandler(callback, options, elementCB){
        if(typeof callback === "object"){
            elementCB = options;
            options = callback;
            callback = null;
        } else if(typeof options === "function"){
            elementCB = options;
            options = defaultOpts;
        }
        this._callback = callback;
        this._options = options || defaultOpts;
        this._elementCB = elementCB;
        this.dom = [];
        this._done = false;
        this._tagStack = [];
        this._parser = this._parser || null;
    }

//default options
    var defaultOpts = {
        normalizeWhitespace: false, //Replace all whitespace with single spaces
        withStartIndices: false, //Add startIndex properties to nodes
    };

    DomHandler.prototype.onparserinit = function(parser){
        this._parser = parser;
    };

//Resets the handler back to starting state
    DomHandler.prototype.onreset = function(){
        DomHandler.call(this, this._callback, this._options, this._elementCB);
    };

//Signals the handler that parsing is done
    DomHandler.prototype.onend = function(){
        if(this._done) return;
        this._done = true;
        this._parser = null;
        this._handleCallback(null);
    };

    DomHandler.prototype._handleCallback =
        DomHandler.prototype.onerror = function(error){
            if(typeof this._callback === "function"){
                this._callback(error, this.dom);
            } else {
                if(error) throw error;
            }
        };

    DomHandler.prototype.onclosetag = function(){
        //if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
        var elem = this._tagStack.pop();
        if(this._elementCB) this._elementCB(elem);
    };

    DomHandler.prototype._addDomElement = function(element){
        var parent = this._tagStack[this._tagStack.length - 1];
        var siblings = parent ? parent.children : this.dom;
        var previousSibling = siblings[siblings.length - 1];

        element.next = null;

        if(this._options.withStartIndices){
            element.startIndex = this._parser.startIndex;
        }

        if (this._options.withDomLvl1) {
            element.__proto__ = element.type === "tag" ? ElementPrototype : NodePrototype;
        }

        if(previousSibling){
            element.prev = previousSibling;
            previousSibling.next = element;
        } else {
            element.prev = null;
        }

        siblings.push(element);
        element.parent = parent || null;
    };

    DomHandler.prototype.onopentag = function(name, attribs){
        var element = {
            type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
            name: name,
            attribs: attribs,
            children: []
        };

        this._addDomElement(element);

        this._tagStack.push(element);
    };

    DomHandler.prototype.ontext = function(data){
        //the ignoreWhitespace is officially dropped, but for now,
        //it's an alias for normalizeWhitespace
        var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;

        var lastTag;

        if(!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length-1]).type === ElementType.Text){
            if(normalize){
                lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
            } else {
                lastTag.data += data;
            }
        } else {
            if(
                this._tagStack.length &&
                (lastTag = this._tagStack[this._tagStack.length - 1]) &&
                (lastTag = lastTag.children[lastTag.children.length - 1]) &&
                lastTag.type === ElementType.Text
            ){
                if(normalize){
                    lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
                } else {
                    lastTag.data += data;
                }
            } else {
                if(normalize){
                    data = data.replace(re_whitespace, " ");
                }

                this._addDomElement({
                    data: data,
                    type: ElementType.Text
                });
            }
        }
    };

    DomHandler.prototype.oncomment = function(data){
        var lastTag = this._tagStack[this._tagStack.length - 1];

        if(lastTag && lastTag.type === ElementType.Comment){
            lastTag.data += data;
            return;
        }

        var element = {
            data: data,
            type: ElementType.Comment
        };

        this._addDomElement(element);
        this._tagStack.push(element);
    };

    DomHandler.prototype.oncdatastart = function(){
        var element = {
            children: [{
                data: "",
                type: ElementType.Text
            }],
            type: ElementType.CDATA
        };

        this._addDomElement(element);
        this._tagStack.push(element);
    };

    DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function(){
        this._tagStack.pop();
    };

    DomHandler.prototype.onprocessinginstruction = function(name, data){
        this._addDomElement({
            name: name,
            data: data,
            type: ElementType.Directive
        });
    };

    module.exports = DomHandler;

},{"./lib/element":50,"./lib/node":51,"domelementtype":48}],50:[function(require,module,exports){
// DOM-Level-1-compliant structure
    var NodePrototype = require('./node');
    var ElementPrototype = module.exports = Object.create(NodePrototype);

    var domLvl1 = {
        tagName: "name"
    };

    Object.keys(domLvl1).forEach(function(key) {
        var shorthand = domLvl1[key];
        Object.defineProperty(ElementPrototype, key, {
            get: function() {
                return this[shorthand] || null;
            },
            set: function(val) {
                this[shorthand] = val;
                return val;
            }
        });
    });

},{"./node":51}],51:[function(require,module,exports){
// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
    var NodePrototype = module.exports = {
        get firstChild() {
            var children = this.children;
            return children && children[0] || null;
        },
        get lastChild() {
            var children = this.children;
            return children && children[children.length - 1] || null;
        },
        get nodeType() {
            return nodeTypes[this.type] || nodeTypes.element;
        }
    };

    var domLvl1 = {
        tagName: "name",
        childNodes: "children",
        parentNode: "parent",
        previousSibling: "prev",
        nextSibling: "next",
        nodeValue: "data"
    };

    var nodeTypes = {
        element: 1,
        text: 3,
        cdata: 4,
        comment: 8
    };

    Object.keys(domLvl1).forEach(function(key) {
        var shorthand = domLvl1[key];
        Object.defineProperty(NodePrototype, key, {
            get: function() {
                return this[shorthand] || null;
            },
            set: function(val) {
                this[shorthand] = val;
                return val;
            }
        });
    });

},{}],52:[function(require,module,exports){
    var DomUtils = module.exports;

    [
        require("./lib/stringify"),
        require("./lib/traversal"),
        require("./lib/manipulation"),
        require("./lib/querying"),
        require("./lib/legacy"),
        require("./lib/helpers")
    ].forEach(function(ext){
        Object.keys(ext).forEach(function(key){
            DomUtils[key] = ext[key].bind(DomUtils);
        });
    });

},{"./lib/helpers":53,"./lib/legacy":54,"./lib/manipulation":55,"./lib/querying":56,"./lib/stringify":57,"./lib/traversal":58}],53:[function(require,module,exports){
// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
    exports.removeSubsets = function(nodes) {
        var idx = nodes.length, node, ancestor, replace;

        // Check if each node (or one of its ancestors) is already contained in the
        // array.
        while (--idx > -1) {
            node = ancestor = nodes[idx];

            // Temporarily remove the node under consideration
            nodes[idx] = null;
            replace = true;

            while (ancestor) {
                if (nodes.indexOf(ancestor) > -1) {
                    replace = false;
                    nodes.splice(idx, 1);
                    break;
                }
                ancestor = ancestor.parent;
            }

            // If the node has been found to be unique, re-insert it.
            if (replace) {
                nodes[idx] = node;
            }
        }

        return nodes;
    };

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
    var POSITION = {
        DISCONNECTED: 1,
        PRECEDING: 2,
        FOLLOWING: 4,
        CONTAINS: 8,
        CONTAINED_BY: 16
    };

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
    var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
        var aParents = [];
        var bParents = [];
        var current, sharedParent, siblings, aSibling, bSibling, idx;

        if (nodeA === nodeB) {
            return 0;
        }

        current = nodeA;
        while (current) {
            aParents.unshift(current);
            current = current.parent;
        }
        current = nodeB;
        while (current) {
            bParents.unshift(current);
            current = current.parent;
        }

        idx = 0;
        while (aParents[idx] === bParents[idx]) {
            idx++;
        }

        if (idx === 0) {
            return POSITION.DISCONNECTED;
        }

        sharedParent = aParents[idx - 1];
        siblings = sharedParent.children;
        aSibling = aParents[idx];
        bSibling = bParents[idx];

        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
            if (sharedParent === nodeB) {
                return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
            }
            return POSITION.FOLLOWING;
        } else {
            if (sharedParent === nodeA) {
                return POSITION.PRECEDING | POSITION.CONTAINS;
            }
            return POSITION.PRECEDING;
        }
    };

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
    exports.uniqueSort = function(nodes) {
        var idx = nodes.length, node, position;

        nodes = nodes.slice();

        while (--idx > -1) {
            node = nodes[idx];
            position = nodes.indexOf(node);
            if (position > -1 && position < idx) {
                nodes.splice(idx, 1);
            }
        }
        nodes.sort(function(a, b) {
            var relative = comparePos(a, b);
            if (relative & POSITION.PRECEDING) {
                return -1;
            } else if (relative & POSITION.FOLLOWING) {
                return 1;
            }
            return 0;
        });

        return nodes;
    };

},{}],54:[function(require,module,exports){
    var ElementType = require("domelementtype");
    var isTag = exports.isTag = ElementType.isTag;

    exports.testElement = function(options, element){
        for(var key in options){
            if(!options.hasOwnProperty(key));
            else if(key === "tag_name"){
                if(!isTag(element) || !options.tag_name(element.name)){
                    return false;
                }
            } else if(key === "tag_type"){
                if(!options.tag_type(element.type)) return false;
            } else if(key === "tag_contains"){
                if(isTag(element) || !options.tag_contains(element.data)){
                    return false;
                }
            } else if(!element.attribs || !options[key](element.attribs[key])){
                return false;
            }
        }
        return true;
    };

    var Checks = {
        tag_name: function(name){
            if(typeof name === "function"){
                return function(elem){ return isTag(elem) && name(elem.name); };
            } else if(name === "*"){
                return isTag;
            } else {
                return function(elem){ return isTag(elem) && elem.name === name; };
            }
        },
        tag_type: function(type){
            if(typeof type === "function"){
                return function(elem){ return type(elem.type); };
            } else {
                return function(elem){ return elem.type === type; };
            }
        },
        tag_contains: function(data){
            if(typeof data === "function"){
                return function(elem){ return !isTag(elem) && data(elem.data); };
            } else {
                return function(elem){ return !isTag(elem) && elem.data === data; };
            }
        }
    };

    function getAttribCheck(attrib, value){
        if(typeof value === "function"){
            return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
        } else {
            return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
        }
    }

    function combineFuncs(a, b){
        return function(elem){
            return a(elem) || b(elem);
        };
    }

    exports.getElements = function(options, element, recurse, limit){
        var funcs = Object.keys(options).map(function(key){
            var value = options[key];
            return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
        });

        return funcs.length === 0 ? [] : this.filter(
            funcs.reduce(combineFuncs),
            element, recurse, limit
        );
    };

    exports.getElementById = function(id, element, recurse){
        if(!Array.isArray(element)) element = [element];
        return this.findOne(getAttribCheck("id", id), element, recurse !== false);
    };

    exports.getElementsByTagName = function(name, element, recurse, limit){
        return this.filter(Checks.tag_name(name), element, recurse, limit);
    };

    exports.getElementsByTagType = function(type, element, recurse, limit){
        return this.filter(Checks.tag_type(type), element, recurse, limit);
    };

},{"domelementtype":48}],55:[function(require,module,exports){
    exports.removeElement = function(elem){
        if(elem.prev) elem.prev.next = elem.next;
        if(elem.next) elem.next.prev = elem.prev;

        if(elem.parent){
            var childs = elem.parent.children;
            childs.splice(childs.lastIndexOf(elem), 1);
        }
    };

    exports.replaceElement = function(elem, replacement){
        var prev = replacement.prev = elem.prev;
        if(prev){
            prev.next = replacement;
        }

        var next = replacement.next = elem.next;
        if(next){
            next.prev = replacement;
        }

        var parent = replacement.parent = elem.parent;
        if(parent){
            var childs = parent.children;
            childs[childs.lastIndexOf(elem)] = replacement;
        }
    };

    exports.appendChild = function(elem, child){
        child.parent = elem;

        if(elem.children.push(child) !== 1){
            var sibling = elem.children[elem.children.length - 2];
            sibling.next = child;
            child.prev = sibling;
            child.next = null;
        }
    };

    exports.append = function(elem, next){
        var parent = elem.parent,
            currNext = elem.next;

        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;

        if(currNext){
            currNext.prev = next;
            if(parent){
                var childs = parent.children;
                childs.splice(childs.lastIndexOf(currNext), 0, next);
            }
        } else if(parent){
            parent.children.push(next);
        }
    };

    exports.prepend = function(elem, prev){
        var parent = elem.parent;
        if(parent){
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(elem), 0, prev);
        }

        if(elem.prev){
            elem.prev.next = prev;
        }

        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
    };



},{}],56:[function(require,module,exports){
    var isTag = require("domelementtype").isTag;

    module.exports = {
        filter: filter,
        find: find,
        findOneChild: findOneChild,
        findOne: findOne,
        existsOne: existsOne,
        findAll: findAll
    };

    function filter(test, element, recurse, limit){
        if(!Array.isArray(element)) element = [element];

        if(typeof limit !== "number" || !isFinite(limit)){
            limit = Infinity;
        }
        return find(test, element, recurse !== false, limit);
    }

    function find(test, elems, recurse, limit){
        var result = [], childs;

        for(var i = 0, j = elems.length; i < j; i++){
            if(test(elems[i])){
                result.push(elems[i]);
                if(--limit <= 0) break;
            }

            childs = elems[i].children;
            if(recurse && childs && childs.length > 0){
                childs = find(test, childs, recurse, limit);
                result = result.concat(childs);
                limit -= childs.length;
                if(limit <= 0) break;
            }
        }

        return result;
    }

    function findOneChild(test, elems){
        for(var i = 0, l = elems.length; i < l; i++){
            if(test(elems[i])) return elems[i];
        }

        return null;
    }

    function findOne(test, elems){
        var elem = null;

        for(var i = 0, l = elems.length; i < l && !elem; i++){
            if(!isTag(elems[i])){
                continue;
            } else if(test(elems[i])){
                elem = elems[i];
            } else if(elems[i].children.length > 0){
                elem = findOne(test, elems[i].children);
            }
        }

        return elem;
    }

    function existsOne(test, elems){
        for(var i = 0, l = elems.length; i < l; i++){
            if(
                isTag(elems[i]) && (
                    test(elems[i]) || (
                        elems[i].children.length > 0 &&
                        existsOne(test, elems[i].children)
                    )
                )
            ){
                return true;
            }
        }

        return false;
    }

    function findAll(test, elems){
        var result = [];
        for(var i = 0, j = elems.length; i < j; i++){
            if(!isTag(elems[i])) continue;
            if(test(elems[i])) result.push(elems[i]);

            if(elems[i].children.length > 0){
                result = result.concat(findAll(test, elems[i].children));
            }
        }
        return result;
    }

},{"domelementtype":48}],57:[function(require,module,exports){
    var ElementType = require("domelementtype"),
        getOuterHTML = require("dom-serializer"),
        isTag = ElementType.isTag;

    module.exports = {
        getInnerHTML: getInnerHTML,
        getOuterHTML: getOuterHTML,
        getText: getText
    };

    function getInnerHTML(elem, opts){
        return elem.children ? elem.children.map(function(elem){
            return getOuterHTML(elem, opts);
        }).join("") : "";
    }

    function getText(elem){
        if(Array.isArray(elem)) return elem.map(getText).join("");
        if(isTag(elem) || elem.type === ElementType.CDATA) return getText(elem.children);
        if(elem.type === ElementType.Text) return elem.data;
        return "";
    }

},{"dom-serializer":46,"domelementtype":48}],58:[function(require,module,exports){
    var getChildren = exports.getChildren = function(elem){
        return elem.children;
    };

    var getParent = exports.getParent = function(elem){
        return elem.parent;
    };

    exports.getSiblings = function(elem){
        var parent = getParent(elem);
        return parent ? getChildren(parent) : [elem];
    };

    exports.getAttributeValue = function(elem, name){
        return elem.attribs && elem.attribs[name];
    };

    exports.hasAttrib = function(elem, name){
        return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
    };

    exports.getName = function(elem){
        return elem.name;
    };

},{}],59:[function(require,module,exports){
    var encode = require("./lib/encode.js"),
        decode = require("./lib/decode.js");

    exports.decode = function(data, level){
        return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
    };

    exports.decodeStrict = function(data, level){
        return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
    };

    exports.encode = function(data, level){
        return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
    };

    exports.encodeXML = encode.XML;

    exports.encodeHTML4 =
        exports.encodeHTML5 =
            exports.encodeHTML  = encode.HTML;

    exports.decodeXML =
        exports.decodeXMLStrict = decode.XML;

    exports.decodeHTML4 =
        exports.decodeHTML5 =
            exports.decodeHTML = decode.HTML;

    exports.decodeHTML4Strict =
        exports.decodeHTML5Strict =
            exports.decodeHTMLStrict = decode.HTMLStrict;

    exports.escape = encode.escape;

},{"./lib/decode.js":60,"./lib/encode.js":62}],60:[function(require,module,exports){
    var entityMap = require("../maps/entities.json"),
        legacyMap = require("../maps/legacy.json"),
        xmlMap    = require("../maps/xml.json"),
        decodeCodePoint = require("./decode_codepoint.js");

    var decodeXMLStrict  = getStrictDecoder(xmlMap),
        decodeHTMLStrict = getStrictDecoder(entityMap);

    function getStrictDecoder(map){
        var keys = Object.keys(map).join("|"),
            replace = getReplacer(map);

        keys += "|#[xX][\\da-fA-F]+|#\\d+";

        var re = new RegExp("&(?:" + keys + ");", "g");

        return function(str){
            return String(str).replace(re, replace);
        };
    }

    var decodeHTML = (function(){
        var legacy = Object.keys(legacyMap)
            .sort(sorter);

        var keys = Object.keys(entityMap)
            .sort(sorter);

        for(var i = 0, j = 0; i < keys.length; i++){
            if(legacy[j] === keys[i]){
                keys[i] += ";?";
                j++;
            } else {
                keys[i] += ";";
            }
        }

        var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
            replace = getReplacer(entityMap);

        function replacer(str){
            if(str.substr(-1) !== ";") str += ";";
            return replace(str);
        }

        //TODO consider creating a merged map
        return function(str){
            return String(str).replace(re, replacer);
        };
    }());

    function sorter(a, b){
        return a < b ? 1 : -1;
    }

    function getReplacer(map){
        return function replace(str){
            if(str.charAt(1) === "#"){
                if(str.charAt(2) === "X" || str.charAt(2) === "x"){
                    return decodeCodePoint(parseInt(str.substr(3), 16));
                }
                return decodeCodePoint(parseInt(str.substr(2), 10));
            }
            return map[str.slice(1, -1)];
        };
    }

    module.exports = {
        XML: decodeXMLStrict,
        HTML: decodeHTML,
        HTMLStrict: decodeHTMLStrict
    };
},{"../maps/entities.json":64,"../maps/legacy.json":65,"../maps/xml.json":66,"./decode_codepoint.js":61}],61:[function(require,module,exports){
    var decodeMap = require("../maps/decode.json");

    module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
    function decodeCodePoint(codePoint){

        if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
            return "\uFFFD";
        }

        if(codePoint in decodeMap){
            codePoint = decodeMap[codePoint];
        }

        var output = "";

        if(codePoint > 0xFFFF){
            codePoint -= 0x10000;
            output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        output += String.fromCharCode(codePoint);
        return output;
    }

},{"../maps/decode.json":63}],62:[function(require,module,exports){
    var inverseXML = getInverseObj(require("../maps/xml.json")),
        xmlReplacer = getInverseReplacer(inverseXML);

    exports.XML = getInverse(inverseXML, xmlReplacer);

    var inverseHTML = getInverseObj(require("../maps/entities.json")),
        htmlReplacer = getInverseReplacer(inverseHTML);

    exports.HTML = getInverse(inverseHTML, htmlReplacer);

    function getInverseObj(obj){
        return Object.keys(obj).sort().reduce(function(inverse, name){
            inverse[obj[name]] = "&" + name + ";";
            return inverse;
        }, {});
    }

    function getInverseReplacer(inverse){
        var single = [],
            multiple = [];

        Object.keys(inverse).forEach(function(k){
            if(k.length === 1){
                single.push("\\" + k);
            } else {
                multiple.push(k);
            }
        });

        //TODO add ranges
        multiple.unshift("[" + single.join("") + "]");

        return new RegExp(multiple.join("|"), "g");
    }

    var re_nonASCII = /[^\0-\x7F]/g,
        re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

    function singleCharReplacer(c){
        return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
    }

    function astralReplacer(c){
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        var high = c.charCodeAt(0);
        var low  = c.charCodeAt(1);
        var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
    }

    function getInverse(inverse, re){
        function func(name){
            return inverse[name];
        }

        return function(data){
            return data
                .replace(re, func)
                .replace(re_astralSymbols, astralReplacer)
                .replace(re_nonASCII, singleCharReplacer);
        };
    }

    var re_xmlChars = getInverseReplacer(inverseXML);

    function escapeXML(data){
        return data
            .replace(re_xmlChars, singleCharReplacer)
            .replace(re_astralSymbols, astralReplacer)
            .replace(re_nonASCII, singleCharReplacer);
    }

    exports.escape = escapeXML;

},{"../maps/entities.json":64,"../maps/xml.json":66}],63:[function(require,module,exports){
    module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}
},{}],64:[function(require,module,exports){
    module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","Acy":"\u0410","acy":"\u0430","AElig":"\u00C6","aelig":"\u00E6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\u00C0","agrave":"\u00E0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\u00C5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\u00C5","aring":"\u00E5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\u00A6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\u00C7","ccedil":"\u00E7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\u00B8","Cedilla":"\u00B8","cemptyv":"\u29B2","cent":"\u00A2","centerdot":"\u00B7","CenterDot":"\u00B7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\u00AE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\u00A9","COPY":"\u00A9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\u00A4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\u00B0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\u00B4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\u00A8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\u00F7","divide":"\u00F7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\u00A8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\u00A8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\u00C9","eacute":"\u00E9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\u00CA","ecirc":"\u00EA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\u00C8","egrave":"\u00E8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\u00BD","frac13":"\u2153","frac14":"\u00BC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\u00BE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\u00BD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\u00CD","iacute":"\u00ED","ic":"\u2063","Icirc":"\u00CE","icirc":"\u00EE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\u00A1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\u00CC","igrave":"\u00EC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\u00BF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\u00CF","iuml":"\u00EF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\u00AB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\u00AF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\u00B5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\u00B7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\u00A0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\u00A0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\u00AC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\u00D1","ntilde":"\u00F1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\u00D3","oacute":"\u00F3","oast":"\u229B","Ocirc":"\u00D4","ocirc":"\u00F4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\u00D2","ograve":"\u00F2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\u00AA","ordm":"\u00BA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\u00D8","oslash":"\u00F8","osol":"\u2298","Otilde":"\u00D5","otilde":"\u00F5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\u00D6","ouml":"\u00F6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\u00B6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\u00B1","plusmn":"\u00B1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\u00B1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\u00A3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\u00BB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\u00AE","REG":"\u00AE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\u00A7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\u00AD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\u00AF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\u00DF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\u00DE","thorn":"\u00FE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\u00D7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\u00DA","uacute":"\u00FA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\u00DB","ucirc":"\u00FB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\u00D9","ugrave":"\u00F9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\u00A8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\u00DC","uuml":"\u00FC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\u00DD","yacute":"\u00FD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\u00A5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\u00FF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"}
},{}],65:[function(require,module,exports){
    module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","AElig":"\u00C6","aelig":"\u00E6","Agrave":"\u00C0","agrave":"\u00E0","amp":"&","AMP":"&","Aring":"\u00C5","aring":"\u00E5","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","brvbar":"\u00A6","Ccedil":"\u00C7","ccedil":"\u00E7","cedil":"\u00B8","cent":"\u00A2","copy":"\u00A9","COPY":"\u00A9","curren":"\u00A4","deg":"\u00B0","divide":"\u00F7","Eacute":"\u00C9","eacute":"\u00E9","Ecirc":"\u00CA","ecirc":"\u00EA","Egrave":"\u00C8","egrave":"\u00E8","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","frac12":"\u00BD","frac14":"\u00BC","frac34":"\u00BE","gt":">","GT":">","Iacute":"\u00CD","iacute":"\u00ED","Icirc":"\u00CE","icirc":"\u00EE","iexcl":"\u00A1","Igrave":"\u00CC","igrave":"\u00EC","iquest":"\u00BF","Iuml":"\u00CF","iuml":"\u00EF","laquo":"\u00AB","lt":"<","LT":"<","macr":"\u00AF","micro":"\u00B5","middot":"\u00B7","nbsp":"\u00A0","not":"\u00AC","Ntilde":"\u00D1","ntilde":"\u00F1","Oacute":"\u00D3","oacute":"\u00F3","Ocirc":"\u00D4","ocirc":"\u00F4","Ograve":"\u00D2","ograve":"\u00F2","ordf":"\u00AA","ordm":"\u00BA","Oslash":"\u00D8","oslash":"\u00F8","Otilde":"\u00D5","otilde":"\u00F5","Ouml":"\u00D6","ouml":"\u00F6","para":"\u00B6","plusmn":"\u00B1","pound":"\u00A3","quot":"\"","QUOT":"\"","raquo":"\u00BB","reg":"\u00AE","REG":"\u00AE","sect":"\u00A7","shy":"\u00AD","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","szlig":"\u00DF","THORN":"\u00DE","thorn":"\u00FE","times":"\u00D7","Uacute":"\u00DA","uacute":"\u00FA","Ucirc":"\u00DB","ucirc":"\u00FB","Ugrave":"\u00D9","ugrave":"\u00F9","uml":"\u00A8","Uuml":"\u00DC","uuml":"\u00FC","Yacute":"\u00DD","yacute":"\u00FD","yen":"\u00A5","yuml":"\u00FF"}
},{}],66:[function(require,module,exports){
    module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

},{}],67:[function(require,module,exports){
    module.exports = CollectingHandler;

    function CollectingHandler(cbs){
        this._cbs = cbs || {};
        this.events = [];
    }

    var EVENTS = require("./").EVENTS;
    Object.keys(EVENTS).forEach(function(name){
        if(EVENTS[name] === 0){
            name = "on" + name;
            CollectingHandler.prototype[name] = function(){
                this.events.push([name]);
                if(this._cbs[name]) this._cbs[name]();
            };
        } else if(EVENTS[name] === 1){
            name = "on" + name;
            CollectingHandler.prototype[name] = function(a){
                this.events.push([name, a]);
                if(this._cbs[name]) this._cbs[name](a);
            };
        } else if(EVENTS[name] === 2){
            name = "on" + name;
            CollectingHandler.prototype[name] = function(a, b){
                this.events.push([name, a, b]);
                if(this._cbs[name]) this._cbs[name](a, b);
            };
        } else {
            throw Error("wrong number of arguments");
        }
    });

    CollectingHandler.prototype.onreset = function(){
        this.events = [];
        if(this._cbs.onreset) this._cbs.onreset();
    };

    CollectingHandler.prototype.restart = function(){
        if(this._cbs.onreset) this._cbs.onreset();

        for(var i = 0, len = this.events.length; i < len; i++){
            if(this._cbs[this.events[i][0]]){

                var num = this.events[i].length;

                if(num === 1){
                    this._cbs[this.events[i][0]]();
                } else if(num === 2){
                    this._cbs[this.events[i][0]](this.events[i][1]);
                } else {
                    this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
                }
            }
        }
    };

},{"./":74}],68:[function(require,module,exports){
    var index = require("./index.js"),
        DomHandler = index.DomHandler,
        DomUtils = index.DomUtils;

//TODO: make this a streamable handler
    function FeedHandler(callback, options){
        this.init(callback, options);
    }

    require("util").inherits(FeedHandler, DomHandler);

    FeedHandler.prototype.init = DomHandler;

    function getElements(what, where){
        return DomUtils.getElementsByTagName(what, where, true);
    }
    function getOneElement(what, where){
        return DomUtils.getElementsByTagName(what, where, true, 1)[0];
    }
    function fetch(what, where, recurse){
        return DomUtils.getText(
            DomUtils.getElementsByTagName(what, where, recurse, 1)
        ).trim();
    }

    function addConditionally(obj, prop, what, where, recurse){
        var tmp = fetch(what, where, recurse);
        if(tmp) obj[prop] = tmp;
    }

    var isValidFeed = function(value){
        return value === "rss" || value === "feed" || value === "rdf:RDF";
    };

    FeedHandler.prototype.onend = function(){
        var feed = {},
            feedRoot = getOneElement(isValidFeed, this.dom),
            tmp, childs;

        if(feedRoot){
            if(feedRoot.name === "feed"){
                childs = feedRoot.children;

                feed.type = "atom";
                addConditionally(feed, "id", "id", childs);
                addConditionally(feed, "title", "title", childs);
                if((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
                addConditionally(feed, "description", "subtitle", childs);
                if((tmp = fetch("updated", childs))) feed.updated = new Date(tmp);
                addConditionally(feed, "author", "email", childs, true);

                feed.items = getElements("entry", childs).map(function(item){
                    var entry = {}, tmp;

                    item = item.children;

                    addConditionally(entry, "id", "id", item);
                    addConditionally(entry, "title", "title", item);
                    if((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
                    if((tmp = fetch("summary", item) || fetch("content", item))) entry.description = tmp;
                    if((tmp = fetch("updated", item))) entry.pubDate = new Date(tmp);
                    return entry;
                });
            } else {
                childs = getOneElement("channel", feedRoot.children).children;

                feed.type = feedRoot.name.substr(0, 3);
                feed.id = "";
                addConditionally(feed, "title", "title", childs);
                addConditionally(feed, "link", "link", childs);
                addConditionally(feed, "description", "description", childs);
                if((tmp = fetch("lastBuildDate", childs))) feed.updated = new Date(tmp);
                addConditionally(feed, "author", "managingEditor", childs, true);

                feed.items = getElements("item", feedRoot.children).map(function(item){
                    var entry = {}, tmp;

                    item = item.children;

                    addConditionally(entry, "id", "guid", item);
                    addConditionally(entry, "title", "title", item);
                    addConditionally(entry, "link", "link", item);
                    addConditionally(entry, "description", "description", item);
                    if((tmp = fetch("pubDate", item))) entry.pubDate = new Date(tmp);
                    return entry;
                });
            }
        }
        this.dom = feed;
        DomHandler.prototype._handleCallback.call(
            this, feedRoot ? null : Error("couldn't find root of feed")
        );
    };

    module.exports = FeedHandler;

},{"./index.js":74,"util":113}],69:[function(require,module,exports){
    var Tokenizer = require("./Tokenizer.js");

    /*
     Options:

     xmlMode: Disables the special behavior for script/style tags (false by default)
     lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
     lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
     */

    /*
     Callbacks:

     oncdataend,
     oncdatastart,
     onclosetag,
     oncomment,
     oncommentend,
     onerror,
     onopentag,
     onprocessinginstruction,
     onreset,
     ontext
     */

    var formTags = {
        input: true,
        option: true,
        optgroup: true,
        select: true,
        button: true,
        datalist: true,
        textarea: true
    };

    var openImpliesClose = {
        tr      : { tr:true, th:true, td:true },
        th      : { th:true },
        td      : { thead:true, th:true, td:true },
        body    : { head:true, link:true, script:true },
        li      : { li:true },
        p       : { p:true },
        h1      : { p:true },
        h2      : { p:true },
        h3      : { p:true },
        h4      : { p:true },
        h5      : { p:true },
        h6      : { p:true },
        select  : formTags,
        input   : formTags,
        output  : formTags,
        button  : formTags,
        datalist: formTags,
        textarea: formTags,
        option  : { option:true },
        optgroup: { optgroup:true }
    };

    var voidElements = {
        __proto__: null,
        area: true,
        base: true,
        basefont: true,
        br: true,
        col: true,
        command: true,
        embed: true,
        frame: true,
        hr: true,
        img: true,
        input: true,
        isindex: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true,

        //common self closing svg elements
        path: true,
        circle: true,
        ellipse: true,
        line: true,
        rect: true,
        use: true,
        stop: true,
        polyline: true,
        polygon: true
    };

    var re_nameEnd = /\s|\//;

    function Parser(cbs, options){
        this._options = options || {};
        this._cbs = cbs || {};

        this._tagname = "";
        this._attribname = "";
        this._attribvalue = "";
        this._attribs = null;
        this._stack = [];

        this.startIndex = 0;
        this.endIndex = null;

        this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
            !!this._options.lowerCaseTags :
            !this._options.xmlMode;
        this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
            !!this._options.lowerCaseAttributeNames :
            !this._options.xmlMode;

        this._tokenizer = new Tokenizer(this._options, this);

        if(this._cbs.onparserinit) this._cbs.onparserinit(this);
    }

    require("util").inherits(Parser, require("events").EventEmitter);

    Parser.prototype._updatePosition = function(initialOffset){
        if(this.endIndex === null){
            if(this._tokenizer._sectionStart <= initialOffset){
                this.startIndex = 0;
            } else {
                this.startIndex = this._tokenizer._sectionStart - initialOffset;
            }
        }
        else this.startIndex = this.endIndex + 1;
        this.endIndex = this._tokenizer.getAbsoluteIndex();
    };

//Tokenizer event handlers
    Parser.prototype.ontext = function(data){
        this._updatePosition(1);
        this.endIndex--;

        if(this._cbs.ontext) this._cbs.ontext(data);
    };

    Parser.prototype.onopentagname = function(name){
        if(this._lowerCaseTagNames){
            name = name.toLowerCase();
        }

        this._tagname = name;

        if(!this._options.xmlMode && name in openImpliesClose) {
            for(
                var el;
                (el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
                this.onclosetag(el)
            );
        }

        if(this._options.xmlMode || !(name in voidElements)){
            this._stack.push(name);
        }

        if(this._cbs.onopentagname) this._cbs.onopentagname(name);
        if(this._cbs.onopentag) this._attribs = {};
    };

    Parser.prototype.onopentagend = function(){
        this._updatePosition(1);

        if(this._attribs){
            if(this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
            this._attribs = null;
        }

        if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
            this._cbs.onclosetag(this._tagname);
        }

        this._tagname = "";
    };

    Parser.prototype.onclosetag = function(name){
        this._updatePosition(1);

        if(this._lowerCaseTagNames){
            name = name.toLowerCase();
        }

        if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
            var pos = this._stack.lastIndexOf(name);
            if(pos !== -1){
                if(this._cbs.onclosetag){
                    pos = this._stack.length - pos;
                    while(pos--) this._cbs.onclosetag(this._stack.pop());
                }
                else this._stack.length = pos;
            } else if(name === "p" && !this._options.xmlMode){
                this.onopentagname(name);
                this._closeCurrentTag();
            }
        } else if(!this._options.xmlMode && (name === "br" || name === "p")){
            this.onopentagname(name);
            this._closeCurrentTag();
        }
    };

    Parser.prototype.onselfclosingtag = function(){
        if(this._options.xmlMode || this._options.recognizeSelfClosing){
            this._closeCurrentTag();
        } else {
            this.onopentagend();
        }
    };

    Parser.prototype._closeCurrentTag = function(){
        var name = this._tagname;

        this.onopentagend();

        //self-closing tags will be on the top of the stack
        //(cheaper check than in onclosetag)
        if(this._stack[this._stack.length - 1] === name){
            if(this._cbs.onclosetag){
                this._cbs.onclosetag(name);
            }
            this._stack.pop();
        }
    };

    Parser.prototype.onattribname = function(name){
        if(this._lowerCaseAttributeNames){
            name = name.toLowerCase();
        }
        this._attribname = name;
    };

    Parser.prototype.onattribdata = function(value){
        this._attribvalue += value;
    };

    Parser.prototype.onattribend = function(){
        if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
        if(
            this._attribs &&
            !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
        ){
            this._attribs[this._attribname] = this._attribvalue;
        }
        this._attribname = "";
        this._attribvalue = "";
    };

    Parser.prototype._getInstructionName = function(value){
        var idx = value.search(re_nameEnd),
            name = idx < 0 ? value : value.substr(0, idx);

        if(this._lowerCaseTagNames){
            name = name.toLowerCase();
        }

        return name;
    };

    Parser.prototype.ondeclaration = function(value){
        if(this._cbs.onprocessinginstruction){
            var name = this._getInstructionName(value);
            this._cbs.onprocessinginstruction("!" + name, "!" + value);
        }
    };

    Parser.prototype.onprocessinginstruction = function(value){
        if(this._cbs.onprocessinginstruction){
            var name = this._getInstructionName(value);
            this._cbs.onprocessinginstruction("?" + name, "?" + value);
        }
    };

    Parser.prototype.oncomment = function(value){
        this._updatePosition(4);

        if(this._cbs.oncomment) this._cbs.oncomment(value);
        if(this._cbs.oncommentend) this._cbs.oncommentend();
    };

    Parser.prototype.oncdata = function(value){
        this._updatePosition(1);

        if(this._options.xmlMode || this._options.recognizeCDATA){
            if(this._cbs.oncdatastart) this._cbs.oncdatastart();
            if(this._cbs.ontext) this._cbs.ontext(value);
            if(this._cbs.oncdataend) this._cbs.oncdataend();
        } else {
            this.oncomment("[CDATA[" + value + "]]");
        }
    };

    Parser.prototype.onerror = function(err){
        if(this._cbs.onerror) this._cbs.onerror(err);
    };

    Parser.prototype.onend = function(){
        if(this._cbs.onclosetag){
            for(
                var i = this._stack.length;
                i > 0;
                this._cbs.onclosetag(this._stack[--i])
            );
        }
        if(this._cbs.onend) this._cbs.onend();
    };


//Resets the parser to a blank state, ready to parse a new HTML document
    Parser.prototype.reset = function(){
        if(this._cbs.onreset) this._cbs.onreset();
        this._tokenizer.reset();

        this._tagname = "";
        this._attribname = "";
        this._attribs = null;
        this._stack = [];

        if(this._cbs.onparserinit) this._cbs.onparserinit(this);
    };

//Parses a complete HTML document and pushes it to the handler
    Parser.prototype.parseComplete = function(data){
        this.reset();
        this.end(data);
    };

    Parser.prototype.write = function(chunk){
        this._tokenizer.write(chunk);
    };

    Parser.prototype.end = function(chunk){
        this._tokenizer.end(chunk);
    };

    Parser.prototype.pause = function(){
        this._tokenizer.pause();
    };

    Parser.prototype.resume = function(){
        this._tokenizer.resume();
    };

//alias for backwards compat
    Parser.prototype.parseChunk = Parser.prototype.write;
    Parser.prototype.done = Parser.prototype.end;

    module.exports = Parser;

},{"./Tokenizer.js":72,"events":92,"util":113}],70:[function(require,module,exports){
    module.exports = ProxyHandler;

    function ProxyHandler(cbs){
        this._cbs = cbs || {};
    }

    var EVENTS = require("./").EVENTS;
    Object.keys(EVENTS).forEach(function(name){
        if(EVENTS[name] === 0){
            name = "on" + name;
            ProxyHandler.prototype[name] = function(){
                if(this._cbs[name]) this._cbs[name]();
            };
        } else if(EVENTS[name] === 1){
            name = "on" + name;
            ProxyHandler.prototype[name] = function(a){
                if(this._cbs[name]) this._cbs[name](a);
            };
        } else if(EVENTS[name] === 2){
            name = "on" + name;
            ProxyHandler.prototype[name] = function(a, b){
                if(this._cbs[name]) this._cbs[name](a, b);
            };
        } else {
            throw Error("wrong number of arguments");
        }
    });
},{"./":74}],71:[function(require,module,exports){
    module.exports = Stream;

    var Parser = require("./WritableStream.js");

    function Stream(options){
        Parser.call(this, new Cbs(this), options);
    }

    require("util").inherits(Stream, Parser);

    Stream.prototype.readable = true;

    function Cbs(scope){
        this.scope = scope;
    }

    var EVENTS = require("../").EVENTS;

    Object.keys(EVENTS).forEach(function(name){
        if(EVENTS[name] === 0){
            Cbs.prototype["on" + name] = function(){
                this.scope.emit(name);
            };
        } else if(EVENTS[name] === 1){
            Cbs.prototype["on" + name] = function(a){
                this.scope.emit(name, a);
            };
        } else if(EVENTS[name] === 2){
            Cbs.prototype["on" + name] = function(a, b){
                this.scope.emit(name, a, b);
            };
        } else {
            throw Error("wrong number of arguments!");
        }
    });
},{"../":74,"./WritableStream.js":73,"util":113}],72:[function(require,module,exports){
    module.exports = Tokenizer;

    var decodeCodePoint = require("entities/lib/decode_codepoint.js"),
        entityMap = require("entities/maps/entities.json"),
        legacyMap = require("entities/maps/legacy.json"),
        xmlMap    = require("entities/maps/xml.json"),

        i = 0,

        TEXT                      = i++,
        BEFORE_TAG_NAME           = i++, //after <
        IN_TAG_NAME               = i++,
        IN_SELF_CLOSING_TAG       = i++,
        BEFORE_CLOSING_TAG_NAME   = i++,
        IN_CLOSING_TAG_NAME       = i++,
        AFTER_CLOSING_TAG_NAME    = i++,

    //attributes
        BEFORE_ATTRIBUTE_NAME     = i++,
        IN_ATTRIBUTE_NAME         = i++,
        AFTER_ATTRIBUTE_NAME      = i++,
        BEFORE_ATTRIBUTE_VALUE    = i++,
        IN_ATTRIBUTE_VALUE_DQ     = i++, // "
        IN_ATTRIBUTE_VALUE_SQ     = i++, // '
        IN_ATTRIBUTE_VALUE_NQ     = i++,

    //declarations
        BEFORE_DECLARATION        = i++, // !
        IN_DECLARATION            = i++,

    //processing instructions
        IN_PROCESSING_INSTRUCTION = i++, // ?

    //comments
        BEFORE_COMMENT            = i++,
        IN_COMMENT                = i++,
        AFTER_COMMENT_1           = i++,
        AFTER_COMMENT_2           = i++,

    //cdata
        BEFORE_CDATA_1            = i++, // [
        BEFORE_CDATA_2            = i++, // C
        BEFORE_CDATA_3            = i++, // D
        BEFORE_CDATA_4            = i++, // A
        BEFORE_CDATA_5            = i++, // T
        BEFORE_CDATA_6            = i++, // A
        IN_CDATA                  = i++, // [
        AFTER_CDATA_1             = i++, // ]
        AFTER_CDATA_2             = i++, // ]

    //special tags
        BEFORE_SPECIAL            = i++, //S
        BEFORE_SPECIAL_END        = i++,   //S

        BEFORE_SCRIPT_1           = i++, //C
        BEFORE_SCRIPT_2           = i++, //R
        BEFORE_SCRIPT_3           = i++, //I
        BEFORE_SCRIPT_4           = i++, //P
        BEFORE_SCRIPT_5           = i++, //T
        AFTER_SCRIPT_1            = i++, //C
        AFTER_SCRIPT_2            = i++, //R
        AFTER_SCRIPT_3            = i++, //I
        AFTER_SCRIPT_4            = i++, //P
        AFTER_SCRIPT_5            = i++, //T

        BEFORE_STYLE_1            = i++, //T
        BEFORE_STYLE_2            = i++, //Y
        BEFORE_STYLE_3            = i++, //L
        BEFORE_STYLE_4            = i++, //E
        AFTER_STYLE_1             = i++, //T
        AFTER_STYLE_2             = i++, //Y
        AFTER_STYLE_3             = i++, //L
        AFTER_STYLE_4             = i++, //E

        BEFORE_ENTITY             = i++, //&
        BEFORE_NUMERIC_ENTITY     = i++, //#
        IN_NAMED_ENTITY           = i++,
        IN_NUMERIC_ENTITY         = i++,
        IN_HEX_ENTITY             = i++, //X

        j = 0,

        SPECIAL_NONE              = j++,
        SPECIAL_SCRIPT            = j++,
        SPECIAL_STYLE             = j++;

    function whitespace(c){
        return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
    }

    function characterState(char, SUCCESS){
        return function(c){
            if(c === char) this._state = SUCCESS;
        };
    }

    function ifElseState(upper, SUCCESS, FAILURE){
        var lower = upper.toLowerCase();

        if(upper === lower){
            return function(c){
                if(c === lower){
                    this._state = SUCCESS;
                } else {
                    this._state = FAILURE;
                    this._index--;
                }
            };
        } else {
            return function(c){
                if(c === lower || c === upper){
                    this._state = SUCCESS;
                } else {
                    this._state = FAILURE;
                    this._index--;
                }
            };
        }
    }

    function consumeSpecialNameChar(upper, NEXT_STATE){
        var lower = upper.toLowerCase();

        return function(c){
            if(c === lower || c === upper){
                this._state = NEXT_STATE;
            } else {
                this._state = IN_TAG_NAME;
                this._index--; //consume the token again
            }
        };
    }

    function Tokenizer(options, cbs){
        this._state = TEXT;
        this._buffer = "";
        this._sectionStart = 0;
        this._index = 0;
        this._bufferOffset = 0; //chars removed from _buffer
        this._baseState = TEXT;
        this._special = SPECIAL_NONE;
        this._cbs = cbs;
        this._running = true;
        this._ended = false;
        this._xmlMode = !!(options && options.xmlMode);
        this._decodeEntities = !!(options && options.decodeEntities);
    }

    Tokenizer.prototype._stateText = function(c){
        if(c === "<"){
            if(this._index > this._sectionStart){
                this._cbs.ontext(this._getSection());
            }
            this._state = BEFORE_TAG_NAME;
            this._sectionStart = this._index;
        } else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
            if(this._index > this._sectionStart){
                this._cbs.ontext(this._getSection());
            }
            this._baseState = TEXT;
            this._state = BEFORE_ENTITY;
            this._sectionStart = this._index;
        }
    };

    Tokenizer.prototype._stateBeforeTagName = function(c){
        if(c === "/"){
            this._state = BEFORE_CLOSING_TAG_NAME;
        } else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
            this._state = TEXT;
        } else if(c === "!"){
            this._state = BEFORE_DECLARATION;
            this._sectionStart = this._index + 1;
        } else if(c === "?"){
            this._state = IN_PROCESSING_INSTRUCTION;
            this._sectionStart = this._index + 1;
        } else if(c === "<"){
            this._cbs.ontext(this._getSection());
            this._sectionStart = this._index;
        } else {
            this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
                BEFORE_SPECIAL : IN_TAG_NAME;
            this._sectionStart = this._index;
        }
    };

    Tokenizer.prototype._stateInTagName = function(c){
        if(c === "/" || c === ">" || whitespace(c)){
            this._emitToken("onopentagname");
            this._state = BEFORE_ATTRIBUTE_NAME;
            this._index--;
        }
    };

    Tokenizer.prototype._stateBeforeCloseingTagName = function(c){
        if(whitespace(c));
        else if(c === ">"){
            this._state = TEXT;
        } else if(this._special !== SPECIAL_NONE){
            if(c === "s" || c === "S"){
                this._state = BEFORE_SPECIAL_END;
            } else {
                this._state = TEXT;
                this._index--;
            }
        } else {
            this._state = IN_CLOSING_TAG_NAME;
            this._sectionStart = this._index;
        }
    };

    Tokenizer.prototype._stateInCloseingTagName = function(c){
        if(c === ">" || whitespace(c)){
            this._emitToken("onclosetag");
            this._state = AFTER_CLOSING_TAG_NAME;
            this._index--;
        }
    };

    Tokenizer.prototype._stateAfterCloseingTagName = function(c){
        //skip everything until ">"
        if(c === ">"){
            this._state = TEXT;
            this._sectionStart = this._index + 1;
        }
    };

    Tokenizer.prototype._stateBeforeAttributeName = function(c){
        if(c === ">"){
            this._cbs.onopentagend();
            this._state = TEXT;
            this._sectionStart = this._index + 1;
        } else if(c === "/"){
            this._state = IN_SELF_CLOSING_TAG;
        } else if(!whitespace(c)){
            this._state = IN_ATTRIBUTE_NAME;
            this._sectionStart = this._index;
        }
    };

    Tokenizer.prototype._stateInSelfClosingTag = function(c){
        if(c === ">"){
            this._cbs.onselfclosingtag();
            this._state = TEXT;
            this._sectionStart = this._index + 1;
        } else if(!whitespace(c)){
            this._state = BEFORE_ATTRIBUTE_NAME;
            this._index--;
        }
    };

    Tokenizer.prototype._stateInAttributeName = function(c){
        if(c === "=" || c === "/" || c === ">" || whitespace(c)){
            this._cbs.onattribname(this._getSection());
            this._sectionStart = -1;
            this._state = AFTER_ATTRIBUTE_NAME;
            this._index--;
        }
    };

    Tokenizer.prototype._stateAfterAttributeName = function(c){
        if(c === "="){
            this._state = BEFORE_ATTRIBUTE_VALUE;
        } else if(c === "/" || c === ">"){
            this._cbs.onattribend();
            this._state = BEFORE_ATTRIBUTE_NAME;
            this._index--;
        } else if(!whitespace(c)){
            this._cbs.onattribend();
            this._state = IN_ATTRIBUTE_NAME;
            this._sectionStart = this._index;
        }
    };

    Tokenizer.prototype._stateBeforeAttributeValue = function(c){
        if(c === "\""){
            this._state = IN_ATTRIBUTE_VALUE_DQ;
            this._sectionStart = this._index + 1;
        } else if(c === "'"){
            this._state = IN_ATTRIBUTE_VALUE_SQ;
            this._sectionStart = this._index + 1;
        } else if(!whitespace(c)){
            this._state = IN_ATTRIBUTE_VALUE_NQ;
            this._sectionStart = this._index;
            this._index--; //reconsume token
        }
    };

    Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c){
        if(c === "\""){
            this._emitToken("onattribdata");
            this._cbs.onattribend();
            this._state = BEFORE_ATTRIBUTE_NAME;
        } else if(this._decodeEntities && c === "&"){
            this._emitToken("onattribdata");
            this._baseState = this._state;
            this._state = BEFORE_ENTITY;
            this._sectionStart = this._index;
        }
    };

    Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c){
        if(c === "'"){
            this._emitToken("onattribdata");
            this._cbs.onattribend();
            this._state = BEFORE_ATTRIBUTE_NAME;
        } else if(this._decodeEntities && c === "&"){
            this._emitToken("onattribdata");
            this._baseState = this._state;
            this._state = BEFORE_ENTITY;
            this._sectionStart = this._index;
        }
    };

    Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c){
        if(whitespace(c) || c === ">"){
            this._emitToken("onattribdata");
            this._cbs.onattribend();
            this._state = BEFORE_ATTRIBUTE_NAME;
            this._index--;
        } else if(this._decodeEntities && c === "&"){
            this._emitToken("onattribdata");
            this._baseState = this._state;
            this._state = BEFORE_ENTITY;
            this._sectionStart = this._index;
        }
    };

    Tokenizer.prototype._stateBeforeDeclaration = function(c){
        this._state = c === "[" ? BEFORE_CDATA_1 :
            c === "-" ? BEFORE_COMMENT :
                IN_DECLARATION;
    };

    Tokenizer.prototype._stateInDeclaration = function(c){
        if(c === ">"){
            this._cbs.ondeclaration(this._getSection());
            this._state = TEXT;
            this._sectionStart = this._index + 1;
        }
    };

    Tokenizer.prototype._stateInProcessingInstruction = function(c){
        if(c === ">"){
            this._cbs.onprocessinginstruction(this._getSection());
            this._state = TEXT;
            this._sectionStart = this._index + 1;
        }
    };

    Tokenizer.prototype._stateBeforeComment = function(c){
        if(c === "-"){
            this._state = IN_COMMENT;
            this._sectionStart = this._index + 1;
        } else {
            this._state = IN_DECLARATION;
        }
    };

    Tokenizer.prototype._stateInComment = function(c){
        if(c === "-") this._state = AFTER_COMMENT_1;
    };

    Tokenizer.prototype._stateAfterComment1 = function(c){
        if(c === "-"){
            this._state = AFTER_COMMENT_2;
        } else {
            this._state = IN_COMMENT;
        }
    };

    Tokenizer.prototype._stateAfterComment2 = function(c){
        if(c === ">"){
            //remove 2 trailing chars
            this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
            this._state = TEXT;
            this._sectionStart = this._index + 1;
        } else if(c !== "-"){
            this._state = IN_COMMENT;
        }
        // else: stay in AFTER_COMMENT_2 (`--->`)
    };

    Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
    Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

    Tokenizer.prototype._stateBeforeCdata6 = function(c){
        if(c === "["){
            this._state = IN_CDATA;
            this._sectionStart = this._index + 1;
        } else {
            this._state = IN_DECLARATION;
            this._index--;
        }
    };

    Tokenizer.prototype._stateInCdata = function(c){
        if(c === "]") this._state = AFTER_CDATA_1;
    };

    Tokenizer.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2);

    Tokenizer.prototype._stateAfterCdata2 = function(c){
        if(c === ">"){
            //remove 2 trailing chars
            this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
            this._state = TEXT;
            this._sectionStart = this._index + 1;
        } else if(c !== "]") {
            this._state = IN_CDATA;
        }
        //else: stay in AFTER_CDATA_2 (`]]]>`)
    };

    Tokenizer.prototype._stateBeforeSpecial = function(c){
        if(c === "c" || c === "C"){
            this._state = BEFORE_SCRIPT_1;
        } else if(c === "t" || c === "T"){
            this._state = BEFORE_STYLE_1;
        } else {
            this._state = IN_TAG_NAME;
            this._index--; //consume the token again
        }
    };

    Tokenizer.prototype._stateBeforeSpecialEnd = function(c){
        if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
            this._state = AFTER_SCRIPT_1;
        } else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
            this._state = AFTER_STYLE_1;
        }
        else this._state = TEXT;
    };

    Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
    Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
    Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
    Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

    Tokenizer.prototype._stateBeforeScript5 = function(c){
        if(c === "/" || c === ">" || whitespace(c)){
            this._special = SPECIAL_SCRIPT;
        }
        this._state = IN_TAG_NAME;
        this._index--; //consume the token again
    };

    Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
    Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
    Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
    Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

    Tokenizer.prototype._stateAfterScript5 = function(c){
        if(c === ">" || whitespace(c)){
            this._special = SPECIAL_NONE;
            this._state = IN_CLOSING_TAG_NAME;
            this._sectionStart = this._index - 6;
            this._index--; //reconsume the token
        }
        else this._state = TEXT;
    };

    Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
    Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
    Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

    Tokenizer.prototype._stateBeforeStyle4 = function(c){
        if(c === "/" || c === ">" || whitespace(c)){
            this._special = SPECIAL_STYLE;
        }
        this._state = IN_TAG_NAME;
        this._index--; //consume the token again
    };

    Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
    Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
    Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

    Tokenizer.prototype._stateAfterStyle4 = function(c){
        if(c === ">" || whitespace(c)){
            this._special = SPECIAL_NONE;
            this._state = IN_CLOSING_TAG_NAME;
            this._sectionStart = this._index - 5;
            this._index--; //reconsume the token
        }
        else this._state = TEXT;
    };

    Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
    Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
    Tokenizer.prototype._parseNamedEntityStrict = function(){
        //offset = 1
        if(this._sectionStart + 1 < this._index){
            var entity = this._buffer.substring(this._sectionStart + 1, this._index),
                map = this._xmlMode ? xmlMap : entityMap;

            if(map.hasOwnProperty(entity)){
                this._emitPartial(map[entity]);
                this._sectionStart = this._index + 1;
            }
        }
    };


//parses legacy entities (without trailing semicolon)
    Tokenizer.prototype._parseLegacyEntity = function(){
        var start = this._sectionStart + 1,
            limit = this._index - start;

        if(limit > 6) limit = 6; //the max length of legacy entities is 6

        while(limit >= 2){ //the min length of legacy entities is 2
            var entity = this._buffer.substr(start, limit);

            if(legacyMap.hasOwnProperty(entity)){
                this._emitPartial(legacyMap[entity]);
                this._sectionStart += limit + 1;
                return;
            } else {
                limit--;
            }
        }
    };

    Tokenizer.prototype._stateInNamedEntity = function(c){
        if(c === ";"){
            this._parseNamedEntityStrict();
            if(this._sectionStart + 1 < this._index && !this._xmlMode){
                this._parseLegacyEntity();
            }
            this._state = this._baseState;
        } else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
            if(this._xmlMode);
            else if(this._sectionStart + 1 === this._index);
            else if(this._baseState !== TEXT){
                if(c !== "="){
                    this._parseNamedEntityStrict();
                }
            } else {
                this._parseLegacyEntity();
            }

            this._state = this._baseState;
            this._index--;
        }
    };

    Tokenizer.prototype._decodeNumericEntity = function(offset, base){
        var sectionStart = this._sectionStart + offset;

        if(sectionStart !== this._index){
            //parse entity
            var entity = this._buffer.substring(sectionStart, this._index);
            var parsed = parseInt(entity, base);

            this._emitPartial(decodeCodePoint(parsed));
            this._sectionStart = this._index;
        } else {
            this._sectionStart--;
        }

        this._state = this._baseState;
    };

    Tokenizer.prototype._stateInNumericEntity = function(c){
        if(c === ";"){
            this._decodeNumericEntity(2, 10);
            this._sectionStart++;
        } else if(c < "0" || c > "9"){
            if(!this._xmlMode){
                this._decodeNumericEntity(2, 10);
            } else {
                this._state = this._baseState;
            }
            this._index--;
        }
    };

    Tokenizer.prototype._stateInHexEntity = function(c){
        if(c === ";"){
            this._decodeNumericEntity(3, 16);
            this._sectionStart++;
        } else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
            if(!this._xmlMode){
                this._decodeNumericEntity(3, 16);
            } else {
                this._state = this._baseState;
            }
            this._index--;
        }
    };

    Tokenizer.prototype._cleanup = function (){
        if(this._sectionStart < 0){
            this._buffer = "";
            this._index = 0;
            this._bufferOffset += this._index;
        } else if(this._running){
            if(this._state === TEXT){
                if(this._sectionStart !== this._index){
                    this._cbs.ontext(this._buffer.substr(this._sectionStart));
                }
                this._buffer = "";
                this._index = 0;
                this._bufferOffset += this._index;
            } else if(this._sectionStart === this._index){
                //the section just started
                this._buffer = "";
                this._index = 0;
                this._bufferOffset += this._index;
            } else {
                //remove everything unnecessary
                this._buffer = this._buffer.substr(this._sectionStart);
                this._index -= this._sectionStart;
                this._bufferOffset += this._sectionStart;
            }

            this._sectionStart = 0;
        }
    };

//TODO make events conditional
    Tokenizer.prototype.write = function(chunk){
        if(this._ended) this._cbs.onerror(Error(".write() after done!"));

        this._buffer += chunk;
        this._parse();
    };

    Tokenizer.prototype._parse = function(){
        while(this._index < this._buffer.length && this._running){
            var c = this._buffer.charAt(this._index);
            if(this._state === TEXT) {
                this._stateText(c);
            } else if(this._state === BEFORE_TAG_NAME){
                this._stateBeforeTagName(c);
            } else if(this._state === IN_TAG_NAME) {
                this._stateInTagName(c);
            } else if(this._state === BEFORE_CLOSING_TAG_NAME){
                this._stateBeforeCloseingTagName(c);
            } else if(this._state === IN_CLOSING_TAG_NAME){
                this._stateInCloseingTagName(c);
            } else if(this._state === AFTER_CLOSING_TAG_NAME){
                this._stateAfterCloseingTagName(c);
            } else if(this._state === IN_SELF_CLOSING_TAG){
                this._stateInSelfClosingTag(c);
            }

            /*
             *	attributes
             */
            else if(this._state === BEFORE_ATTRIBUTE_NAME){
                this._stateBeforeAttributeName(c);
            } else if(this._state === IN_ATTRIBUTE_NAME){
                this._stateInAttributeName(c);
            } else if(this._state === AFTER_ATTRIBUTE_NAME){
                this._stateAfterAttributeName(c);
            } else if(this._state === BEFORE_ATTRIBUTE_VALUE){
                this._stateBeforeAttributeValue(c);
            } else if(this._state === IN_ATTRIBUTE_VALUE_DQ){
                this._stateInAttributeValueDoubleQuotes(c);
            } else if(this._state === IN_ATTRIBUTE_VALUE_SQ){
                this._stateInAttributeValueSingleQuotes(c);
            } else if(this._state === IN_ATTRIBUTE_VALUE_NQ){
                this._stateInAttributeValueNoQuotes(c);
            }

            /*
             *	declarations
             */
            else if(this._state === BEFORE_DECLARATION){
                this._stateBeforeDeclaration(c);
            } else if(this._state === IN_DECLARATION){
                this._stateInDeclaration(c);
            }

            /*
             *	processing instructions
             */
            else if(this._state === IN_PROCESSING_INSTRUCTION){
                this._stateInProcessingInstruction(c);
            }

            /*
             *	comments
             */
            else if(this._state === BEFORE_COMMENT){
                this._stateBeforeComment(c);
            } else if(this._state === IN_COMMENT){
                this._stateInComment(c);
            } else if(this._state === AFTER_COMMENT_1){
                this._stateAfterComment1(c);
            } else if(this._state === AFTER_COMMENT_2){
                this._stateAfterComment2(c);
            }

            /*
             *	cdata
             */
            else if(this._state === BEFORE_CDATA_1){
                this._stateBeforeCdata1(c);
            } else if(this._state === BEFORE_CDATA_2){
                this._stateBeforeCdata2(c);
            } else if(this._state === BEFORE_CDATA_3){
                this._stateBeforeCdata3(c);
            } else if(this._state === BEFORE_CDATA_4){
                this._stateBeforeCdata4(c);
            } else if(this._state === BEFORE_CDATA_5){
                this._stateBeforeCdata5(c);
            } else if(this._state === BEFORE_CDATA_6){
                this._stateBeforeCdata6(c);
            } else if(this._state === IN_CDATA){
                this._stateInCdata(c);
            } else if(this._state === AFTER_CDATA_1){
                this._stateAfterCdata1(c);
            } else if(this._state === AFTER_CDATA_2){
                this._stateAfterCdata2(c);
            }

            /*
             * special tags
             */
            else if(this._state === BEFORE_SPECIAL){
                this._stateBeforeSpecial(c);
            } else if(this._state === BEFORE_SPECIAL_END){
                this._stateBeforeSpecialEnd(c);
            }

            /*
             * script
             */
            else if(this._state === BEFORE_SCRIPT_1){
                this._stateBeforeScript1(c);
            } else if(this._state === BEFORE_SCRIPT_2){
                this._stateBeforeScript2(c);
            } else if(this._state === BEFORE_SCRIPT_3){
                this._stateBeforeScript3(c);
            } else if(this._state === BEFORE_SCRIPT_4){
                this._stateBeforeScript4(c);
            } else if(this._state === BEFORE_SCRIPT_5){
                this._stateBeforeScript5(c);
            }

            else if(this._state === AFTER_SCRIPT_1){
                this._stateAfterScript1(c);
            } else if(this._state === AFTER_SCRIPT_2){
                this._stateAfterScript2(c);
            } else if(this._state === AFTER_SCRIPT_3){
                this._stateAfterScript3(c);
            } else if(this._state === AFTER_SCRIPT_4){
                this._stateAfterScript4(c);
            } else if(this._state === AFTER_SCRIPT_5){
                this._stateAfterScript5(c);
            }

            /*
             * style
             */
            else if(this._state === BEFORE_STYLE_1){
                this._stateBeforeStyle1(c);
            } else if(this._state === BEFORE_STYLE_2){
                this._stateBeforeStyle2(c);
            } else if(this._state === BEFORE_STYLE_3){
                this._stateBeforeStyle3(c);
            } else if(this._state === BEFORE_STYLE_4){
                this._stateBeforeStyle4(c);
            }

            else if(this._state === AFTER_STYLE_1){
                this._stateAfterStyle1(c);
            } else if(this._state === AFTER_STYLE_2){
                this._stateAfterStyle2(c);
            } else if(this._state === AFTER_STYLE_3){
                this._stateAfterStyle3(c);
            } else if(this._state === AFTER_STYLE_4){
                this._stateAfterStyle4(c);
            }

            /*
             * entities
             */
            else if(this._state === BEFORE_ENTITY){
                this._stateBeforeEntity(c);
            } else if(this._state === BEFORE_NUMERIC_ENTITY){
                this._stateBeforeNumericEntity(c);
            } else if(this._state === IN_NAMED_ENTITY){
                this._stateInNamedEntity(c);
            } else if(this._state === IN_NUMERIC_ENTITY){
                this._stateInNumericEntity(c);
            } else if(this._state === IN_HEX_ENTITY){
                this._stateInHexEntity(c);
            }

            else {
                this._cbs.onerror(Error("unknown _state"), this._state);
            }

            this._index++;
        }

        this._cleanup();
    };

    Tokenizer.prototype.pause = function(){
        this._running = false;
    };
    Tokenizer.prototype.resume = function(){
        this._running = true;

        if(this._index < this._buffer.length){
            this._parse();
        }
        if(this._ended){
            this._finish();
        }
    };

    Tokenizer.prototype.end = function(chunk){
        if(this._ended) this._cbs.onerror(Error(".end() after done!"));
        if(chunk) this.write(chunk);

        this._ended = true;

        if(this._running) this._finish();
    };

    Tokenizer.prototype._finish = function(){
        //if there is remaining data, emit it in a reasonable way
        if(this._sectionStart < this._index){
            this._handleTrailingData();
        }

        this._cbs.onend();
    };

    Tokenizer.prototype._handleTrailingData = function(){
        var data = this._buffer.substr(this._sectionStart);

        if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
            this._cbs.oncdata(data);
        } else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
            this._cbs.oncomment(data);
        } else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
            this._parseLegacyEntity();
            if(this._sectionStart < this._index){
                this._state = this._baseState;
                this._handleTrailingData();
            }
        } else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
            this._decodeNumericEntity(2, 10);
            if(this._sectionStart < this._index){
                this._state = this._baseState;
                this._handleTrailingData();
            }
        } else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
            this._decodeNumericEntity(3, 16);
            if(this._sectionStart < this._index){
                this._state = this._baseState;
                this._handleTrailingData();
            }
        } else if(
            this._state !== IN_TAG_NAME &&
            this._state !== BEFORE_ATTRIBUTE_NAME &&
            this._state !== BEFORE_ATTRIBUTE_VALUE &&
            this._state !== AFTER_ATTRIBUTE_NAME &&
            this._state !== IN_ATTRIBUTE_NAME &&
            this._state !== IN_ATTRIBUTE_VALUE_SQ &&
            this._state !== IN_ATTRIBUTE_VALUE_DQ &&
            this._state !== IN_ATTRIBUTE_VALUE_NQ &&
            this._state !== IN_CLOSING_TAG_NAME
        ){
            this._cbs.ontext(data);
        }
        //else, ignore remaining data
        //TODO add a way to remove current tag
    };

    Tokenizer.prototype.reset = function(){
        Tokenizer.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
    };

    Tokenizer.prototype.getAbsoluteIndex = function(){
        return this._bufferOffset + this._index;
    };

    Tokenizer.prototype._getSection = function(){
        return this._buffer.substring(this._sectionStart, this._index);
    };

    Tokenizer.prototype._emitToken = function(name){
        this._cbs[name](this._getSection());
        this._sectionStart = -1;
    };

    Tokenizer.prototype._emitPartial = function(value){
        if(this._baseState !== TEXT){
            this._cbs.onattribdata(value); //TODO implement the new event
        } else {
            this._cbs.ontext(value);
        }
    };

},{"entities/lib/decode_codepoint.js":75,"entities/maps/entities.json":77,"entities/maps/legacy.json":78,"entities/maps/xml.json":79}],73:[function(require,module,exports){
    module.exports = Stream;

    var Parser = require("./Parser.js"),
        WritableStream = require("stream").Writable || require("readable-stream").Writable;

    function Stream(cbs, options){
        var parser = this._parser = new Parser(cbs, options);

        WritableStream.call(this, {decodeStrings: false});

        this.once("finish", function(){
            parser.end();
        });
    }

    require("util").inherits(Stream, WritableStream);

    WritableStream.prototype._write = function(chunk, encoding, cb){
        this._parser.write(chunk);
        cb();
    };
},{"./Parser.js":69,"readable-stream":88,"stream":109,"util":113}],74:[function(require,module,exports){
    var Parser = require("./Parser.js"),
        DomHandler = require("domhandler");

    function defineProp(name, value){
        delete module.exports[name];
        module.exports[name] = value;
        return value;
    }

    module.exports = {
        Parser: Parser,
        Tokenizer: require("./Tokenizer.js"),
        ElementType: require("domelementtype"),
        DomHandler: DomHandler,
        get FeedHandler(){
            return defineProp("FeedHandler", require("./FeedHandler.js"));
        },
        get Stream(){
            return defineProp("Stream", require("./Stream.js"));
        },
        get WritableStream(){
            return defineProp("WritableStream", require("./WritableStream.js"));
        },
        get ProxyHandler(){
            return defineProp("ProxyHandler", require("./ProxyHandler.js"));
        },
        get DomUtils(){
            return defineProp("DomUtils", require("domutils"));
        },
        get CollectingHandler(){
            return defineProp("CollectingHandler", require("./CollectingHandler.js"));
        },
        // For legacy support
        DefaultHandler: DomHandler,
        get RssHandler(){
            return defineProp("RssHandler", this.FeedHandler);
        },
        //helper methods
        parseDOM: function(data, options){
            var handler = new DomHandler(options);
            new Parser(handler, options).end(data);
            return handler.dom;
        },
        parseFeed: function(feed, options){
            var handler = new module.exports.FeedHandler(options);
            new Parser(handler, options).end(feed);
            return handler.dom;
        },
        createDomStream: function(cb, options, elementCb){
            var handler = new DomHandler(cb, options, elementCb);
            return new Parser(handler, options);
        },
        // List of all events that the parser emits
        EVENTS: { /* Format: eventname: number of arguments */
            attribute: 2,
            cdatastart: 0,
            cdataend: 0,
            text: 1,
            processinginstruction: 2,
            comment: 1,
            commentend: 0,
            closetag: 1,
            opentag: 2,
            opentagname: 1,
            error: 1,
            end: 0
        }
    };

},{"./CollectingHandler.js":67,"./FeedHandler.js":68,"./Parser.js":69,"./ProxyHandler.js":70,"./Stream.js":71,"./Tokenizer.js":72,"./WritableStream.js":73,"domelementtype":48,"domhandler":49,"domutils":52}],75:[function(require,module,exports){
    arguments[4][61][0].apply(exports,arguments)
},{"../maps/decode.json":76,"dup":61}],76:[function(require,module,exports){
    arguments[4][63][0].apply(exports,arguments)
},{"dup":63}],77:[function(require,module,exports){
    arguments[4][64][0].apply(exports,arguments)
},{"dup":64}],78:[function(require,module,exports){
    arguments[4][65][0].apply(exports,arguments)
},{"dup":65}],79:[function(require,module,exports){
    arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],80:[function(require,module,exports){
    /*
     Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
     (c) 2010-2013, Vladimir Agafonkin
     (c) 2010-2011, CloudMade
     */
    (function (window, document, undefined) {
        var oldL = window.L,
            L = {};

        L.version = '0.7.7';

// define Leaflet for Node module pattern loaders, including Browserify
        if (typeof module === 'object' && typeof module.exports === 'object') {
            module.exports = L;

// define Leaflet as an AMD module
        } else if (typeof define === 'function' && define.amd) {
            define(L);
        }

// define Leaflet as a global L variable, saving the original L to restore later if needed

        L.noConflict = function () {
            window.L = oldL;
            return this;
        };

        window.L = L;


        /*
         * L.Util contains various utility functions used throughout Leaflet code.
         */

        L.Util = {
            extend: function (dest) { // (Object[, Object, ...]) ->
                var sources = Array.prototype.slice.call(arguments, 1),
                    i, j, len, src;

                for (j = 0, len = sources.length; j < len; j++) {
                    src = sources[j] || {};
                    for (i in src) {
                        if (src.hasOwnProperty(i)) {
                            dest[i] = src[i];
                        }
                    }
                }
                return dest;
            },

            bind: function (fn, obj) { // (Function, Object) -> Function
                var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
                return function () {
                    return fn.apply(obj, args || arguments);
                };
            },

            stamp: (function () {
                var lastId = 0,
                    key = '_leaflet_id';
                return function (obj) {
                    obj[key] = obj[key] || ++lastId;
                    return obj[key];
                };
            }()),

            invokeEach: function (obj, method, context) {
                var i, args;

                if (typeof obj === 'object') {
                    args = Array.prototype.slice.call(arguments, 3);

                    for (i in obj) {
                        method.apply(context, [i, obj[i]].concat(args));
                    }
                    return true;
                }

                return false;
            },

            limitExecByInterval: function (fn, time, context) {
                var lock, execOnUnlock;

                return function wrapperFn() {
                    var args = arguments;

                    if (lock) {
                        execOnUnlock = true;
                        return;
                    }

                    lock = true;

                    setTimeout(function () {
                        lock = false;

                        if (execOnUnlock) {
                            wrapperFn.apply(context, args);
                            execOnUnlock = false;
                        }
                    }, time);

                    fn.apply(context, args);
                };
            },

            falseFn: function () {
                return false;
            },

            formatNum: function (num, digits) {
                var pow = Math.pow(10, digits || 5);
                return Math.round(num * pow) / pow;
            },

            trim: function (str) {
                return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
            },

            splitWords: function (str) {
                return L.Util.trim(str).split(/\s+/);
            },

            setOptions: function (obj, options) {
                obj.options = L.extend({}, obj.options, options);
                return obj.options;
            },

            getParamString: function (obj, existingUrl, uppercase) {
                var params = [];
                for (var i in obj) {
                    params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
                }
                return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
            },
            template: function (str, data) {
                return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
                    var value = data[key];
                    if (value === undefined) {
                        throw new Error('No value provided for variable ' + str);
                    } else if (typeof value === 'function') {
                        value = value(data);
                    }
                    return value;
                });
            },

            isArray: Array.isArray || function (obj) {
                return (Object.prototype.toString.call(obj) === '[object Array]');
            },

            emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
        };

        (function () {

            // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

            function getPrefixed(name) {
                var i, fn,
                    prefixes = ['webkit', 'moz', 'o', 'ms'];

                for (i = 0; i < prefixes.length && !fn; i++) {
                    fn = window[prefixes[i] + name];
                }

                return fn;
            }

            var lastTime = 0;

            function timeoutDefer(fn) {
                var time = +new Date(),
                    timeToCall = Math.max(0, 16 - (time - lastTime));

                lastTime = time + timeToCall;
                return window.setTimeout(fn, timeToCall);
            }

            var requestFn = window.requestAnimationFrame ||
                getPrefixed('RequestAnimationFrame') || timeoutDefer;

            var cancelFn = window.cancelAnimationFrame ||
                getPrefixed('CancelAnimationFrame') ||
                getPrefixed('CancelRequestAnimationFrame') ||
                function (id) { window.clearTimeout(id); };


            L.Util.requestAnimFrame = function (fn, context, immediate, element) {
                fn = L.bind(fn, context);

                if (immediate && requestFn === timeoutDefer) {
                    fn();
                } else {
                    return requestFn.call(window, fn, element);
                }
            };

            L.Util.cancelAnimFrame = function (id) {
                if (id) {
                    cancelFn.call(window, id);
                }
            };

        }());

// shortcuts for most used utility functions
        L.extend = L.Util.extend;
        L.bind = L.Util.bind;
        L.stamp = L.Util.stamp;
        L.setOptions = L.Util.setOptions;


        /*
         * L.Class powers the OOP facilities of the library.
         * Thanks to John Resig and Dean Edwards for inspiration!
         */

        L.Class = function () {};

        L.Class.extend = function (props) {

            // extended class with the new prototype
            var NewClass = function () {

                // call the constructor
                if (this.initialize) {
                    this.initialize.apply(this, arguments);
                }

                // call all constructor hooks
                if (this._initHooks) {
                    this.callInitHooks();
                }
            };

            // instantiate class without calling constructor
            var F = function () {};
            F.prototype = this.prototype;

            var proto = new F();
            proto.constructor = NewClass;

            NewClass.prototype = proto;

            //inherit parent's statics
            for (var i in this) {
                if (this.hasOwnProperty(i) && i !== 'prototype') {
                    NewClass[i] = this[i];
                }
            }

            // mix static properties into the class
            if (props.statics) {
                L.extend(NewClass, props.statics);
                delete props.statics;
            }

            // mix includes into the prototype
            if (props.includes) {
                L.Util.extend.apply(null, [proto].concat(props.includes));
                delete props.includes;
            }

            // merge options
            if (props.options && proto.options) {
                props.options = L.extend({}, proto.options, props.options);
            }

            // mix given properties into the prototype
            L.extend(proto, props);

            proto._initHooks = [];

            var parent = this;
            // jshint camelcase: false
            NewClass.__super__ = parent.prototype;

            // add method for calling all hooks
            proto.callInitHooks = function () {

                if (this._initHooksCalled) { return; }

                if (parent.prototype.callInitHooks) {
                    parent.prototype.callInitHooks.call(this);
                }

                this._initHooksCalled = true;

                for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                    proto._initHooks[i].call(this);
                }
            };

            return NewClass;
        };


// method for adding properties to prototype
        L.Class.include = function (props) {
            L.extend(this.prototype, props);
        };

// merge new default options to the Class
        L.Class.mergeOptions = function (options) {
            L.extend(this.prototype.options, options);
        };

// add a constructor hook
        L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
            var args = Array.prototype.slice.call(arguments, 1);

            var init = typeof fn === 'function' ? fn : function () {
                this[fn].apply(this, args);
            };

            this.prototype._initHooks = this.prototype._initHooks || [];
            this.prototype._initHooks.push(init);
        };


        /*
         * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
         */

        var eventsKey = '_leaflet_events';

        L.Mixin = {};

        L.Mixin.Events = {

            addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])

                // types can be a map of types/handlers
                if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }

                var events = this[eventsKey] = this[eventsKey] || {},
                    contextId = context && context !== this && L.stamp(context),
                    i, len, event, type, indexKey, indexLenKey, typeIndex;

                // types can be a string of space-separated words
                types = L.Util.splitWords(types);

                for (i = 0, len = types.length; i < len; i++) {
                    event = {
                        action: fn,
                        context: context || this
                    };
                    type = types[i];

                    if (contextId) {
                        // store listeners of a particular context in a separate hash (if it has an id)
                        // gives a major performance boost when removing thousands of map layers

                        indexKey = type + '_idx';
                        indexLenKey = indexKey + '_len';

                        typeIndex = events[indexKey] = events[indexKey] || {};

                        if (!typeIndex[contextId]) {
                            typeIndex[contextId] = [];

                            // keep track of the number of keys in the index to quickly check if it's empty
                            events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                        }

                        typeIndex[contextId].push(event);


                    } else {
                        events[type] = events[type] || [];
                        events[type].push(event);
                    }
                }

                return this;
            },

            hasEventListeners: function (type) { // (String) -> Boolean
                var events = this[eventsKey];
                return !!events && ((type in events && events[type].length > 0) ||
                    (type + '_idx' in events && events[type + '_idx_len'] > 0));
            },

            removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

                if (!this[eventsKey]) {
                    return this;
                }

                if (!types) {
                    return this.clearAllEventListeners();
                }

                if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }

                var events = this[eventsKey],
                    contextId = context && context !== this && L.stamp(context),
                    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

                types = L.Util.splitWords(types);

                for (i = 0, len = types.length; i < len; i++) {
                    type = types[i];
                    indexKey = type + '_idx';
                    indexLenKey = indexKey + '_len';

                    typeIndex = events[indexKey];

                    if (!fn) {
                        // clear all listeners for a type if function isn't specified
                        delete events[type];
                        delete events[indexKey];
                        delete events[indexLenKey];

                    } else {
                        listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

                        if (listeners) {
                            for (j = listeners.length - 1; j >= 0; j--) {
                                if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
                                    removed = listeners.splice(j, 1);
                                    // set the old action to a no-op, because it is possible
                                    // that the listener is being iterated over as part of a dispatch
                                    removed[0].action = L.Util.falseFn;
                                }
                            }

                            if (context && typeIndex && (listeners.length === 0)) {
                                delete typeIndex[contextId];
                                events[indexLenKey]--;
                            }
                        }
                    }
                }

                return this;
            },

            clearAllEventListeners: function () {
                delete this[eventsKey];
                return this;
            },

            fireEvent: function (type, data) { // (String[, Object])
                if (!this.hasEventListeners(type)) {
                    return this;
                }

                var event = L.Util.extend({}, data, { type: type, target: this });

                var events = this[eventsKey],
                    listeners, i, len, typeIndex, contextId;

                if (events[type]) {
                    // make sure adding/removing listeners inside other listeners won't cause infinite loop
                    listeners = events[type].slice();

                    for (i = 0, len = listeners.length; i < len; i++) {
                        listeners[i].action.call(listeners[i].context, event);
                    }
                }

                // fire event for the context-indexed listeners as well
                typeIndex = events[type + '_idx'];

                for (contextId in typeIndex) {
                    listeners = typeIndex[contextId].slice();

                    if (listeners) {
                        for (i = 0, len = listeners.length; i < len; i++) {
                            listeners[i].action.call(listeners[i].context, event);
                        }
                    }
                }

                return this;
            },

            addOneTimeEventListener: function (types, fn, context) {

                if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }

                var handler = L.bind(function () {
                    this
                        .removeEventListener(types, fn, context)
                        .removeEventListener(types, handler, context);
                }, this);

                return this
                    .addEventListener(types, fn, context)
                    .addEventListener(types, handler, context);
            }
        };

        L.Mixin.Events.on = L.Mixin.Events.addEventListener;
        L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
        L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
        L.Mixin.Events.fire = L.Mixin.Events.fireEvent;


        /*
         * L.Browser handles different browser and feature detections for internal Leaflet use.
         */

        (function () {

            var ie = 'ActiveXObject' in window,
                ielt9 = ie && !document.addEventListener,

            // terrible browser detection to work around Safari / iOS / Android browser bugs
                ua = navigator.userAgent.toLowerCase(),
                webkit = ua.indexOf('webkit') !== -1,
                chrome = ua.indexOf('chrome') !== -1,
                phantomjs = ua.indexOf('phantom') !== -1,
                android = ua.indexOf('android') !== -1,
                android23 = ua.search('android [23]') !== -1,
                gecko = ua.indexOf('gecko') !== -1,

                mobile = typeof orientation !== undefined + '',
                msPointer = !window.PointerEvent && window.MSPointerEvent,
                pointer = (window.PointerEvent && window.navigator.pointerEnabled) ||
                    msPointer,
                retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
                    ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
                    window.matchMedia('(min-resolution:144dpi)').matches),

                doc = document.documentElement,
                ie3d = ie && ('transition' in doc.style),
                webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
                gecko3d = 'MozPerspective' in doc.style,
                opera3d = 'OTransition' in doc.style,
                any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;

            var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||
                (window.DocumentTouch && document instanceof window.DocumentTouch));

            L.Browser = {
                ie: ie,
                ielt9: ielt9,
                webkit: webkit,
                gecko: gecko && !webkit && !window.opera && !ie,

                android: android,
                android23: android23,

                chrome: chrome,

                ie3d: ie3d,
                webkit3d: webkit3d,
                gecko3d: gecko3d,
                opera3d: opera3d,
                any3d: any3d,

                mobile: mobile,
                mobileWebkit: mobile && webkit,
                mobileWebkit3d: mobile && webkit3d,
                mobileOpera: mobile && window.opera,

                touch: touch,
                msPointer: msPointer,
                pointer: pointer,

                retina: retina
            };

        }());


        /*
         * L.Point represents a point with x and y coordinates.
         */

        L.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
            this.x = (round ? Math.round(x) : x);
            this.y = (round ? Math.round(y) : y);
        };

        L.Point.prototype = {

            clone: function () {
                return new L.Point(this.x, this.y);
            },

            // non-destructive, returns a new point
            add: function (point) {
                return this.clone()._add(L.point(point));
            },

            // destructive, used directly for performance in situations where it's safe to modify existing point
            _add: function (point) {
                this.x += point.x;
                this.y += point.y;
                return this;
            },

            subtract: function (point) {
                return this.clone()._subtract(L.point(point));
            },

            _subtract: function (point) {
                this.x -= point.x;
                this.y -= point.y;
                return this;
            },

            divideBy: function (num) {
                return this.clone()._divideBy(num);
            },

            _divideBy: function (num) {
                this.x /= num;
                this.y /= num;
                return this;
            },

            multiplyBy: function (num) {
                return this.clone()._multiplyBy(num);
            },

            _multiplyBy: function (num) {
                this.x *= num;
                this.y *= num;
                return this;
            },

            round: function () {
                return this.clone()._round();
            },

            _round: function () {
                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                return this;
            },

            floor: function () {
                return this.clone()._floor();
            },

            _floor: function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                return this;
            },

            distanceTo: function (point) {
                point = L.point(point);

                var x = point.x - this.x,
                    y = point.y - this.y;

                return Math.sqrt(x * x + y * y);
            },

            equals: function (point) {
                point = L.point(point);

                return point.x === this.x &&
                    point.y === this.y;
            },

            contains: function (point) {
                point = L.point(point);

                return Math.abs(point.x) <= Math.abs(this.x) &&
                    Math.abs(point.y) <= Math.abs(this.y);
            },

            toString: function () {
                return 'Point(' +
                    L.Util.formatNum(this.x) + ', ' +
                    L.Util.formatNum(this.y) + ')';
            }
        };

        L.point = function (x, y, round) {
            if (x instanceof L.Point) {
                return x;
            }
            if (L.Util.isArray(x)) {
                return new L.Point(x[0], x[1]);
            }
            if (x === undefined || x === null) {
                return x;
            }
            return new L.Point(x, y, round);
        };


        /*
         * L.Bounds represents a rectangular area on the screen in pixel coordinates.
         */

        L.Bounds = function (a, b) { //(Point, Point) or Point[]
            if (!a) { return; }

            var points = b ? [a, b] : a;

            for (var i = 0, len = points.length; i < len; i++) {
                this.extend(points[i]);
            }
        };

        L.Bounds.prototype = {
            // extend the bounds to contain the given point
            extend: function (point) { // (Point)
                point = L.point(point);

                if (!this.min && !this.max) {
                    this.min = point.clone();
                    this.max = point.clone();
                } else {
                    this.min.x = Math.min(point.x, this.min.x);
                    this.max.x = Math.max(point.x, this.max.x);
                    this.min.y = Math.min(point.y, this.min.y);
                    this.max.y = Math.max(point.y, this.max.y);
                }
                return this;
            },

            getCenter: function (round) { // (Boolean) -> Point
                return new L.Point(
                    (this.min.x + this.max.x) / 2,
                    (this.min.y + this.max.y) / 2, round);
            },

            getBottomLeft: function () { // -> Point
                return new L.Point(this.min.x, this.max.y);
            },

            getTopRight: function () { // -> Point
                return new L.Point(this.max.x, this.min.y);
            },

            getSize: function () {
                return this.max.subtract(this.min);
            },

            contains: function (obj) { // (Bounds) or (Point) -> Boolean
                var min, max;

                if (typeof obj[0] === 'number' || obj instanceof L.Point) {
                    obj = L.point(obj);
                } else {
                    obj = L.bounds(obj);
                }

                if (obj instanceof L.Bounds) {
                    min = obj.min;
                    max = obj.max;
                } else {
                    min = max = obj;
                }

                return (min.x >= this.min.x) &&
                    (max.x <= this.max.x) &&
                    (min.y >= this.min.y) &&
                    (max.y <= this.max.y);
            },

            intersects: function (bounds) { // (Bounds) -> Boolean
                bounds = L.bounds(bounds);

                var min = this.min,
                    max = this.max,
                    min2 = bounds.min,
                    max2 = bounds.max,
                    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
                    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

                return xIntersects && yIntersects;
            },

            isValid: function () {
                return !!(this.min && this.max);
            }
        };

        L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
            if (!a || a instanceof L.Bounds) {
                return a;
            }
            return new L.Bounds(a, b);
        };


        /*
         * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
         */

        L.Transformation = function (a, b, c, d) {
            this._a = a;
            this._b = b;
            this._c = c;
            this._d = d;
        };

        L.Transformation.prototype = {
            transform: function (point, scale) { // (Point, Number) -> Point
                return this._transform(point.clone(), scale);
            },

            // destructive transform (faster)
            _transform: function (point, scale) {
                scale = scale || 1;
                point.x = scale * (this._a * point.x + this._b);
                point.y = scale * (this._c * point.y + this._d);
                return point;
            },

            untransform: function (point, scale) {
                scale = scale || 1;
                return new L.Point(
                    (point.x / scale - this._b) / this._a,
                    (point.y / scale - this._d) / this._c);
            }
        };


        /*
         * L.DomUtil contains various utility functions for working with DOM.
         */

        L.DomUtil = {
            get: function (id) {
                return (typeof id === 'string' ? document.getElementById(id) : id);
            },

            getStyle: function (el, style) {

                var value = el.style[style];

                if (!value && el.currentStyle) {
                    value = el.currentStyle[style];
                }

                if ((!value || value === 'auto') && document.defaultView) {
                    var css = document.defaultView.getComputedStyle(el, null);
                    value = css ? css[style] : null;
                }

                return value === 'auto' ? null : value;
            },

            getViewportOffset: function (element) {

                var top = 0,
                    left = 0,
                    el = element,
                    docBody = document.body,
                    docEl = document.documentElement,
                    pos;

                do {
                    top  += el.offsetTop  || 0;
                    left += el.offsetLeft || 0;

                    //add borders
                    top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
                    left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

                    pos = L.DomUtil.getStyle(el, 'position');

                    if (el.offsetParent === docBody && pos === 'absolute') { break; }

                    if (pos === 'fixed') {
                        top  += docBody.scrollTop  || docEl.scrollTop  || 0;
                        left += docBody.scrollLeft || docEl.scrollLeft || 0;
                        break;
                    }

                    if (pos === 'relative' && !el.offsetLeft) {
                        var width = L.DomUtil.getStyle(el, 'width'),
                            maxWidth = L.DomUtil.getStyle(el, 'max-width'),
                            r = el.getBoundingClientRect();

                        if (width !== 'none' || maxWidth !== 'none') {
                            left += r.left + el.clientLeft;
                        }

                        //calculate full y offset since we're breaking out of the loop
                        top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);

                        break;
                    }

                    el = el.offsetParent;

                } while (el);

                el = element;

                do {
                    if (el === docBody) { break; }

                    top  -= el.scrollTop  || 0;
                    left -= el.scrollLeft || 0;

                    el = el.parentNode;
                } while (el);

                return new L.Point(left, top);
            },

            documentIsLtr: function () {
                if (!L.DomUtil._docIsLtrCached) {
                    L.DomUtil._docIsLtrCached = true;
                    L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
                }
                return L.DomUtil._docIsLtr;
            },

            create: function (tagName, className, container) {

                var el = document.createElement(tagName);
                el.className = className;

                if (container) {
                    container.appendChild(el);
                }

                return el;
            },

            hasClass: function (el, name) {
                if (el.classList !== undefined) {
                    return el.classList.contains(name);
                }
                var className = L.DomUtil._getClass(el);
                return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
            },

            addClass: function (el, name) {
                if (el.classList !== undefined) {
                    var classes = L.Util.splitWords(name);
                    for (var i = 0, len = classes.length; i < len; i++) {
                        el.classList.add(classes[i]);
                    }
                } else if (!L.DomUtil.hasClass(el, name)) {
                    var className = L.DomUtil._getClass(el);
                    L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
                }
            },

            removeClass: function (el, name) {
                if (el.classList !== undefined) {
                    el.classList.remove(name);
                } else {
                    L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
                }
            },

            _setClass: function (el, name) {
                if (el.className.baseVal === undefined) {
                    el.className = name;
                } else {
                    // in case of SVG element
                    el.className.baseVal = name;
                }
            },

            _getClass: function (el) {
                return el.className.baseVal === undefined ? el.className : el.className.baseVal;
            },

            setOpacity: function (el, value) {

                if ('opacity' in el.style) {
                    el.style.opacity = value;

                } else if ('filter' in el.style) {

                    var filter = false,
                        filterName = 'DXImageTransform.Microsoft.Alpha';

                    // filters collection throws an error if we try to retrieve a filter that doesn't exist
                    try {
                        filter = el.filters.item(filterName);
                    } catch (e) {
                        // don't set opacity to 1 if we haven't already set an opacity,
                        // it isn't needed and breaks transparent pngs.
                        if (value === 1) { return; }
                    }

                    value = Math.round(value * 100);

                    if (filter) {
                        filter.Enabled = (value !== 100);
                        filter.Opacity = value;
                    } else {
                        el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
                    }
                }
            },

            testProp: function (props) {

                var style = document.documentElement.style;

                for (var i = 0; i < props.length; i++) {
                    if (props[i] in style) {
                        return props[i];
                    }
                }
                return false;
            },

            getTranslateString: function (point) {
                // on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
                // makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
                // (same speed either way), Opera 12 doesn't support translate3d

                var is3d = L.Browser.webkit3d,
                    open = 'translate' + (is3d ? '3d' : '') + '(',
                    close = (is3d ? ',0' : '') + ')';

                return open + point.x + 'px,' + point.y + 'px' + close;
            },

            getScaleString: function (scale, origin) {

                var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
                    scaleStr = ' scale(' + scale + ') ';

                return preTranslateStr + scaleStr;
            },

            setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

                // jshint camelcase: false
                el._leaflet_pos = point;

                if (!disable3D && L.Browser.any3d) {
                    el.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);
                } else {
                    el.style.left = point.x + 'px';
                    el.style.top = point.y + 'px';
                }
            },

            getPosition: function (el) {
                // this method is only used for elements previously positioned using setPosition,
                // so it's safe to cache the position for performance

                // jshint camelcase: false
                return el._leaflet_pos;
            }
        };


// prefix style property names

        L.DomUtil.TRANSFORM = L.DomUtil.testProp(
            ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

        L.DomUtil.TRANSITION = L.DomUtil.testProp(
            ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

        L.DomUtil.TRANSITION_END =
            L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?
            L.DomUtil.TRANSITION + 'End' : 'transitionend';

        (function () {
            if ('onselectstart' in document) {
                L.extend(L.DomUtil, {
                    disableTextSelection: function () {
                        L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
                    },

                    enableTextSelection: function () {
                        L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
                    }
                });
            } else {
                var userSelectProperty = L.DomUtil.testProp(
                    ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

                L.extend(L.DomUtil, {
                    disableTextSelection: function () {
                        if (userSelectProperty) {
                            var style = document.documentElement.style;
                            this._userSelect = style[userSelectProperty];
                            style[userSelectProperty] = 'none';
                        }
                    },

                    enableTextSelection: function () {
                        if (userSelectProperty) {
                            document.documentElement.style[userSelectProperty] = this._userSelect;
                            delete this._userSelect;
                        }
                    }
                });
            }

            L.extend(L.DomUtil, {
                disableImageDrag: function () {
                    L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
                },

                enableImageDrag: function () {
                    L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
                }
            });
        })();


        /*
         * L.LatLng represents a geographical point with latitude and longitude coordinates.
         */

        L.LatLng = function (lat, lng, alt) { // (Number, Number, Number)
            lat = parseFloat(lat);
            lng = parseFloat(lng);

            if (isNaN(lat) || isNaN(lng)) {
                throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
            }

            this.lat = lat;
            this.lng = lng;

            if (alt !== undefined) {
                this.alt = parseFloat(alt);
            }
        };

        L.extend(L.LatLng, {
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
        });

        L.LatLng.prototype = {
            equals: function (obj) { // (LatLng) -> Boolean
                if (!obj) { return false; }

                obj = L.latLng(obj);

                var margin = Math.max(
                    Math.abs(this.lat - obj.lat),
                    Math.abs(this.lng - obj.lng));

                return margin <= L.LatLng.MAX_MARGIN;
            },

            toString: function (precision) { // (Number) -> String
                return 'LatLng(' +
                    L.Util.formatNum(this.lat, precision) + ', ' +
                    L.Util.formatNum(this.lng, precision) + ')';
            },

            // Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
            // TODO move to projection code, LatLng shouldn't know about Earth
            distanceTo: function (other) { // (LatLng) -> Number
                other = L.latLng(other);

                var R = 6378137, // earth radius in meters
                    d2r = L.LatLng.DEG_TO_RAD,
                    dLat = (other.lat - this.lat) * d2r,
                    dLon = (other.lng - this.lng) * d2r,
                    lat1 = this.lat * d2r,
                    lat2 = other.lat * d2r,
                    sin1 = Math.sin(dLat / 2),
                    sin2 = Math.sin(dLon / 2);

                var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            },

            wrap: function (a, b) { // (Number, Number) -> LatLng
                var lng = this.lng;

                a = a || -180;
                b = b ||  180;

                lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);

                return new L.LatLng(this.lat, lng);
            }
        };

        L.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)
            if (a instanceof L.LatLng) {
                return a;
            }
            if (L.Util.isArray(a)) {
                if (typeof a[0] === 'number' || typeof a[0] === 'string') {
                    return new L.LatLng(a[0], a[1], a[2]);
                } else {
                    return null;
                }
            }
            if (a === undefined || a === null) {
                return a;
            }
            if (typeof a === 'object' && 'lat' in a) {
                return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
            }
            if (b === undefined) {
                return null;
            }
            return new L.LatLng(a, b);
        };



        /*
         * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
         */

        L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
            if (!southWest) { return; }

            var latlngs = northEast ? [southWest, northEast] : southWest;

            for (var i = 0, len = latlngs.length; i < len; i++) {
                this.extend(latlngs[i]);
            }
        };

        L.LatLngBounds.prototype = {
            // extend the bounds to contain the given point or bounds
            extend: function (obj) { // (LatLng) or (LatLngBounds)
                if (!obj) { return this; }

                var latLng = L.latLng(obj);
                if (latLng !== null) {
                    obj = latLng;
                } else {
                    obj = L.latLngBounds(obj);
                }

                if (obj instanceof L.LatLng) {
                    if (!this._southWest && !this._northEast) {
                        this._southWest = new L.LatLng(obj.lat, obj.lng);
                        this._northEast = new L.LatLng(obj.lat, obj.lng);
                    } else {
                        this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
                        this._southWest.lng = Math.min(obj.lng, this._southWest.lng);

                        this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
                        this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
                    }
                } else if (obj instanceof L.LatLngBounds) {
                    this.extend(obj._southWest);
                    this.extend(obj._northEast);
                }
                return this;
            },

            // extend the bounds by a percentage
            pad: function (bufferRatio) { // (Number) -> LatLngBounds
                var sw = this._southWest,
                    ne = this._northEast,
                    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
                    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

                return new L.LatLngBounds(
                    new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
                    new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
            },

            getCenter: function () { // -> LatLng
                return new L.LatLng(
                    (this._southWest.lat + this._northEast.lat) / 2,
                    (this._southWest.lng + this._northEast.lng) / 2);
            },

            getSouthWest: function () {
                return this._southWest;
            },

            getNorthEast: function () {
                return this._northEast;
            },

            getNorthWest: function () {
                return new L.LatLng(this.getNorth(), this.getWest());
            },

            getSouthEast: function () {
                return new L.LatLng(this.getSouth(), this.getEast());
            },

            getWest: function () {
                return this._southWest.lng;
            },

            getSouth: function () {
                return this._southWest.lat;
            },

            getEast: function () {
                return this._northEast.lng;
            },

            getNorth: function () {
                return this._northEast.lat;
            },

            contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
                if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
                    obj = L.latLng(obj);
                } else {
                    obj = L.latLngBounds(obj);
                }

                var sw = this._southWest,
                    ne = this._northEast,
                    sw2, ne2;

                if (obj instanceof L.LatLngBounds) {
                    sw2 = obj.getSouthWest();
                    ne2 = obj.getNorthEast();
                } else {
                    sw2 = ne2 = obj;
                }

                return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
                    (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
            },

            intersects: function (bounds) { // (LatLngBounds)
                bounds = L.latLngBounds(bounds);

                var sw = this._southWest,
                    ne = this._northEast,
                    sw2 = bounds.getSouthWest(),
                    ne2 = bounds.getNorthEast(),

                    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
                    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

                return latIntersects && lngIntersects;
            },

            toBBoxString: function () {
                return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
            },

            equals: function (bounds) { // (LatLngBounds)
                if (!bounds) { return false; }

                bounds = L.latLngBounds(bounds);

                return this._southWest.equals(bounds.getSouthWest()) &&
                    this._northEast.equals(bounds.getNorthEast());
            },

            isValid: function () {
                return !!(this._southWest && this._northEast);
            }
        };

//TODO International date line?

        L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
            if (!a || a instanceof L.LatLngBounds) {
                return a;
            }
            return new L.LatLngBounds(a, b);
        };


        /*
         * L.Projection contains various geographical projections used by CRS classes.
         */

        L.Projection = {};


        /*
         * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
         */

        L.Projection.SphericalMercator = {
            MAX_LATITUDE: 85.0511287798,

            project: function (latlng) { // (LatLng) -> Point
                var d = L.LatLng.DEG_TO_RAD,
                    max = this.MAX_LATITUDE,
                    lat = Math.max(Math.min(max, latlng.lat), -max),
                    x = latlng.lng * d,
                    y = lat * d;

                y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

                return new L.Point(x, y);
            },

            unproject: function (point) { // (Point, Boolean) -> LatLng
                var d = L.LatLng.RAD_TO_DEG,
                    lng = point.x * d,
                    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;

                return new L.LatLng(lat, lng);
            }
        };


        /*
         * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
         */

        L.Projection.LonLat = {
            project: function (latlng) {
                return new L.Point(latlng.lng, latlng.lat);
            },

            unproject: function (point) {
                return new L.LatLng(point.y, point.x);
            }
        };


        /*
         * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
         */

        L.CRS = {
            latLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point
                var projectedPoint = this.projection.project(latlng),
                    scale = this.scale(zoom);

                return this.transformation._transform(projectedPoint, scale);
            },

            pointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng
                var scale = this.scale(zoom),
                    untransformedPoint = this.transformation.untransform(point, scale);

                return this.projection.unproject(untransformedPoint);
            },

            project: function (latlng) {
                return this.projection.project(latlng);
            },

            scale: function (zoom) {
                return 256 * Math.pow(2, zoom);
            },

            getSize: function (zoom) {
                var s = this.scale(zoom);
                return L.point(s, s);
            }
        };


        /*
         * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
         */

        L.CRS.Simple = L.extend({}, L.CRS, {
            projection: L.Projection.LonLat,
            transformation: new L.Transformation(1, 0, -1, 0),

            scale: function (zoom) {
                return Math.pow(2, zoom);
            }
        });


        /*
         * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
         * and is used by Leaflet by default.
         */

        L.CRS.EPSG3857 = L.extend({}, L.CRS, {
            code: 'EPSG:3857',

            projection: L.Projection.SphericalMercator,
            transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),

            project: function (latlng) { // (LatLng) -> Point
                var projectedPoint = this.projection.project(latlng),
                    earthRadius = 6378137;
                return projectedPoint.multiplyBy(earthRadius);
            }
        });

        L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
            code: 'EPSG:900913'
        });


        /*
         * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
         */

        L.CRS.EPSG4326 = L.extend({}, L.CRS, {
            code: 'EPSG:4326',

            projection: L.Projection.LonLat,
            transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
        });


        /*
         * L.Map is the central class of the API - it is used to create a map.
         */

        L.Map = L.Class.extend({

            includes: L.Mixin.Events,

            options: {
                crs: L.CRS.EPSG3857,

                /*
                 center: LatLng,
                 zoom: Number,
                 layers: Array,
                 */

                fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
                trackResize: true,
                markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
            },

            initialize: function (id, options) { // (HTMLElement or String, Object)
                options = L.setOptions(this, options);


                this._initContainer(id);
                this._initLayout();

                // hack for https://github.com/Leaflet/Leaflet/issues/1980
                this._onResize = L.bind(this._onResize, this);

                this._initEvents();

                if (options.maxBounds) {
                    this.setMaxBounds(options.maxBounds);
                }

                if (options.center && options.zoom !== undefined) {
                    this.setView(L.latLng(options.center), options.zoom, {reset: true});
                }

                this._handlers = [];

                this._layers = {};
                this._zoomBoundLayers = {};
                this._tileLayersNum = 0;

                this.callInitHooks();

                this._addLayers(options.layers);
            },


            // public methods that modify map state

            // replaced by animation-powered implementation in Map.PanAnimation.js
            setView: function (center, zoom) {
                zoom = zoom === undefined ? this.getZoom() : zoom;
                this._resetView(L.latLng(center), this._limitZoom(zoom));
                return this;
            },

            setZoom: function (zoom, options) {
                if (!this._loaded) {
                    this._zoom = this._limitZoom(zoom);
                    return this;
                }
                return this.setView(this.getCenter(), zoom, {zoom: options});
            },

            zoomIn: function (delta, options) {
                return this.setZoom(this._zoom + (delta || 1), options);
            },

            zoomOut: function (delta, options) {
                return this.setZoom(this._zoom - (delta || 1), options);
            },

            setZoomAround: function (latlng, zoom, options) {
                var scale = this.getZoomScale(zoom),
                    viewHalf = this.getSize().divideBy(2),
                    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

                    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
                    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

                return this.setView(newCenter, zoom, {zoom: options});
            },

            fitBounds: function (bounds, options) {

                options = options || {};
                bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

                var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
                    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

                    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

                zoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;

                var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

                    swPoint = this.project(bounds.getSouthWest(), zoom),
                    nePoint = this.project(bounds.getNorthEast(), zoom),
                    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

                return this.setView(center, zoom, options);
            },

            fitWorld: function (options) {
                return this.fitBounds([[-90, -180], [90, 180]], options);
            },

            panTo: function (center, options) { // (LatLng)
                return this.setView(center, this._zoom, {pan: options});
            },

            panBy: function (offset) { // (Point)
                // replaced with animated panBy in Map.PanAnimation.js
                this.fire('movestart');

                this._rawPanBy(L.point(offset));

                this.fire('move');
                return this.fire('moveend');
            },

            setMaxBounds: function (bounds) {
                bounds = L.latLngBounds(bounds);

                this.options.maxBounds = bounds;

                if (!bounds) {
                    return this.off('moveend', this._panInsideMaxBounds, this);
                }

                if (this._loaded) {
                    this._panInsideMaxBounds();
                }

                return this.on('moveend', this._panInsideMaxBounds, this);
            },

            panInsideBounds: function (bounds, options) {
                var center = this.getCenter(),
                    newCenter = this._limitCenter(center, this._zoom, bounds);

                if (center.equals(newCenter)) { return this; }

                return this.panTo(newCenter, options);
            },

            addLayer: function (layer) {
                // TODO method is too big, refactor

                var id = L.stamp(layer);

                if (this._layers[id]) { return this; }

                this._layers[id] = layer;

                // TODO getMaxZoom, getMinZoom in ILayer (instead of options)
                if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
                    this._zoomBoundLayers[id] = layer;
                    this._updateZoomLevels();
                }

                // TODO looks ugly, refactor!!!
                if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
                    this._tileLayersNum++;
                    this._tileLayersToLoad++;
                    layer.on('load', this._onTileLayerLoad, this);
                }

                if (this._loaded) {
                    this._layerAdd(layer);
                }

                return this;
            },

            removeLayer: function (layer) {
                var id = L.stamp(layer);

                if (!this._layers[id]) { return this; }

                if (this._loaded) {
                    layer.onRemove(this);
                }

                delete this._layers[id];

                if (this._loaded) {
                    this.fire('layerremove', {layer: layer});
                }

                if (this._zoomBoundLayers[id]) {
                    delete this._zoomBoundLayers[id];
                    this._updateZoomLevels();
                }

                // TODO looks ugly, refactor
                if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
                    this._tileLayersNum--;
                    this._tileLayersToLoad--;
                    layer.off('load', this._onTileLayerLoad, this);
                }

                return this;
            },

            hasLayer: function (layer) {
                if (!layer) { return false; }

                return (L.stamp(layer) in this._layers);
            },

            eachLayer: function (method, context) {
                for (var i in this._layers) {
                    method.call(context, this._layers[i]);
                }
                return this;
            },

            invalidateSize: function (options) {
                if (!this._loaded) { return this; }

                options = L.extend({
                    animate: false,
                    pan: true
                }, options === true ? {animate: true} : options);

                var oldSize = this.getSize();
                this._sizeChanged = true;
                this._initialCenter = null;

                var newSize = this.getSize(),
                    oldCenter = oldSize.divideBy(2).round(),
                    newCenter = newSize.divideBy(2).round(),
                    offset = oldCenter.subtract(newCenter);

                if (!offset.x && !offset.y) { return this; }

                if (options.animate && options.pan) {
                    this.panBy(offset);

                } else {
                    if (options.pan) {
                        this._rawPanBy(offset);
                    }

                    this.fire('move');

                    if (options.debounceMoveend) {
                        clearTimeout(this._sizeTimer);
                        this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
                    } else {
                        this.fire('moveend');
                    }
                }

                return this.fire('resize', {
                    oldSize: oldSize,
                    newSize: newSize
                });
            },

            // TODO handler.addTo
            addHandler: function (name, HandlerClass) {
                if (!HandlerClass) { return this; }

                var handler = this[name] = new HandlerClass(this);

                this._handlers.push(handler);

                if (this.options[name]) {
                    handler.enable();
                }

                return this;
            },

            remove: function () {
                if (this._loaded) {
                    this.fire('unload');
                }

                this._initEvents('off');

                try {
                    // throws error in IE6-8
                    delete this._container._leaflet;
                } catch (e) {
                    this._container._leaflet = undefined;
                }

                this._clearPanes();
                if (this._clearControlPos) {
                    this._clearControlPos();
                }

                this._clearHandlers();

                return this;
            },


            // public methods for getting map state

            getCenter: function () { // (Boolean) -> LatLng
                this._checkIfLoaded();

                if (this._initialCenter && !this._moved()) {
                    return this._initialCenter;
                }
                return this.layerPointToLatLng(this._getCenterLayerPoint());
            },

            getZoom: function () {
                return this._zoom;
            },

            getBounds: function () {
                var bounds = this.getPixelBounds(),
                    sw = this.unproject(bounds.getBottomLeft()),
                    ne = this.unproject(bounds.getTopRight());

                return new L.LatLngBounds(sw, ne);
            },

            getMinZoom: function () {
                return this.options.minZoom === undefined ?
                    (this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :
                    this.options.minZoom;
            },

            getMaxZoom: function () {
                return this.options.maxZoom === undefined ?
                    (this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
                    this.options.maxZoom;
            },

            getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
                bounds = L.latLngBounds(bounds);

                var zoom = this.getMinZoom() - (inside ? 1 : 0),
                    maxZoom = this.getMaxZoom(),
                    size = this.getSize(),

                    nw = bounds.getNorthWest(),
                    se = bounds.getSouthEast(),

                    zoomNotFound = true,
                    boundsSize;

                padding = L.point(padding || [0, 0]);

                do {
                    zoom++;
                    boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
                    zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

                } while (zoomNotFound && zoom <= maxZoom);

                if (zoomNotFound && inside) {
                    return null;
                }

                return inside ? zoom : zoom - 1;
            },

            getSize: function () {
                if (!this._size || this._sizeChanged) {
                    this._size = new L.Point(
                        this._container.clientWidth,
                        this._container.clientHeight);

                    this._sizeChanged = false;
                }
                return this._size.clone();
            },

            getPixelBounds: function () {
                var topLeftPoint = this._getTopLeftPoint();
                return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
            },

            getPixelOrigin: function () {
                this._checkIfLoaded();
                return this._initialTopLeftPoint;
            },

            getPanes: function () {
                return this._panes;
            },

            getContainer: function () {
                return this._container;
            },


            // TODO replace with universal implementation after refactoring projections

            getZoomScale: function (toZoom) {
                var crs = this.options.crs;
                return crs.scale(toZoom) / crs.scale(this._zoom);
            },

            getScaleZoom: function (scale) {
                return this._zoom + (Math.log(scale) / Math.LN2);
            },


            // conversion methods

            project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
                zoom = zoom === undefined ? this._zoom : zoom;
                return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
            },

            unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
                zoom = zoom === undefined ? this._zoom : zoom;
                return this.options.crs.pointToLatLng(L.point(point), zoom);
            },

            layerPointToLatLng: function (point) { // (Point)
                var projectedPoint = L.point(point).add(this.getPixelOrigin());
                return this.unproject(projectedPoint);
            },

            latLngToLayerPoint: function (latlng) { // (LatLng)
                var projectedPoint = this.project(L.latLng(latlng))._round();
                return projectedPoint._subtract(this.getPixelOrigin());
            },

            containerPointToLayerPoint: function (point) { // (Point)
                return L.point(point).subtract(this._getMapPanePos());
            },

            layerPointToContainerPoint: function (point) { // (Point)
                return L.point(point).add(this._getMapPanePos());
            },

            containerPointToLatLng: function (point) {
                var layerPoint = this.containerPointToLayerPoint(L.point(point));
                return this.layerPointToLatLng(layerPoint);
            },

            latLngToContainerPoint: function (latlng) {
                return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
            },

            mouseEventToContainerPoint: function (e) { // (MouseEvent)
                return L.DomEvent.getMousePosition(e, this._container);
            },

            mouseEventToLayerPoint: function (e) { // (MouseEvent)
                return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
            },

            mouseEventToLatLng: function (e) { // (MouseEvent)
                return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
            },


            // map initialization methods

            _initContainer: function (id) {
                var container = this._container = L.DomUtil.get(id);

                if (!container) {
                    throw new Error('Map container not found.');
                } else if (container._leaflet) {
                    throw new Error('Map container is already initialized.');
                }

                container._leaflet = true;
            },

            _initLayout: function () {
                var container = this._container;

                L.DomUtil.addClass(container, 'leaflet-container' +
                    (L.Browser.touch ? ' leaflet-touch' : '') +
                    (L.Browser.retina ? ' leaflet-retina' : '') +
                    (L.Browser.ielt9 ? ' leaflet-oldie' : '') +
                    (this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));

                var position = L.DomUtil.getStyle(container, 'position');

                if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
                    container.style.position = 'relative';
                }

                this._initPanes();

                if (this._initControlPos) {
                    this._initControlPos();
                }
            },

            _initPanes: function () {
                var panes = this._panes = {};

                this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);

                this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
                panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
                panes.shadowPane = this._createPane('leaflet-shadow-pane');
                panes.overlayPane = this._createPane('leaflet-overlay-pane');
                panes.markerPane = this._createPane('leaflet-marker-pane');
                panes.popupPane = this._createPane('leaflet-popup-pane');

                var zoomHide = ' leaflet-zoom-hide';

                if (!this.options.markerZoomAnimation) {
                    L.DomUtil.addClass(panes.markerPane, zoomHide);
                    L.DomUtil.addClass(panes.shadowPane, zoomHide);
                    L.DomUtil.addClass(panes.popupPane, zoomHide);
                }
            },

            _createPane: function (className, container) {
                return L.DomUtil.create('div', className, container || this._panes.objectsPane);
            },

            _clearPanes: function () {
                this._container.removeChild(this._mapPane);
            },

            _addLayers: function (layers) {
                layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

                for (var i = 0, len = layers.length; i < len; i++) {
                    this.addLayer(layers[i]);
                }
            },


            // private methods that modify map state

            _resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

                var zoomChanged = (this._zoom !== zoom);

                if (!afterZoomAnim) {
                    this.fire('movestart');

                    if (zoomChanged) {
                        this.fire('zoomstart');
                    }
                }

                this._zoom = zoom;
                this._initialCenter = center;

                this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

                if (!preserveMapOffset) {
                    L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
                } else {
                    this._initialTopLeftPoint._add(this._getMapPanePos());
                }

                this._tileLayersToLoad = this._tileLayersNum;

                var loading = !this._loaded;
                this._loaded = true;

                this.fire('viewreset', {hard: !preserveMapOffset});

                if (loading) {
                    this.fire('load');
                    this.eachLayer(this._layerAdd, this);
                }

                this.fire('move');

                if (zoomChanged || afterZoomAnim) {
                    this.fire('zoomend');
                }

                this.fire('moveend', {hard: !preserveMapOffset});
            },

            _rawPanBy: function (offset) {
                L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
            },

            _getZoomSpan: function () {
                return this.getMaxZoom() - this.getMinZoom();
            },

            _updateZoomLevels: function () {
                var i,
                    minZoom = Infinity,
                    maxZoom = -Infinity,
                    oldZoomSpan = this._getZoomSpan();

                for (i in this._zoomBoundLayers) {
                    var layer = this._zoomBoundLayers[i];
                    if (!isNaN(layer.options.minZoom)) {
                        minZoom = Math.min(minZoom, layer.options.minZoom);
                    }
                    if (!isNaN(layer.options.maxZoom)) {
                        maxZoom = Math.max(maxZoom, layer.options.maxZoom);
                    }
                }

                if (i === undefined) { // we have no tilelayers
                    this._layersMaxZoom = this._layersMinZoom = undefined;
                } else {
                    this._layersMaxZoom = maxZoom;
                    this._layersMinZoom = minZoom;
                }

                if (oldZoomSpan !== this._getZoomSpan()) {
                    this.fire('zoomlevelschange');
                }
            },

            _panInsideMaxBounds: function () {
                this.panInsideBounds(this.options.maxBounds);
            },

            _checkIfLoaded: function () {
                if (!this._loaded) {
                    throw new Error('Set map center and zoom first.');
                }
            },

            // map events

            _initEvents: function (onOff) {
                if (!L.DomEvent) { return; }

                onOff = onOff || 'on';

                L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

                var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
                        'mouseleave', 'mousemove', 'contextmenu'],
                    i, len;

                for (i = 0, len = events.length; i < len; i++) {
                    L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
                }

                if (this.options.trackResize) {
                    L.DomEvent[onOff](window, 'resize', this._onResize, this);
                }
            },

            _onResize: function () {
                L.Util.cancelAnimFrame(this._resizeRequest);
                this._resizeRequest = L.Util.requestAnimFrame(
                    function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);
            },

            _onMouseClick: function (e) {
                if (!this._loaded || (!e._simulated &&
                    ((this.dragging && this.dragging.moved()) ||
                    (this.boxZoom  && this.boxZoom.moved()))) ||
                    L.DomEvent._skipped(e)) { return; }

                this.fire('preclick');
                this._fireMouseEvent(e);
            },

            _fireMouseEvent: function (e) {
                if (!this._loaded || L.DomEvent._skipped(e)) { return; }

                var type = e.type;

                type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

                if (!this.hasEventListeners(type)) { return; }

                if (type === 'contextmenu') {
                    L.DomEvent.preventDefault(e);
                }

                var containerPoint = this.mouseEventToContainerPoint(e),
                    layerPoint = this.containerPointToLayerPoint(containerPoint),
                    latlng = this.layerPointToLatLng(layerPoint);

                this.fire(type, {
                    latlng: latlng,
                    layerPoint: layerPoint,
                    containerPoint: containerPoint,
                    originalEvent: e
                });
            },

            _onTileLayerLoad: function () {
                this._tileLayersToLoad--;
                if (this._tileLayersNum && !this._tileLayersToLoad) {
                    this.fire('tilelayersload');
                }
            },

            _clearHandlers: function () {
                for (var i = 0, len = this._handlers.length; i < len; i++) {
                    this._handlers[i].disable();
                }
            },

            whenReady: function (callback, context) {
                if (this._loaded) {
                    callback.call(context || this, this);
                } else {
                    this.on('load', callback, context);
                }
                return this;
            },

            _layerAdd: function (layer) {
                layer.onAdd(this);
                this.fire('layeradd', {layer: layer});
            },


            // private methods for getting map state

            _getMapPanePos: function () {
                return L.DomUtil.getPosition(this._mapPane);
            },

            _moved: function () {
                var pos = this._getMapPanePos();
                return pos && !pos.equals([0, 0]);
            },

            _getTopLeftPoint: function () {
                return this.getPixelOrigin().subtract(this._getMapPanePos());
            },

            _getNewTopLeftPoint: function (center, zoom) {
                var viewHalf = this.getSize()._divideBy(2);
                // TODO round on display, not calculation to increase precision?
                return this.project(center, zoom)._subtract(viewHalf)._round();
            },

            _latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {
                var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
                return this.project(latlng, newZoom)._subtract(topLeft);
            },

            // layer point of the current center
            _getCenterLayerPoint: function () {
                return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
            },

            // offset of the specified place to the current center in pixels
            _getCenterOffset: function (latlng) {
                return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
            },

            // adjust center for view to get inside bounds
            _limitCenter: function (center, zoom, bounds) {

                if (!bounds) { return center; }

                var centerPoint = this.project(center, zoom),
                    viewHalf = this.getSize().divideBy(2),
                    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
                    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

                return this.unproject(centerPoint.add(offset), zoom);
            },

            // adjust offset for view to get inside bounds
            _limitOffset: function (offset, bounds) {
                if (!bounds) { return offset; }

                var viewBounds = this.getPixelBounds(),
                    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

                return offset.add(this._getBoundsOffset(newBounds, bounds));
            },

            // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
            _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
                var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
                    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

                    dx = this._rebound(nwOffset.x, -seOffset.x),
                    dy = this._rebound(nwOffset.y, -seOffset.y);

                return new L.Point(dx, dy);
            },

            _rebound: function (left, right) {
                return left + right > 0 ?
                Math.round(left - right) / 2 :
                Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
            },

            _limitZoom: function (zoom) {
                var min = this.getMinZoom(),
                    max = this.getMaxZoom();

                return Math.max(min, Math.min(max, zoom));
            }
        });

        L.map = function (id, options) {
            return new L.Map(id, options);
        };


        /*
         * Mercator projection that takes into account that the Earth is not a perfect sphere.
         * Less popular than spherical mercator; used by projections like EPSG:3395.
         */

        L.Projection.Mercator = {
            MAX_LATITUDE: 85.0840591556,

            R_MINOR: 6356752.314245179,
            R_MAJOR: 6378137,

            project: function (latlng) { // (LatLng) -> Point
                var d = L.LatLng.DEG_TO_RAD,
                    max = this.MAX_LATITUDE,
                    lat = Math.max(Math.min(max, latlng.lat), -max),
                    r = this.R_MAJOR,
                    r2 = this.R_MINOR,
                    x = latlng.lng * d * r,
                    y = lat * d,
                    tmp = r2 / r,
                    eccent = Math.sqrt(1.0 - tmp * tmp),
                    con = eccent * Math.sin(y);

                con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

                var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
                y = -r * Math.log(ts);

                return new L.Point(x, y);
            },

            unproject: function (point) { // (Point, Boolean) -> LatLng
                var d = L.LatLng.RAD_TO_DEG,
                    r = this.R_MAJOR,
                    r2 = this.R_MINOR,
                    lng = point.x * d / r,
                    tmp = r2 / r,
                    eccent = Math.sqrt(1 - (tmp * tmp)),
                    ts = Math.exp(- point.y / r),
                    phi = (Math.PI / 2) - 2 * Math.atan(ts),
                    numIter = 15,
                    tol = 1e-7,
                    i = numIter,
                    dphi = 0.1,
                    con;

                while ((Math.abs(dphi) > tol) && (--i > 0)) {
                    con = eccent * Math.sin(phi);
                    dphi = (Math.PI / 2) - 2 * Math.atan(ts *
                            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
                    phi += dphi;
                }

                return new L.LatLng(phi * d, lng);
            }
        };



        L.CRS.EPSG3395 = L.extend({}, L.CRS, {
            code: 'EPSG:3395',

            projection: L.Projection.Mercator,

            transformation: (function () {
                var m = L.Projection.Mercator,
                    r = m.R_MAJOR,
                    scale = 0.5 / (Math.PI * r);

                return new L.Transformation(scale, 0.5, -scale, 0.5);
            }())
        });


        /*
         * L.TileLayer is used for standard xyz-numbered tile layers.
         */

        L.TileLayer = L.Class.extend({
            includes: L.Mixin.Events,

            options: {
                minZoom: 0,
                maxZoom: 18,
                tileSize: 256,
                subdomains: 'abc',
                errorTileUrl: '',
                attribution: '',
                zoomOffset: 0,
                opacity: 1,
                /*
                 maxNativeZoom: null,
                 zIndex: null,
                 tms: false,
                 continuousWorld: false,
                 noWrap: false,
                 zoomReverse: false,
                 detectRetina: false,
                 reuseTiles: false,
                 bounds: false,
                 */
                unloadInvisibleTiles: L.Browser.mobile,
                updateWhenIdle: L.Browser.mobile
            },

            initialize: function (url, options) {
                options = L.setOptions(this, options);

                // detecting retina displays, adjusting tileSize and zoom levels
                if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

                    options.tileSize = Math.floor(options.tileSize / 2);
                    options.zoomOffset++;

                    if (options.minZoom > 0) {
                        options.minZoom--;
                    }
                    this.options.maxZoom--;
                }

                if (options.bounds) {
                    options.bounds = L.latLngBounds(options.bounds);
                }

                this._url = url;

                var subdomains = this.options.subdomains;

                if (typeof subdomains === 'string') {
                    this.options.subdomains = subdomains.split('');
                }
            },

            onAdd: function (map) {
                this._map = map;
                this._animated = map._zoomAnimated;

                // create a container div for tiles
                this._initContainer();

                // set up events
                map.on({
                    'viewreset': this._reset,
                    'moveend': this._update
                }, this);

                if (this._animated) {
                    map.on({
                        'zoomanim': this._animateZoom,
                        'zoomend': this._endZoomAnim
                    }, this);
                }

                if (!this.options.updateWhenIdle) {
                    this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
                    map.on('move', this._limitedUpdate, this);
                }

                this._reset();
                this._update();
            },

            addTo: function (map) {
                map.addLayer(this);
                return this;
            },

            onRemove: function (map) {
                this._container.parentNode.removeChild(this._container);

                map.off({
                    'viewreset': this._reset,
                    'moveend': this._update
                }, this);

                if (this._animated) {
                    map.off({
                        'zoomanim': this._animateZoom,
                        'zoomend': this._endZoomAnim
                    }, this);
                }

                if (!this.options.updateWhenIdle) {
                    map.off('move', this._limitedUpdate, this);
                }

                this._container = null;
                this._map = null;
            },

            bringToFront: function () {
                var pane = this._map._panes.tilePane;

                if (this._container) {
                    pane.appendChild(this._container);
                    this._setAutoZIndex(pane, Math.max);
                }

                return this;
            },

            bringToBack: function () {
                var pane = this._map._panes.tilePane;

                if (this._container) {
                    pane.insertBefore(this._container, pane.firstChild);
                    this._setAutoZIndex(pane, Math.min);
                }

                return this;
            },

            getAttribution: function () {
                return this.options.attribution;
            },

            getContainer: function () {
                return this._container;
            },

            setOpacity: function (opacity) {
                this.options.opacity = opacity;

                if (this._map) {
                    this._updateOpacity();
                }

                return this;
            },

            setZIndex: function (zIndex) {
                this.options.zIndex = zIndex;
                this._updateZIndex();

                return this;
            },

            setUrl: function (url, noRedraw) {
                this._url = url;

                if (!noRedraw) {
                    this.redraw();
                }

                return this;
            },

            redraw: function () {
                if (this._map) {
                    this._reset({hard: true});
                    this._update();
                }
                return this;
            },

            _updateZIndex: function () {
                if (this._container && this.options.zIndex !== undefined) {
                    this._container.style.zIndex = this.options.zIndex;
                }
            },

            _setAutoZIndex: function (pane, compare) {

                var layers = pane.children,
                    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
                    zIndex, i, len;

                for (i = 0, len = layers.length; i < len; i++) {

                    if (layers[i] !== this._container) {
                        zIndex = parseInt(layers[i].style.zIndex, 10);

                        if (!isNaN(zIndex)) {
                            edgeZIndex = compare(edgeZIndex, zIndex);
                        }
                    }
                }

                this.options.zIndex = this._container.style.zIndex =
                    (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
            },

            _updateOpacity: function () {
                var i,
                    tiles = this._tiles;

                if (L.Browser.ielt9) {
                    for (i in tiles) {
                        L.DomUtil.setOpacity(tiles[i], this.options.opacity);
                    }
                } else {
                    L.DomUtil.setOpacity(this._container, this.options.opacity);
                }
            },

            _initContainer: function () {
                var tilePane = this._map._panes.tilePane;

                if (!this._container) {
                    this._container = L.DomUtil.create('div', 'leaflet-layer');

                    this._updateZIndex();

                    if (this._animated) {
                        var className = 'leaflet-tile-container';

                        this._bgBuffer = L.DomUtil.create('div', className, this._container);
                        this._tileContainer = L.DomUtil.create('div', className, this._container);

                    } else {
                        this._tileContainer = this._container;
                    }

                    tilePane.appendChild(this._container);

                    if (this.options.opacity < 1) {
                        this._updateOpacity();
                    }
                }
            },

            _reset: function (e) {
                for (var key in this._tiles) {
                    this.fire('tileunload', {tile: this._tiles[key]});
                }

                this._tiles = {};
                this._tilesToLoad = 0;

                if (this.options.reuseTiles) {
                    this._unusedTiles = [];
                }

                this._tileContainer.innerHTML = '';

                if (this._animated && e && e.hard) {
                    this._clearBgBuffer();
                }

                this._initContainer();
            },

            _getTileSize: function () {
                var map = this._map,
                    zoom = map.getZoom() + this.options.zoomOffset,
                    zoomN = this.options.maxNativeZoom,
                    tileSize = this.options.tileSize;

                if (zoomN && zoom > zoomN) {
                    tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
                }

                return tileSize;
            },

            _update: function () {

                if (!this._map) { return; }

                var map = this._map,
                    bounds = map.getPixelBounds(),
                    zoom = map.getZoom(),
                    tileSize = this._getTileSize();

                if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                    return;
                }

                var tileBounds = L.bounds(
                    bounds.min.divideBy(tileSize)._floor(),
                    bounds.max.divideBy(tileSize)._floor());

                this._addTilesFromCenterOut(tileBounds);

                if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
                    this._removeOtherTiles(tileBounds);
                }
            },

            _addTilesFromCenterOut: function (bounds) {
                var queue = [],
                    center = bounds.getCenter();

                var j, i, point;

                for (j = bounds.min.y; j <= bounds.max.y; j++) {
                    for (i = bounds.min.x; i <= bounds.max.x; i++) {
                        point = new L.Point(i, j);

                        if (this._tileShouldBeLoaded(point)) {
                            queue.push(point);
                        }
                    }
                }

                var tilesToLoad = queue.length;

                if (tilesToLoad === 0) { return; }

                // load tiles in order of their distance to center
                queue.sort(function (a, b) {
                    return a.distanceTo(center) - b.distanceTo(center);
                });

                var fragment = document.createDocumentFragment();

                // if its the first batch of tiles to load
                if (!this._tilesToLoad) {
                    this.fire('loading');
                }

                this._tilesToLoad += tilesToLoad;

                for (i = 0; i < tilesToLoad; i++) {
                    this._addTile(queue[i], fragment);
                }

                this._tileContainer.appendChild(fragment);
            },

            _tileShouldBeLoaded: function (tilePoint) {
                if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
                    return false; // already loaded
                }

                var options = this.options;

                if (!options.continuousWorld) {
                    var limit = this._getWrapTileNum();

                    // don't load if exceeds world bounds
                    if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
                        tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
                }

                if (options.bounds) {
                    var tileSize = this._getTileSize(),
                        nwPoint = tilePoint.multiplyBy(tileSize),
                        sePoint = nwPoint.add([tileSize, tileSize]),
                        nw = this._map.unproject(nwPoint),
                        se = this._map.unproject(sePoint);

                    // TODO temporary hack, will be removed after refactoring projections
                    // https://github.com/Leaflet/Leaflet/issues/1618
                    if (!options.continuousWorld && !options.noWrap) {
                        nw = nw.wrap();
                        se = se.wrap();
                    }

                    if (!options.bounds.intersects([nw, se])) { return false; }
                }

                return true;
            },

            _removeOtherTiles: function (bounds) {
                var kArr, x, y, key;

                for (key in this._tiles) {
                    kArr = key.split(':');
                    x = parseInt(kArr[0], 10);
                    y = parseInt(kArr[1], 10);

                    // remove tile if it's out of bounds
                    if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
                        this._removeTile(key);
                    }
                }
            },

            _removeTile: function (key) {
                var tile = this._tiles[key];

                this.fire('tileunload', {tile: tile, url: tile.src});

                if (this.options.reuseTiles) {
                    L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
                    this._unusedTiles.push(tile);

                } else if (tile.parentNode === this._tileContainer) {
                    this._tileContainer.removeChild(tile);
                }

                // for https://github.com/CloudMade/Leaflet/issues/137
                if (!L.Browser.android) {
                    tile.onload = null;
                    tile.src = L.Util.emptyImageUrl;
                }

                delete this._tiles[key];
            },

            _addTile: function (tilePoint, container) {
                var tilePos = this._getTilePos(tilePoint);

                // get unused tile - or create a new tile
                var tile = this._getTile();

                /*
                 Chrome 20 layouts much faster with top/left (verify with timeline, frames)
                 Android 4 browser has display issues with top/left and requires transform instead
                 (other browsers don't currently care) - see debug/hacks/jitter.html for an example
                 */
                L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

                this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

                this._loadTile(tile, tilePoint);

                if (tile.parentNode !== this._tileContainer) {
                    container.appendChild(tile);
                }
            },

            _getZoomForUrl: function () {

                var options = this.options,
                    zoom = this._map.getZoom();

                if (options.zoomReverse) {
                    zoom = options.maxZoom - zoom;
                }

                zoom += options.zoomOffset;

                return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
            },

            _getTilePos: function (tilePoint) {
                var origin = this._map.getPixelOrigin(),
                    tileSize = this._getTileSize();

                return tilePoint.multiplyBy(tileSize).subtract(origin);
            },

            // image-specific code (override to implement e.g. Canvas or SVG tile layer)

            getTileUrl: function (tilePoint) {
                return L.Util.template(this._url, L.extend({
                    s: this._getSubdomain(tilePoint),
                    z: tilePoint.z,
                    x: tilePoint.x,
                    y: tilePoint.y
                }, this.options));
            },

            _getWrapTileNum: function () {
                var crs = this._map.options.crs,
                    size = crs.getSize(this._map.getZoom());
                return size.divideBy(this._getTileSize())._floor();
            },

            _adjustTilePoint: function (tilePoint) {

                var limit = this._getWrapTileNum();

                // wrap tile coordinates
                if (!this.options.continuousWorld && !this.options.noWrap) {
                    tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
                }

                if (this.options.tms) {
                    tilePoint.y = limit.y - tilePoint.y - 1;
                }

                tilePoint.z = this._getZoomForUrl();
            },

            _getSubdomain: function (tilePoint) {
                var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
                return this.options.subdomains[index];
            },

            _getTile: function () {
                if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                    var tile = this._unusedTiles.pop();
                    this._resetTile(tile);
                    return tile;
                }
                return this._createTile();
            },

            // Override if data stored on a tile needs to be cleaned up before reuse
            _resetTile: function (/*tile*/) {},

            _createTile: function () {
                var tile = L.DomUtil.create('img', 'leaflet-tile');
                tile.style.width = tile.style.height = this._getTileSize() + 'px';
                tile.galleryimg = 'no';

                tile.onselectstart = tile.onmousemove = L.Util.falseFn;

                if (L.Browser.ielt9 && this.options.opacity !== undefined) {
                    L.DomUtil.setOpacity(tile, this.options.opacity);
                }
                // without this hack, tiles disappear after zoom on Chrome for Android
                // https://github.com/Leaflet/Leaflet/issues/2078
                if (L.Browser.mobileWebkit3d) {
                    tile.style.WebkitBackfaceVisibility = 'hidden';
                }
                return tile;
            },

            _loadTile: function (tile, tilePoint) {
                tile._layer  = this;
                tile.onload  = this._tileOnLoad;
                tile.onerror = this._tileOnError;

                this._adjustTilePoint(tilePoint);
                tile.src     = this.getTileUrl(tilePoint);

                this.fire('tileloadstart', {
                    tile: tile,
                    url: tile.src
                });
            },

            _tileLoaded: function () {
                this._tilesToLoad--;

                if (this._animated) {
                    L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
                }

                if (!this._tilesToLoad) {
                    this.fire('load');

                    if (this._animated) {
                        // clear scaled tiles after all new tiles are loaded (for performance)
                        clearTimeout(this._clearBgBufferTimer);
                        this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
                    }
                }
            },

            _tileOnLoad: function () {
                var layer = this._layer;

                //Only if we are loading an actual image
                if (this.src !== L.Util.emptyImageUrl) {
                    L.DomUtil.addClass(this, 'leaflet-tile-loaded');

                    layer.fire('tileload', {
                        tile: this,
                        url: this.src
                    });
                }

                layer._tileLoaded();
            },

            _tileOnError: function () {
                var layer = this._layer;

                layer.fire('tileerror', {
                    tile: this,
                    url: this.src
                });

                var newUrl = layer.options.errorTileUrl;
                if (newUrl) {
                    this.src = newUrl;
                }

                layer._tileLoaded();
            }
        });

        L.tileLayer = function (url, options) {
            return new L.TileLayer(url, options);
        };


        /*
         * L.TileLayer.WMS is used for putting WMS tile layers on the map.
         */

        L.TileLayer.WMS = L.TileLayer.extend({

            defaultWmsParams: {
                service: 'WMS',
                request: 'GetMap',
                version: '1.1.1',
                layers: '',
                styles: '',
                format: 'image/jpeg',
                transparent: false
            },

            initialize: function (url, options) { // (String, Object)

                this._url = url;

                var wmsParams = L.extend({}, this.defaultWmsParams),
                    tileSize = options.tileSize || this.options.tileSize;

                if (options.detectRetina && L.Browser.retina) {
                    wmsParams.width = wmsParams.height = tileSize * 2;
                } else {
                    wmsParams.width = wmsParams.height = tileSize;
                }

                for (var i in options) {
                    // all keys that are not TileLayer options go to WMS params
                    if (!this.options.hasOwnProperty(i) && i !== 'crs') {
                        wmsParams[i] = options[i];
                    }
                }

                this.wmsParams = wmsParams;

                L.setOptions(this, options);
            },

            onAdd: function (map) {

                this._crs = this.options.crs || map.options.crs;

                this._wmsVersion = parseFloat(this.wmsParams.version);

                var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
                this.wmsParams[projectionKey] = this._crs.code;

                L.TileLayer.prototype.onAdd.call(this, map);
            },

            getTileUrl: function (tilePoint) { // (Point, Number) -> String

                var map = this._map,
                    tileSize = this.options.tileSize,

                    nwPoint = tilePoint.multiplyBy(tileSize),
                    sePoint = nwPoint.add([tileSize, tileSize]),

                    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
                    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
                    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
                        [se.y, nw.x, nw.y, se.x].join(',') :
                        [nw.x, se.y, se.x, nw.y].join(','),

                    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});

                return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
            },

            setParams: function (params, noRedraw) {

                L.extend(this.wmsParams, params);

                if (!noRedraw) {
                    this.redraw();
                }

                return this;
            }
        });

        L.tileLayer.wms = function (url, options) {
            return new L.TileLayer.WMS(url, options);
        };


        /*
         * L.TileLayer.Canvas is a class that you can use as a base for creating
         * dynamically drawn Canvas-based tile layers.
         */

        L.TileLayer.Canvas = L.TileLayer.extend({
            options: {
                async: false
            },

            initialize: function (options) {
                L.setOptions(this, options);
            },

            redraw: function () {
                if (this._map) {
                    this._reset({hard: true});
                    this._update();
                }

                for (var i in this._tiles) {
                    this._redrawTile(this._tiles[i]);
                }
                return this;
            },

            _redrawTile: function (tile) {
                this.drawTile(tile, tile._tilePoint, this._map._zoom);
            },

            _createTile: function () {
                var tile = L.DomUtil.create('canvas', 'leaflet-tile');
                tile.width = tile.height = this.options.tileSize;
                tile.onselectstart = tile.onmousemove = L.Util.falseFn;
                return tile;
            },

            _loadTile: function (tile, tilePoint) {
                tile._layer = this;
                tile._tilePoint = tilePoint;

                this._redrawTile(tile);

                if (!this.options.async) {
                    this.tileDrawn(tile);
                }
            },

            drawTile: function (/*tile, tilePoint*/) {
                // override with rendering code
            },

            tileDrawn: function (tile) {
                this._tileOnLoad.call(tile);
            }
        });


        L.tileLayer.canvas = function (options) {
            return new L.TileLayer.Canvas(options);
        };


        /*
         * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
         */

        L.ImageOverlay = L.Class.extend({
            includes: L.Mixin.Events,

            options: {
                opacity: 1
            },

            initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
                this._url = url;
                this._bounds = L.latLngBounds(bounds);

                L.setOptions(this, options);
            },

            onAdd: function (map) {
                this._map = map;

                if (!this._image) {
                    this._initImage();
                }

                map._panes.overlayPane.appendChild(this._image);

                map.on('viewreset', this._reset, this);

                if (map.options.zoomAnimation && L.Browser.any3d) {
                    map.on('zoomanim', this._animateZoom, this);
                }

                this._reset();
            },

            onRemove: function (map) {
                map.getPanes().overlayPane.removeChild(this._image);

                map.off('viewreset', this._reset, this);

                if (map.options.zoomAnimation) {
                    map.off('zoomanim', this._animateZoom, this);
                }
            },

            addTo: function (map) {
                map.addLayer(this);
                return this;
            },

            setOpacity: function (opacity) {
                this.options.opacity = opacity;
                this._updateOpacity();
                return this;
            },

            // TODO remove bringToFront/bringToBack duplication from TileLayer/Path
            bringToFront: function () {
                if (this._image) {
                    this._map._panes.overlayPane.appendChild(this._image);
                }
                return this;
            },

            bringToBack: function () {
                var pane = this._map._panes.overlayPane;
                if (this._image) {
                    pane.insertBefore(this._image, pane.firstChild);
                }
                return this;
            },

            setUrl: function (url) {
                this._url = url;
                this._image.src = this._url;
            },

            getAttribution: function () {
                return this.options.attribution;
            },

            _initImage: function () {
                this._image = L.DomUtil.create('img', 'leaflet-image-layer');

                if (this._map.options.zoomAnimation && L.Browser.any3d) {
                    L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
                } else {
                    L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
                }

                this._updateOpacity();

                //TODO createImage util method to remove duplication
                L.extend(this._image, {
                    galleryimg: 'no',
                    onselectstart: L.Util.falseFn,
                    onmousemove: L.Util.falseFn,
                    onload: L.bind(this._onImageLoad, this),
                    src: this._url
                });
            },

            _animateZoom: function (e) {
                var map = this._map,
                    image = this._image,
                    scale = map.getZoomScale(e.zoom),
                    nw = this._bounds.getNorthWest(),
                    se = this._bounds.getSouthEast(),

                    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
                    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
                    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

                image.style[L.DomUtil.TRANSFORM] =
                    L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
            },

            _reset: function () {
                var image   = this._image,
                    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);

                L.DomUtil.setPosition(image, topLeft);

                image.style.width  = size.x + 'px';
                image.style.height = size.y + 'px';
            },

            _onImageLoad: function () {
                this.fire('load');
            },

            _updateOpacity: function () {
                L.DomUtil.setOpacity(this._image, this.options.opacity);
            }
        });

        L.imageOverlay = function (url, bounds, options) {
            return new L.ImageOverlay(url, bounds, options);
        };


        /*
         * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
         */

        L.Icon = L.Class.extend({
            options: {
                /*
                 iconUrl: (String) (required)
                 iconRetinaUrl: (String) (optional, used for retina devices if detected)
                 iconSize: (Point) (can be set through CSS)
                 iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
                 popupAnchor: (Point) (if not specified, popup opens in the anchor point)
                 shadowUrl: (String) (no shadow by default)
                 shadowRetinaUrl: (String) (optional, used for retina devices if detected)
                 shadowSize: (Point)
                 shadowAnchor: (Point)
                 */
                className: ''
            },

            initialize: function (options) {
                L.setOptions(this, options);
            },

            createIcon: function (oldIcon) {
                return this._createIcon('icon', oldIcon);
            },

            createShadow: function (oldIcon) {
                return this._createIcon('shadow', oldIcon);
            },

            _createIcon: function (name, oldIcon) {
                var src = this._getIconUrl(name);

                if (!src) {
                    if (name === 'icon') {
                        throw new Error('iconUrl not set in Icon options (see the docs).');
                    }
                    return null;
                }

                var img;
                if (!oldIcon || oldIcon.tagName !== 'IMG') {
                    img = this._createImg(src);
                } else {
                    img = this._createImg(src, oldIcon);
                }
                this._setIconStyles(img, name);

                return img;
            },

            _setIconStyles: function (img, name) {
                var options = this.options,
                    size = L.point(options[name + 'Size']),
                    anchor;

                if (name === 'shadow') {
                    anchor = L.point(options.shadowAnchor || options.iconAnchor);
                } else {
                    anchor = L.point(options.iconAnchor);
                }

                if (!anchor && size) {
                    anchor = size.divideBy(2, true);
                }

                img.className = 'leaflet-marker-' + name + ' ' + options.className;

                if (anchor) {
                    img.style.marginLeft = (-anchor.x) + 'px';
                    img.style.marginTop  = (-anchor.y) + 'px';
                }

                if (size) {
                    img.style.width  = size.x + 'px';
                    img.style.height = size.y + 'px';
                }
            },

            _createImg: function (src, el) {
                el = el || document.createElement('img');
                el.src = src;
                return el;
            },

            _getIconUrl: function (name) {
                if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
                    return this.options[name + 'RetinaUrl'];
                }
                return this.options[name + 'Url'];
            }
        });

        L.icon = function (options) {
            return new L.Icon(options);
        };


        /*
         * L.Icon.Default is the blue marker icon used by default in Leaflet.
         */

        L.Icon.Default = L.Icon.extend({

            options: {
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],

                shadowSize: [41, 41]
            },

            _getIconUrl: function (name) {
                var key = name + 'Url';

                if (this.options[key]) {
                    return this.options[key];
                }

                if (L.Browser.retina && name === 'icon') {
                    name += '-2x';
                }

                var path = L.Icon.Default.imagePath;

                if (!path) {
                    throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
                }

                return path + '/marker-' + name + '.png';
            }
        });

        L.Icon.Default.imagePath = (function () {
            var scripts = document.getElementsByTagName('script'),
                leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

            var i, len, src, matches, path;

            for (i = 0, len = scripts.length; i < len; i++) {
                src = scripts[i].src;
                matches = src.match(leafletRe);

                if (matches) {
                    path = src.split(leafletRe)[0];
                    return (path ? path + '/' : '') + 'images';
                }
            }
        }());


        /*
         * L.Marker is used to display clickable/draggable icons on the map.
         */

        L.Marker = L.Class.extend({

            includes: L.Mixin.Events,

            options: {
                icon: new L.Icon.Default(),
                title: '',
                alt: '',
                clickable: true,
                draggable: false,
                keyboard: true,
                zIndexOffset: 0,
                opacity: 1,
                riseOnHover: false,
                riseOffset: 250
            },

            initialize: function (latlng, options) {
                L.setOptions(this, options);
                this._latlng = L.latLng(latlng);
            },

            onAdd: function (map) {
                this._map = map;

                map.on('viewreset', this.update, this);

                this._initIcon();
                this.update();
                this.fire('add');

                if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
                    map.on('zoomanim', this._animateZoom, this);
                }
            },

            addTo: function (map) {
                map.addLayer(this);
                return this;
            },

            onRemove: function (map) {
                if (this.dragging) {
                    this.dragging.disable();
                }

                this._removeIcon();
                this._removeShadow();

                this.fire('remove');

                map.off({
                    'viewreset': this.update,
                    'zoomanim': this._animateZoom
                }, this);

                this._map = null;
            },

            getLatLng: function () {
                return this._latlng;
            },

            setLatLng: function (latlng) {
                this._latlng = L.latLng(latlng);

                this.update();

                return this.fire('move', { latlng: this._latlng });
            },

            setZIndexOffset: function (offset) {
                this.options.zIndexOffset = offset;
                this.update();

                return this;
            },

            setIcon: function (icon) {

                this.options.icon = icon;

                if (this._map) {
                    this._initIcon();
                    this.update();
                }

                if (this._popup) {
                    this.bindPopup(this._popup);
                }

                return this;
            },

            update: function () {
                if (this._icon) {
                    this._setPos(this._map.latLngToLayerPoint(this._latlng).round());
                }
                return this;
            },

            _initIcon: function () {
                var options = this.options,
                    map = this._map,
                    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
                    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

                var icon = options.icon.createIcon(this._icon),
                    addIcon = false;

                // if we're not reusing the icon, remove the old one and init new one
                if (icon !== this._icon) {
                    if (this._icon) {
                        this._removeIcon();
                    }
                    addIcon = true;

                    if (options.title) {
                        icon.title = options.title;
                    }

                    if (options.alt) {
                        icon.alt = options.alt;
                    }
                }

                L.DomUtil.addClass(icon, classToAdd);

                if (options.keyboard) {
                    icon.tabIndex = '0';
                }

                this._icon = icon;

                this._initInteraction();

                if (options.riseOnHover) {
                    L.DomEvent
                        .on(icon, 'mouseover', this._bringToFront, this)
                        .on(icon, 'mouseout', this._resetZIndex, this);
                }

                var newShadow = options.icon.createShadow(this._shadow),
                    addShadow = false;

                if (newShadow !== this._shadow) {
                    this._removeShadow();
                    addShadow = true;
                }

                if (newShadow) {
                    L.DomUtil.addClass(newShadow, classToAdd);
                }
                this._shadow = newShadow;


                if (options.opacity < 1) {
                    this._updateOpacity();
                }


                var panes = this._map._panes;

                if (addIcon) {
                    panes.markerPane.appendChild(this._icon);
                }

                if (newShadow && addShadow) {
                    panes.shadowPane.appendChild(this._shadow);
                }
            },

            _removeIcon: function () {
                if (this.options.riseOnHover) {
                    L.DomEvent
                        .off(this._icon, 'mouseover', this._bringToFront)
                        .off(this._icon, 'mouseout', this._resetZIndex);
                }

                this._map._panes.markerPane.removeChild(this._icon);

                this._icon = null;
            },

            _removeShadow: function () {
                if (this._shadow) {
                    this._map._panes.shadowPane.removeChild(this._shadow);
                }
                this._shadow = null;
            },

            _setPos: function (pos) {
                L.DomUtil.setPosition(this._icon, pos);

                if (this._shadow) {
                    L.DomUtil.setPosition(this._shadow, pos);
                }

                this._zIndex = pos.y + this.options.zIndexOffset;

                this._resetZIndex();
            },

            _updateZIndex: function (offset) {
                this._icon.style.zIndex = this._zIndex + offset;
            },

            _animateZoom: function (opt) {
                var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

                this._setPos(pos);
            },

            _initInteraction: function () {

                if (!this.options.clickable) { return; }

                // TODO refactor into something shared with Map/Path/etc. to DRY it up

                var icon = this._icon,
                    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];

                L.DomUtil.addClass(icon, 'leaflet-clickable');
                L.DomEvent.on(icon, 'click', this._onMouseClick, this);
                L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);

                for (var i = 0; i < events.length; i++) {
                    L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
                }

                if (L.Handler.MarkerDrag) {
                    this.dragging = new L.Handler.MarkerDrag(this);

                    if (this.options.draggable) {
                        this.dragging.enable();
                    }
                }
            },

            _onMouseClick: function (e) {
                var wasDragged = this.dragging && this.dragging.moved();

                if (this.hasEventListeners(e.type) || wasDragged) {
                    L.DomEvent.stopPropagation(e);
                }

                if (wasDragged) { return; }

                if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }

                this.fire(e.type, {
                    originalEvent: e,
                    latlng: this._latlng
                });
            },

            _onKeyPress: function (e) {
                if (e.keyCode === 13) {
                    this.fire('click', {
                        originalEvent: e,
                        latlng: this._latlng
                    });
                }
            },

            _fireMouseEvent: function (e) {

                this.fire(e.type, {
                    originalEvent: e,
                    latlng: this._latlng
                });

                // TODO proper custom event propagation
                // this line will always be called if marker is in a FeatureGroup
                if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
                    L.DomEvent.preventDefault(e);
                }
                if (e.type !== 'mousedown') {
                    L.DomEvent.stopPropagation(e);
                } else {
                    L.DomEvent.preventDefault(e);
                }
            },

            setOpacity: function (opacity) {
                this.options.opacity = opacity;
                if (this._map) {
                    this._updateOpacity();
                }

                return this;
            },

            _updateOpacity: function () {
                L.DomUtil.setOpacity(this._icon, this.options.opacity);
                if (this._shadow) {
                    L.DomUtil.setOpacity(this._shadow, this.options.opacity);
                }
            },

            _bringToFront: function () {
                this._updateZIndex(this.options.riseOffset);
            },

            _resetZIndex: function () {
                this._updateZIndex(0);
            }
        });

        L.marker = function (latlng, options) {
            return new L.Marker(latlng, options);
        };


        /*
         * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
         * to use with L.Marker.
         */

        L.DivIcon = L.Icon.extend({
            options: {
                iconSize: [12, 12], // also can be set through CSS
                /*
                 iconAnchor: (Point)
                 popupAnchor: (Point)
                 html: (String)
                 bgPos: (Point)
                 */
                className: 'leaflet-div-icon',
                html: false
            },

            createIcon: function (oldIcon) {
                var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
                    options = this.options;

                if (options.html !== false) {
                    div.innerHTML = options.html;
                } else {
                    div.innerHTML = '';
                }

                if (options.bgPos) {
                    div.style.backgroundPosition =
                        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
                }

                this._setIconStyles(div, 'icon');
                return div;
            },

            createShadow: function () {
                return null;
            }
        });

        L.divIcon = function (options) {
            return new L.DivIcon(options);
        };


        /*
         * L.Popup is used for displaying popups on the map.
         */

        L.Map.mergeOptions({
            closePopupOnClick: true
        });

        L.Popup = L.Class.extend({
            includes: L.Mixin.Events,

            options: {
                minWidth: 50,
                maxWidth: 300,
                // maxHeight: null,
                autoPan: true,
                closeButton: true,
                offset: [0, 7],
                autoPanPadding: [5, 5],
                // autoPanPaddingTopLeft: null,
                // autoPanPaddingBottomRight: null,
                keepInView: false,
                className: '',
                zoomAnimation: true
            },

            initialize: function (options, source) {
                L.setOptions(this, options);

                this._source = source;
                this._animated = L.Browser.any3d && this.options.zoomAnimation;
                this._isOpen = false;
            },

            onAdd: function (map) {
                this._map = map;

                if (!this._container) {
                    this._initLayout();
                }

                var animFade = map.options.fadeAnimation;

                if (animFade) {
                    L.DomUtil.setOpacity(this._container, 0);
                }
                map._panes.popupPane.appendChild(this._container);

                map.on(this._getEvents(), this);

                this.update();

                if (animFade) {
                    L.DomUtil.setOpacity(this._container, 1);
                }

                this.fire('open');

                map.fire('popupopen', {popup: this});

                if (this._source) {
                    this._source.fire('popupopen', {popup: this});
                }
            },

            addTo: function (map) {
                map.addLayer(this);
                return this;
            },

            openOn: function (map) {
                map.openPopup(this);
                return this;
            },

            onRemove: function (map) {
                map._panes.popupPane.removeChild(this._container);

                L.Util.falseFn(this._container.offsetWidth); // force reflow

                map.off(this._getEvents(), this);

                if (map.options.fadeAnimation) {
                    L.DomUtil.setOpacity(this._container, 0);
                }

                this._map = null;

                this.fire('close');

                map.fire('popupclose', {popup: this});

                if (this._source) {
                    this._source.fire('popupclose', {popup: this});
                }
            },

            getLatLng: function () {
                return this._latlng;
            },

            setLatLng: function (latlng) {
                this._latlng = L.latLng(latlng);
                if (this._map) {
                    this._updatePosition();
                    this._adjustPan();
                }
                return this;
            },

            getContent: function () {
                return this._content;
            },

            setContent: function (content) {
                this._content = content;
                this.update();
                return this;
            },

            update: function () {
                if (!this._map) { return; }

                this._container.style.visibility = 'hidden';

                this._updateContent();
                this._updateLayout();
                this._updatePosition();

                this._container.style.visibility = '';

                this._adjustPan();
            },

            _getEvents: function () {
                var events = {
                    viewreset: this._updatePosition
                };

                if (this._animated) {
                    events.zoomanim = this._zoomAnimation;
                }
                if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
                    events.preclick = this._close;
                }
                if (this.options.keepInView) {
                    events.moveend = this._adjustPan;
                }

                return events;
            },

            _close: function () {
                if (this._map) {
                    this._map.closePopup(this);
                }
            },

            _initLayout: function () {
                var prefix = 'leaflet-popup',
                    containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +
                        (this._animated ? 'animated' : 'hide'),
                    container = this._container = L.DomUtil.create('div', containerClass),
                    closeButton;

                if (this.options.closeButton) {
                    closeButton = this._closeButton =
                        L.DomUtil.create('a', prefix + '-close-button', container);
                    closeButton.href = '#close';
                    closeButton.innerHTML = '&#215;';
                    L.DomEvent.disableClickPropagation(closeButton);

                    L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
                }

                var wrapper = this._wrapper =
                    L.DomUtil.create('div', prefix + '-content-wrapper', container);
                L.DomEvent.disableClickPropagation(wrapper);

                this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

                L.DomEvent.disableScrollPropagation(this._contentNode);
                L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

                this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
                this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
            },

            _updateContent: function () {
                if (!this._content) { return; }

                if (typeof this._content === 'string') {
                    this._contentNode.innerHTML = this._content;
                } else {
                    while (this._contentNode.hasChildNodes()) {
                        this._contentNode.removeChild(this._contentNode.firstChild);
                    }
                    this._contentNode.appendChild(this._content);
                }
                this.fire('contentupdate');
            },

            _updateLayout: function () {
                var container = this._contentNode,
                    style = container.style;

                style.width = '';
                style.whiteSpace = 'nowrap';

                var width = container.offsetWidth;
                width = Math.min(width, this.options.maxWidth);
                width = Math.max(width, this.options.minWidth);

                style.width = (width + 1) + 'px';
                style.whiteSpace = '';

                style.height = '';

                var height = container.offsetHeight,
                    maxHeight = this.options.maxHeight,
                    scrolledClass = 'leaflet-popup-scrolled';

                if (maxHeight && height > maxHeight) {
                    style.height = maxHeight + 'px';
                    L.DomUtil.addClass(container, scrolledClass);
                } else {
                    L.DomUtil.removeClass(container, scrolledClass);
                }

                this._containerWidth = this._container.offsetWidth;
            },

            _updatePosition: function () {
                if (!this._map) { return; }

                var pos = this._map.latLngToLayerPoint(this._latlng),
                    animated = this._animated,
                    offset = L.point(this.options.offset);

                if (animated) {
                    L.DomUtil.setPosition(this._container, pos);
                }

                this._containerBottom = -offset.y - (animated ? 0 : pos.y);
                this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);

                // bottom position the popup in case the height of the popup changes (images loading etc)
                this._container.style.bottom = this._containerBottom + 'px';
                this._container.style.left = this._containerLeft + 'px';
            },

            _zoomAnimation: function (opt) {
                var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);

                L.DomUtil.setPosition(this._container, pos);
            },

            _adjustPan: function () {
                if (!this.options.autoPan) { return; }

                var map = this._map,
                    containerHeight = this._container.offsetHeight,
                    containerWidth = this._containerWidth,

                    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

                if (this._animated) {
                    layerPos._add(L.DomUtil.getPosition(this._container));
                }

                var containerPos = map.layerPointToContainerPoint(layerPos),
                    padding = L.point(this.options.autoPanPadding),
                    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
                    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
                    size = map.getSize(),
                    dx = 0,
                    dy = 0;

                if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
                    dx = containerPos.x + containerWidth - size.x + paddingBR.x;
                }
                if (containerPos.x - dx - paddingTL.x < 0) { // left
                    dx = containerPos.x - paddingTL.x;
                }
                if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
                    dy = containerPos.y + containerHeight - size.y + paddingBR.y;
                }
                if (containerPos.y - dy - paddingTL.y < 0) { // top
                    dy = containerPos.y - paddingTL.y;
                }

                if (dx || dy) {
                    map
                        .fire('autopanstart')
                        .panBy([dx, dy]);
                }
            },

            _onCloseButtonClick: function (e) {
                this._close();
                L.DomEvent.stop(e);
            }
        });

        L.popup = function (options, source) {
            return new L.Popup(options, source);
        };


        L.Map.include({
            openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
                this.closePopup();

                if (!(popup instanceof L.Popup)) {
                    var content = popup;

                    popup = new L.Popup(options)
                        .setLatLng(latlng)
                        .setContent(content);
                }
                popup._isOpen = true;

                this._popup = popup;
                return this.addLayer(popup);
            },

            closePopup: function (popup) {
                if (!popup || popup === this._popup) {
                    popup = this._popup;
                    this._popup = null;
                }
                if (popup) {
                    this.removeLayer(popup);
                    popup._isOpen = false;
                }
                return this;
            }
        });


        /*
         * Popup extension to L.Marker, adding popup-related methods.
         */

        L.Marker.include({
            openPopup: function () {
                if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
                    this._popup.setLatLng(this._latlng);
                    this._map.openPopup(this._popup);
                }

                return this;
            },

            closePopup: function () {
                if (this._popup) {
                    this._popup._close();
                }
                return this;
            },

            togglePopup: function () {
                if (this._popup) {
                    if (this._popup._isOpen) {
                        this.closePopup();
                    } else {
                        this.openPopup();
                    }
                }
                return this;
            },

            bindPopup: function (content, options) {
                var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);

                anchor = anchor.add(L.Popup.prototype.options.offset);

                if (options && options.offset) {
                    anchor = anchor.add(options.offset);
                }

                options = L.extend({offset: anchor}, options);

                if (!this._popupHandlersAdded) {
                    this
                        .on('click', this.togglePopup, this)
                        .on('remove', this.closePopup, this)
                        .on('move', this._movePopup, this);
                    this._popupHandlersAdded = true;
                }

                if (content instanceof L.Popup) {
                    L.setOptions(content, options);
                    this._popup = content;
                    content._source = this;
                } else {
                    this._popup = new L.Popup(options, this)
                        .setContent(content);
                }

                return this;
            },

            setPopupContent: function (content) {
                if (this._popup) {
                    this._popup.setContent(content);
                }
                return this;
            },

            unbindPopup: function () {
                if (this._popup) {
                    this._popup = null;
                    this
                        .off('click', this.togglePopup, this)
                        .off('remove', this.closePopup, this)
                        .off('move', this._movePopup, this);
                    this._popupHandlersAdded = false;
                }
                return this;
            },

            getPopup: function () {
                return this._popup;
            },

            _movePopup: function (e) {
                this._popup.setLatLng(e.latlng);
            }
        });


        /*
         * L.LayerGroup is a class to combine several layers into one so that
         * you can manipulate the group (e.g. add/remove it) as one layer.
         */

        L.LayerGroup = L.Class.extend({
            initialize: function (layers) {
                this._layers = {};

                var i, len;

                if (layers) {
                    for (i = 0, len = layers.length; i < len; i++) {
                        this.addLayer(layers[i]);
                    }
                }
            },

            addLayer: function (layer) {
                var id = this.getLayerId(layer);

                this._layers[id] = layer;

                if (this._map) {
                    this._map.addLayer(layer);
                }

                return this;
            },

            removeLayer: function (layer) {
                var id = layer in this._layers ? layer : this.getLayerId(layer);

                if (this._map && this._layers[id]) {
                    this._map.removeLayer(this._layers[id]);
                }

                delete this._layers[id];

                return this;
            },

            hasLayer: function (layer) {
                if (!layer) { return false; }

                return (layer in this._layers || this.getLayerId(layer) in this._layers);
            },

            clearLayers: function () {
                this.eachLayer(this.removeLayer, this);
                return this;
            },

            invoke: function (methodName) {
                var args = Array.prototype.slice.call(arguments, 1),
                    i, layer;

                for (i in this._layers) {
                    layer = this._layers[i];

                    if (layer[methodName]) {
                        layer[methodName].apply(layer, args);
                    }
                }

                return this;
            },

            onAdd: function (map) {
                this._map = map;
                this.eachLayer(map.addLayer, map);
            },

            onRemove: function (map) {
                this.eachLayer(map.removeLayer, map);
                this._map = null;
            },

            addTo: function (map) {
                map.addLayer(this);
                return this;
            },

            eachLayer: function (method, context) {
                for (var i in this._layers) {
                    method.call(context, this._layers[i]);
                }
                return this;
            },

            getLayer: function (id) {
                return this._layers[id];
            },

            getLayers: function () {
                var layers = [];

                for (var i in this._layers) {
                    layers.push(this._layers[i]);
                }
                return layers;
            },

            setZIndex: function (zIndex) {
                return this.invoke('setZIndex', zIndex);
            },

            getLayerId: function (layer) {
                return L.stamp(layer);
            }
        });

        L.layerGroup = function (layers) {
            return new L.LayerGroup(layers);
        };


        /*
         * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
         * shared between a group of interactive layers (like vectors or markers).
         */

        L.FeatureGroup = L.LayerGroup.extend({
            includes: L.Mixin.Events,

            statics: {
                EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'
            },

            addLayer: function (layer) {
                if (this.hasLayer(layer)) {
                    return this;
                }

                if ('on' in layer) {
                    layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
                }

                L.LayerGroup.prototype.addLayer.call(this, layer);

                if (this._popupContent && layer.bindPopup) {
                    layer.bindPopup(this._popupContent, this._popupOptions);
                }

                return this.fire('layeradd', {layer: layer});
            },

            removeLayer: function (layer) {
                if (!this.hasLayer(layer)) {
                    return this;
                }
                if (layer in this._layers) {
                    layer = this._layers[layer];
                }

                if ('off' in layer) {
                    layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);
                }

                L.LayerGroup.prototype.removeLayer.call(this, layer);

                if (this._popupContent) {
                    this.invoke('unbindPopup');
                }

                return this.fire('layerremove', {layer: layer});
            },

            bindPopup: function (content, options) {
                this._popupContent = content;
                this._popupOptions = options;
                return this.invoke('bindPopup', content, options);
            },

            openPopup: function (latlng) {
                // open popup on the first layer
                for (var id in this._layers) {
                    this._layers[id].openPopup(latlng);
                    break;
                }
                return this;
            },

            setStyle: function (style) {
                return this.invoke('setStyle', style);
            },

            bringToFront: function () {
                return this.invoke('bringToFront');
            },

            bringToBack: function () {
                return this.invoke('bringToBack');
            },

            getBounds: function () {
                var bounds = new L.LatLngBounds();

                this.eachLayer(function (layer) {
                    bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
                });

                return bounds;
            },

            _propagateEvent: function (e) {
                e = L.extend({
                    layer: e.target,
                    target: this
                }, e);
                this.fire(e.type, e);
            }
        });

        L.featureGroup = function (layers) {
            return new L.FeatureGroup(layers);
        };


        /*
         * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
         */

        L.Path = L.Class.extend({
            includes: [L.Mixin.Events],

            statics: {
                // how much to extend the clip area around the map view
                // (relative to its size, e.g. 0.5 is half the screen in each direction)
                // set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
                CLIP_PADDING: (function () {
                    var max = L.Browser.mobile ? 1280 : 2000,
                        target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
                    return Math.max(0, Math.min(0.5, target));
                })()
            },

            options: {
                stroke: true,
                color: '#0033ff',
                dashArray: null,
                lineCap: null,
                lineJoin: null,
                weight: 5,
                opacity: 0.5,

                fill: false,
                fillColor: null, //same as color by default
                fillOpacity: 0.2,

                clickable: true
            },

            initialize: function (options) {
                L.setOptions(this, options);
            },

            onAdd: function (map) {
                this._map = map;

                if (!this._container) {
                    this._initElements();
                    this._initEvents();
                }

                this.projectLatlngs();
                this._updatePath();

                if (this._container) {
                    this._map._pathRoot.appendChild(this._container);
                }

                this.fire('add');

                map.on({
                    'viewreset': this.projectLatlngs,
                    'moveend': this._updatePath
                }, this);
            },

            addTo: function (map) {
                map.addLayer(this);
                return this;
            },

            onRemove: function (map) {
                map._pathRoot.removeChild(this._container);

                // Need to fire remove event before we set _map to null as the event hooks might need the object
                this.fire('remove');
                this._map = null;

                if (L.Browser.vml) {
                    this._container = null;
                    this._stroke = null;
                    this._fill = null;
                }

                map.off({
                    'viewreset': this.projectLatlngs,
                    'moveend': this._updatePath
                }, this);
            },

            projectLatlngs: function () {
                // do all projection stuff here
            },

            setStyle: function (style) {
                L.setOptions(this, style);

                if (this._container) {
                    this._updateStyle();
                }

                return this;
            },

            redraw: function () {
                if (this._map) {
                    this.projectLatlngs();
                    this._updatePath();
                }
                return this;
            }
        });

        L.Map.include({
            _updatePathViewport: function () {
                var p = L.Path.CLIP_PADDING,
                    size = this.getSize(),
                    panePos = L.DomUtil.getPosition(this._mapPane),
                    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
                    max = min.add(size.multiplyBy(1 + p * 2)._round());

                this._pathViewport = new L.Bounds(min, max);
            }
        });


        /*
         * Extends L.Path with SVG-specific rendering code.
         */

        L.Path.SVG_NS = 'http://www.w3.org/2000/svg';

        L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);

        L.Path = L.Path.extend({
            statics: {
                SVG: L.Browser.svg
            },

            bringToFront: function () {
                var root = this._map._pathRoot,
                    path = this._container;

                if (path && root.lastChild !== path) {
                    root.appendChild(path);
                }
                return this;
            },

            bringToBack: function () {
                var root = this._map._pathRoot,
                    path = this._container,
                    first = root.firstChild;

                if (path && first !== path) {
                    root.insertBefore(path, first);
                }
                return this;
            },

            getPathString: function () {
                // form path string here
            },

            _createElement: function (name) {
                return document.createElementNS(L.Path.SVG_NS, name);
            },

            _initElements: function () {
                this._map._initPathRoot();
                this._initPath();
                this._initStyle();
            },

            _initPath: function () {
                this._container = this._createElement('g');

                this._path = this._createElement('path');

                if (this.options.className) {
                    L.DomUtil.addClass(this._path, this.options.className);
                }

                this._container.appendChild(this._path);
            },

            _initStyle: function () {
                if (this.options.stroke) {
                    this._path.setAttribute('stroke-linejoin', 'round');
                    this._path.setAttribute('stroke-linecap', 'round');
                }
                if (this.options.fill) {
                    this._path.setAttribute('fill-rule', 'evenodd');
                }
                if (this.options.pointerEvents) {
                    this._path.setAttribute('pointer-events', this.options.pointerEvents);
                }
                if (!this.options.clickable && !this.options.pointerEvents) {
                    this._path.setAttribute('pointer-events', 'none');
                }
                this._updateStyle();
            },

            _updateStyle: function () {
                if (this.options.stroke) {
                    this._path.setAttribute('stroke', this.options.color);
                    this._path.setAttribute('stroke-opacity', this.options.opacity);
                    this._path.setAttribute('stroke-width', this.options.weight);
                    if (this.options.dashArray) {
                        this._path.setAttribute('stroke-dasharray', this.options.dashArray);
                    } else {
                        this._path.removeAttribute('stroke-dasharray');
                    }
                    if (this.options.lineCap) {
                        this._path.setAttribute('stroke-linecap', this.options.lineCap);
                    }
                    if (this.options.lineJoin) {
                        this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
                    }
                } else {
                    this._path.setAttribute('stroke', 'none');
                }
                if (this.options.fill) {
                    this._path.setAttribute('fill', this.options.fillColor || this.options.color);
                    this._path.setAttribute('fill-opacity', this.options.fillOpacity);
                } else {
                    this._path.setAttribute('fill', 'none');
                }
            },

            _updatePath: function () {
                var str = this.getPathString();
                if (!str) {
                    // fix webkit empty string parsing bug
                    str = 'M0 0';
                }
                this._path.setAttribute('d', str);
            },

            // TODO remove duplication with L.Map
            _initEvents: function () {
                if (this.options.clickable) {
                    if (L.Browser.svg || !L.Browser.vml) {
                        L.DomUtil.addClass(this._path, 'leaflet-clickable');
                    }

                    L.DomEvent.on(this._container, 'click', this._onMouseClick, this);

                    var events = ['dblclick', 'mousedown', 'mouseover',
                        'mouseout', 'mousemove', 'contextmenu'];
                    for (var i = 0; i < events.length; i++) {
                        L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
                    }
                }
            },

            _onMouseClick: function (e) {
                if (this._map.dragging && this._map.dragging.moved()) { return; }

                this._fireMouseEvent(e);
            },

            _fireMouseEvent: function (e) {
                if (!this._map || !this.hasEventListeners(e.type)) { return; }

                var map = this._map,
                    containerPoint = map.mouseEventToContainerPoint(e),
                    layerPoint = map.containerPointToLayerPoint(containerPoint),
                    latlng = map.layerPointToLatLng(layerPoint);

                this.fire(e.type, {
                    latlng: latlng,
                    layerPoint: layerPoint,
                    containerPoint: containerPoint,
                    originalEvent: e
                });

                if (e.type === 'contextmenu') {
                    L.DomEvent.preventDefault(e);
                }
                if (e.type !== 'mousemove') {
                    L.DomEvent.stopPropagation(e);
                }
            }
        });

        L.Map.include({
            _initPathRoot: function () {
                if (!this._pathRoot) {
                    this._pathRoot = L.Path.prototype._createElement('svg');
                    this._panes.overlayPane.appendChild(this._pathRoot);

                    if (this.options.zoomAnimation && L.Browser.any3d) {
                        L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');

                        this.on({
                            'zoomanim': this._animatePathZoom,
                            'zoomend': this._endPathZoom
                        });
                    } else {
                        L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
                    }

                    this.on('moveend', this._updateSvgViewport);
                    this._updateSvgViewport();
                }
            },

            _animatePathZoom: function (e) {
                var scale = this.getZoomScale(e.zoom),
                    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);

                this._pathRoot.style[L.DomUtil.TRANSFORM] =
                    L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';

                this._pathZooming = true;
            },

            _endPathZoom: function () {
                this._pathZooming = false;
            },

            _updateSvgViewport: function () {

                if (this._pathZooming) {
                    // Do not update SVGs while a zoom animation is going on otherwise the animation will break.
                    // When the zoom animation ends we will be updated again anyway
                    // This fixes the case where you do a momentum move and zoom while the move is still ongoing.
                    return;
                }

                this._updatePathViewport();

                var vp = this._pathViewport,
                    min = vp.min,
                    max = vp.max,
                    width = max.x - min.x,
                    height = max.y - min.y,
                    root = this._pathRoot,
                    pane = this._panes.overlayPane;

                // Hack to make flicker on drag end on mobile webkit less irritating
                if (L.Browser.mobileWebkit) {
                    pane.removeChild(root);
                }

                L.DomUtil.setPosition(root, min);
                root.setAttribute('width', width);
                root.setAttribute('height', height);
                root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));

                if (L.Browser.mobileWebkit) {
                    pane.appendChild(root);
                }
            }
        });


        /*
         * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
         */

        L.Path.include({

            bindPopup: function (content, options) {

                if (content instanceof L.Popup) {
                    this._popup = content;
                } else {
                    if (!this._popup || options) {
                        this._popup = new L.Popup(options, this);
                    }
                    this._popup.setContent(content);
                }

                if (!this._popupHandlersAdded) {
                    this
                        .on('click', this._openPopup, this)
                        .on('remove', this.closePopup, this);

                    this._popupHandlersAdded = true;
                }

                return this;
            },

            unbindPopup: function () {
                if (this._popup) {
                    this._popup = null;
                    this
                        .off('click', this._openPopup)
                        .off('remove', this.closePopup);

                    this._popupHandlersAdded = false;
                }
                return this;
            },

            openPopup: function (latlng) {

                if (this._popup) {
                    // open the popup from one of the path's points if not specified
                    latlng = latlng || this._latlng ||
                        this._latlngs[Math.floor(this._latlngs.length / 2)];

                    this._openPopup({latlng: latlng});
                }

                return this;
            },

            closePopup: function () {
                if (this._popup) {
                    this._popup._close();
                }
                return this;
            },

            _openPopup: function (e) {
                this._popup.setLatLng(e.latlng);
                this._map.openPopup(this._popup);
            }
        });


        /*
         * Vector rendering for IE6-8 through VML.
         * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
         */

        L.Browser.vml = !L.Browser.svg && (function () {
                try {
                    var div = document.createElement('div');
                    div.innerHTML = '<v:shape adj="1"/>';

                    var shape = div.firstChild;
                    shape.style.behavior = 'url(#default#VML)';

                    return shape && (typeof shape.adj === 'object');

                } catch (e) {
                    return false;
                }
            }());

        L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
            statics: {
                VML: true,
                CLIP_PADDING: 0.02
            },

            _createElement: (function () {
                try {
                    document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
                    return function (name) {
                        return document.createElement('<lvml:' + name + ' class="lvml">');
                    };
                } catch (e) {
                    return function (name) {
                        return document.createElement(
                            '<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                    };
                }
            }()),

            _initPath: function () {
                var container = this._container = this._createElement('shape');

                L.DomUtil.addClass(container, 'leaflet-vml-shape' +
                    (this.options.className ? ' ' + this.options.className : ''));

                if (this.options.clickable) {
                    L.DomUtil.addClass(container, 'leaflet-clickable');
                }

                container.coordsize = '1 1';

                this._path = this._createElement('path');
                container.appendChild(this._path);

                this._map._pathRoot.appendChild(container);
            },

            _initStyle: function () {
                this._updateStyle();
            },

            _updateStyle: function () {
                var stroke = this._stroke,
                    fill = this._fill,
                    options = this.options,
                    container = this._container;

                container.stroked = options.stroke;
                container.filled = options.fill;

                if (options.stroke) {
                    if (!stroke) {
                        stroke = this._stroke = this._createElement('stroke');
                        stroke.endcap = 'round';
                        container.appendChild(stroke);
                    }
                    stroke.weight = options.weight + 'px';
                    stroke.color = options.color;
                    stroke.opacity = options.opacity;

                    if (options.dashArray) {
                        stroke.dashStyle = L.Util.isArray(options.dashArray) ?
                            options.dashArray.join(' ') :
                            options.dashArray.replace(/( *, *)/g, ' ');
                    } else {
                        stroke.dashStyle = '';
                    }
                    if (options.lineCap) {
                        stroke.endcap = options.lineCap.replace('butt', 'flat');
                    }
                    if (options.lineJoin) {
                        stroke.joinstyle = options.lineJoin;
                    }

                } else if (stroke) {
                    container.removeChild(stroke);
                    this._stroke = null;
                }

                if (options.fill) {
                    if (!fill) {
                        fill = this._fill = this._createElement('fill');
                        container.appendChild(fill);
                    }
                    fill.color = options.fillColor || options.color;
                    fill.opacity = options.fillOpacity;

                } else if (fill) {
                    container.removeChild(fill);
                    this._fill = null;
                }
            },

            _updatePath: function () {
                var style = this._container.style;

                style.display = 'none';
                this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug
                style.display = '';
            }
        });

        L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
            _initPathRoot: function () {
                if (this._pathRoot) { return; }

                var root = this._pathRoot = document.createElement('div');
                root.className = 'leaflet-vml-container';
                this._panes.overlayPane.appendChild(root);

                this.on('moveend', this._updatePathViewport);
                this._updatePathViewport();
            }
        });


        /*
         * Vector rendering for all browsers that support canvas.
         */

        L.Browser.canvas = (function () {
            return !!document.createElement('canvas').getContext;
        }());

        L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
            statics: {
                //CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
                CANVAS: true,
                SVG: false
            },

            redraw: function () {
                if (this._map) {
                    this.projectLatlngs();
                    this._requestUpdate();
                }
                return this;
            },

            setStyle: function (style) {
                L.setOptions(this, style);

                if (this._map) {
                    this._updateStyle();
                    this._requestUpdate();
                }
                return this;
            },

            onRemove: function (map) {
                map
                    .off('viewreset', this.projectLatlngs, this)
                    .off('moveend', this._updatePath, this);

                if (this.options.clickable) {
                    this._map.off('click', this._onClick, this);
                    this._map.off('mousemove', this._onMouseMove, this);
                }

                this._requestUpdate();

                this.fire('remove');
                this._map = null;
            },

            _requestUpdate: function () {
                if (this._map && !L.Path._updateRequest) {
                    L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
                }
            },

            _fireMapMoveEnd: function () {
                L.Path._updateRequest = null;
                this.fire('moveend');
            },

            _initElements: function () {
                this._map._initPathRoot();
                this._ctx = this._map._canvasCtx;
            },

            _updateStyle: function () {
                var options = this.options;

                if (options.stroke) {
                    this._ctx.lineWidth = options.weight;
                    this._ctx.strokeStyle = options.color;
                }
                if (options.fill) {
                    this._ctx.fillStyle = options.fillColor || options.color;
                }

                if (options.lineCap) {
                    this._ctx.lineCap = options.lineCap;
                }
                if (options.lineJoin) {
                    this._ctx.lineJoin = options.lineJoin;
                }
            },

            _drawPath: function () {
                var i, j, len, len2, point, drawMethod;

                this._ctx.beginPath();

                for (i = 0, len = this._parts.length; i < len; i++) {
                    for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
                        point = this._parts[i][j];
                        drawMethod = (j === 0 ? 'move' : 'line') + 'To';

                        this._ctx[drawMethod](point.x, point.y);
                    }
                    // TODO refactor ugly hack
                    if (this instanceof L.Polygon) {
                        this._ctx.closePath();
                    }
                }
            },

            _checkIfEmpty: function () {
                return !this._parts.length;
            },

            _updatePath: function () {
                if (this._checkIfEmpty()) { return; }

                var ctx = this._ctx,
                    options = this.options;

                this._drawPath();
                ctx.save();
                this._updateStyle();

                if (options.fill) {
                    ctx.globalAlpha = options.fillOpacity;
                    ctx.fill(options.fillRule || 'evenodd');
                }

                if (options.stroke) {
                    ctx.globalAlpha = options.opacity;
                    ctx.stroke();
                }

                ctx.restore();

                // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
            },

            _initEvents: function () {
                if (this.options.clickable) {
                    this._map.on('mousemove', this._onMouseMove, this);
                    this._map.on('click dblclick contextmenu', this._fireMouseEvent, this);
                }
            },

            _fireMouseEvent: function (e) {
                if (this._containsPoint(e.layerPoint)) {
                    this.fire(e.type, e);
                }
            },

            _onMouseMove: function (e) {
                if (!this._map || this._map._animatingZoom) { return; }

                // TODO don't do on each move
                if (this._containsPoint(e.layerPoint)) {
                    this._ctx.canvas.style.cursor = 'pointer';
                    this._mouseInside = true;
                    this.fire('mouseover', e);

                } else if (this._mouseInside) {
                    this._ctx.canvas.style.cursor = '';
                    this._mouseInside = false;
                    this.fire('mouseout', e);
                }
            }
        });

        L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
            _initPathRoot: function () {
                var root = this._pathRoot,
                    ctx;

                if (!root) {
                    root = this._pathRoot = document.createElement('canvas');
                    root.style.position = 'absolute';
                    ctx = this._canvasCtx = root.getContext('2d');

                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    this._panes.overlayPane.appendChild(root);

                    if (this.options.zoomAnimation) {
                        this._pathRoot.className = 'leaflet-zoom-animated';
                        this.on('zoomanim', this._animatePathZoom);
                        this.on('zoomend', this._endPathZoom);
                    }
                    this.on('moveend', this._updateCanvasViewport);
                    this._updateCanvasViewport();
                }
            },

            _updateCanvasViewport: function () {
                // don't redraw while zooming. See _updateSvgViewport for more details
                if (this._pathZooming) { return; }
                this._updatePathViewport();

                var vp = this._pathViewport,
                    min = vp.min,
                    size = vp.max.subtract(min),
                    root = this._pathRoot;

                //TODO check if this works properly on mobile webkit
                L.DomUtil.setPosition(root, min);
                root.width = size.x;
                root.height = size.y;
                root.getContext('2d').translate(-min.x, -min.y);
            }
        });


        /*
         * L.LineUtil contains different utility functions for line segments
         * and polylines (clipping, simplification, distances, etc.)
         */

        /*jshint bitwise:false */ // allow bitwise operations for this file

        L.LineUtil = {

            // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
            // Improves rendering performance dramatically by lessening the number of points to draw.

            simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {
                if (!tolerance || !points.length) {
                    return points.slice();
                }

                var sqTolerance = tolerance * tolerance;

                // stage 1: vertex reduction
                points = this._reducePoints(points, sqTolerance);

                // stage 2: Douglas-Peucker simplification
                points = this._simplifyDP(points, sqTolerance);

                return points;
            },

            // distance from a point to a segment between two points
            pointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
                return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
            },

            closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
                return this._sqClosestPointOnSegment(p, p1, p2);
            },

            // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
            _simplifyDP: function (points, sqTolerance) {

                var len = points.length,
                    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
                    markers = new ArrayConstructor(len);

                markers[0] = markers[len - 1] = 1;

                this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

                var i,
                    newPoints = [];

                for (i = 0; i < len; i++) {
                    if (markers[i]) {
                        newPoints.push(points[i]);
                    }
                }

                return newPoints;
            },

            _simplifyDPStep: function (points, markers, sqTolerance, first, last) {

                var maxSqDist = 0,
                    index, i, sqDist;

                for (i = first + 1; i <= last - 1; i++) {
                    sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

                    if (sqDist > maxSqDist) {
                        index = i;
                        maxSqDist = sqDist;
                    }
                }

                if (maxSqDist > sqTolerance) {
                    markers[index] = 1;

                    this._simplifyDPStep(points, markers, sqTolerance, first, index);
                    this._simplifyDPStep(points, markers, sqTolerance, index, last);
                }
            },

            // reduce points that are too close to each other to a single point
            _reducePoints: function (points, sqTolerance) {
                var reducedPoints = [points[0]];

                for (var i = 1, prev = 0, len = points.length; i < len; i++) {
                    if (this._sqDist(points[i], points[prev]) > sqTolerance) {
                        reducedPoints.push(points[i]);
                        prev = i;
                    }
                }
                if (prev < len - 1) {
                    reducedPoints.push(points[len - 1]);
                }
                return reducedPoints;
            },

            // Cohen-Sutherland line clipping algorithm.
            // Used to avoid rendering parts of a polyline that are not currently visible.

            clipSegment: function (a, b, bounds, useLastCode) {
                var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
                    codeB = this._getBitCode(b, bounds),

                    codeOut, p, newCode;

                // save 2nd code to avoid calculating it on the next segment
                this._lastCode = codeB;

                while (true) {
                    // if a,b is inside the clip window (trivial accept)
                    if (!(codeA | codeB)) {
                        return [a, b];
                        // if a,b is outside the clip window (trivial reject)
                    } else if (codeA & codeB) {
                        return false;
                        // other cases
                    } else {
                        codeOut = codeA || codeB;
                        p = this._getEdgeIntersection(a, b, codeOut, bounds);
                        newCode = this._getBitCode(p, bounds);

                        if (codeOut === codeA) {
                            a = p;
                            codeA = newCode;
                        } else {
                            b = p;
                            codeB = newCode;
                        }
                    }
                }
            },

            _getEdgeIntersection: function (a, b, code, bounds) {
                var dx = b.x - a.x,
                    dy = b.y - a.y,
                    min = bounds.min,
                    max = bounds.max;

                if (code & 8) { // top
                    return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
                } else if (code & 4) { // bottom
                    return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
                } else if (code & 2) { // right
                    return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
                } else if (code & 1) { // left
                    return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
                }
            },

            _getBitCode: function (/*Point*/ p, bounds) {
                var code = 0;

                if (p.x < bounds.min.x) { // left
                    code |= 1;
                } else if (p.x > bounds.max.x) { // right
                    code |= 2;
                }
                if (p.y < bounds.min.y) { // bottom
                    code |= 4;
                } else if (p.y > bounds.max.y) { // top
                    code |= 8;
                }

                return code;
            },

            // square distance (to avoid unnecessary Math.sqrt calls)
            _sqDist: function (p1, p2) {
                var dx = p2.x - p1.x,
                    dy = p2.y - p1.y;
                return dx * dx + dy * dy;
            },

            // return closest point on segment or distance to that point
            _sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
                var x = p1.x,
                    y = p1.y,
                    dx = p2.x - x,
                    dy = p2.y - y,
                    dot = dx * dx + dy * dy,
                    t;

                if (dot > 0) {
                    t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

                    if (t > 1) {
                        x = p2.x;
                        y = p2.y;
                    } else if (t > 0) {
                        x += dx * t;
                        y += dy * t;
                    }
                }

                dx = p.x - x;
                dy = p.y - y;

                return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
            }
        };


        /*
         * L.Polyline is used to display polylines on a map.
         */

        L.Polyline = L.Path.extend({
            initialize: function (latlngs, options) {
                L.Path.prototype.initialize.call(this, options);

                this._latlngs = this._convertLatLngs(latlngs);
            },

            options: {
                // how much to simplify the polyline on each zoom level
                // more = better performance and smoother look, less = more accurate
                smoothFactor: 1.0,
                noClip: false
            },

            projectLatlngs: function () {
                this._originalPoints = [];

                for (var i = 0, len = this._latlngs.length; i < len; i++) {
                    this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
                }
            },

            getPathString: function () {
                for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {
                    str += this._getPathPartStr(this._parts[i]);
                }
                return str;
            },

            getLatLngs: function () {
                return this._latlngs;
            },

            setLatLngs: function (latlngs) {
                this._latlngs = this._convertLatLngs(latlngs);
                return this.redraw();
            },

            addLatLng: function (latlng) {
                this._latlngs.push(L.latLng(latlng));
                return this.redraw();
            },

            spliceLatLngs: function () { // (Number index, Number howMany)
                var removed = [].splice.apply(this._latlngs, arguments);
                this._convertLatLngs(this._latlngs, true);
                this.redraw();
                return removed;
            },

            closestLayerPoint: function (p) {
                var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;

                for (var j = 0, jLen = parts.length; j < jLen; j++) {
                    var points = parts[j];
                    for (var i = 1, len = points.length; i < len; i++) {
                        p1 = points[i - 1];
                        p2 = points[i];
                        var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
                        if (sqDist < minDistance) {
                            minDistance = sqDist;
                            minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
                        }
                    }
                }
                if (minPoint) {
                    minPoint.distance = Math.sqrt(minDistance);
                }
                return minPoint;
            },

            getBounds: function () {
                return new L.LatLngBounds(this.getLatLngs());
            },

            _convertLatLngs: function (latlngs, overwrite) {
                var i, len, target = overwrite ? latlngs : [];

                for (i = 0, len = latlngs.length; i < len; i++) {
                    if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
                        return;
                    }
                    target[i] = L.latLng(latlngs[i]);
                }
                return target;
            },

            _initEvents: function () {
                L.Path.prototype._initEvents.call(this);
            },

            _getPathPartStr: function (points) {
                var round = L.Path.VML;

                for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {
                    p = points[j];
                    if (round) {
                        p._round();
                    }
                    str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
                }
                return str;
            },

            _clipPoints: function () {
                var points = this._originalPoints,
                    len = points.length,
                    i, k, segment;

                if (this.options.noClip) {
                    this._parts = [points];
                    return;
                }

                this._parts = [];

                var parts = this._parts,
                    vp = this._map._pathViewport,
                    lu = L.LineUtil;

                for (i = 0, k = 0; i < len - 1; i++) {
                    segment = lu.clipSegment(points[i], points[i + 1], vp, i);
                    if (!segment) {
                        continue;
                    }

                    parts[k] = parts[k] || [];
                    parts[k].push(segment[0]);

                    // if segment goes out of screen, or it's the last one, it's the end of the line part
                    if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
                        parts[k].push(segment[1]);
                        k++;
                    }
                }
            },

            // simplify each clipped part of the polyline
            _simplifyPoints: function () {
                var parts = this._parts,
                    lu = L.LineUtil;

                for (var i = 0, len = parts.length; i < len; i++) {
                    parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
                }
            },

            _updatePath: function () {
                if (!this._map) { return; }

                this._clipPoints();
                this._simplifyPoints();

                L.Path.prototype._updatePath.call(this);
            }
        });

        L.polyline = function (latlngs, options) {
            return new L.Polyline(latlngs, options);
        };


        /*
         * L.PolyUtil contains utility functions for polygons (clipping, etc.).
         */

        /*jshint bitwise:false */ // allow bitwise operations here

        L.PolyUtil = {};

        /*
         * Sutherland-Hodgeman polygon clipping algorithm.
         * Used to avoid rendering parts of a polygon that are not currently visible.
         */
        L.PolyUtil.clipPolygon = function (points, bounds) {
            var clippedPoints,
                edges = [1, 4, 2, 8],
                i, j, k,
                a, b,
                len, edge, p,
                lu = L.LineUtil;

            for (i = 0, len = points.length; i < len; i++) {
                points[i]._code = lu._getBitCode(points[i], bounds);
            }

            // for each edge (left, bottom, right, top)
            for (k = 0; k < 4; k++) {
                edge = edges[k];
                clippedPoints = [];

                for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                    a = points[i];
                    b = points[j];

                    // if a is inside the clip window
                    if (!(a._code & edge)) {
                        // if b is outside the clip window (a->b goes out of screen)
                        if (b._code & edge) {
                            p = lu._getEdgeIntersection(b, a, edge, bounds);
                            p._code = lu._getBitCode(p, bounds);
                            clippedPoints.push(p);
                        }
                        clippedPoints.push(a);

                        // else if b is inside the clip window (a->b enters the screen)
                    } else if (!(b._code & edge)) {
                        p = lu._getEdgeIntersection(b, a, edge, bounds);
                        p._code = lu._getBitCode(p, bounds);
                        clippedPoints.push(p);
                    }
                }
                points = clippedPoints;
            }

            return points;
        };


        /*
         * L.Polygon is used to display polygons on a map.
         */

        L.Polygon = L.Polyline.extend({
            options: {
                fill: true
            },

            initialize: function (latlngs, options) {
                L.Polyline.prototype.initialize.call(this, latlngs, options);
                this._initWithHoles(latlngs);
            },

            _initWithHoles: function (latlngs) {
                var i, len, hole;
                if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
                    this._latlngs = this._convertLatLngs(latlngs[0]);
                    this._holes = latlngs.slice(1);

                    for (i = 0, len = this._holes.length; i < len; i++) {
                        hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
                        if (hole[0].equals(hole[hole.length - 1])) {
                            hole.pop();
                        }
                    }
                }

                // filter out last point if its equal to the first one
                latlngs = this._latlngs;

                if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
                    latlngs.pop();
                }
            },

            projectLatlngs: function () {
                L.Polyline.prototype.projectLatlngs.call(this);

                // project polygon holes points
                // TODO move this logic to Polyline to get rid of duplication
                this._holePoints = [];

                if (!this._holes) { return; }

                var i, j, len, len2;

                for (i = 0, len = this._holes.length; i < len; i++) {
                    this._holePoints[i] = [];

                    for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
                        this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
                    }
                }
            },

            setLatLngs: function (latlngs) {
                if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
                    this._initWithHoles(latlngs);
                    return this.redraw();
                } else {
                    return L.Polyline.prototype.setLatLngs.call(this, latlngs);
                }
            },

            _clipPoints: function () {
                var points = this._originalPoints,
                    newParts = [];

                this._parts = [points].concat(this._holePoints);

                if (this.options.noClip) { return; }

                for (var i = 0, len = this._parts.length; i < len; i++) {
                    var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
                    if (clipped.length) {
                        newParts.push(clipped);
                    }
                }

                this._parts = newParts;
            },

            _getPathPartStr: function (points) {
                var str = L.Polyline.prototype._getPathPartStr.call(this, points);
                return str + (L.Browser.svg ? 'z' : 'x');
            }
        });

        L.polygon = function (latlngs, options) {
            return new L.Polygon(latlngs, options);
        };


        /*
         * Contains L.MultiPolyline and L.MultiPolygon layers.
         */

        (function () {
            function createMulti(Klass) {

                return L.FeatureGroup.extend({

                    initialize: function (latlngs, options) {
                        this._layers = {};
                        this._options = options;
                        this.setLatLngs(latlngs);
                    },

                    setLatLngs: function (latlngs) {
                        var i = 0,
                            len = latlngs.length;

                        this.eachLayer(function (layer) {
                            if (i < len) {
                                layer.setLatLngs(latlngs[i++]);
                            } else {
                                this.removeLayer(layer);
                            }
                        }, this);

                        while (i < len) {
                            this.addLayer(new Klass(latlngs[i++], this._options));
                        }

                        return this;
                    },

                    getLatLngs: function () {
                        var latlngs = [];

                        this.eachLayer(function (layer) {
                            latlngs.push(layer.getLatLngs());
                        });

                        return latlngs;
                    }
                });
            }

            L.MultiPolyline = createMulti(L.Polyline);
            L.MultiPolygon = createMulti(L.Polygon);

            L.multiPolyline = function (latlngs, options) {
                return new L.MultiPolyline(latlngs, options);
            };

            L.multiPolygon = function (latlngs, options) {
                return new L.MultiPolygon(latlngs, options);
            };
        }());


        /*
         * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
         */

        L.Rectangle = L.Polygon.extend({
            initialize: function (latLngBounds, options) {
                L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
            },

            setBounds: function (latLngBounds) {
                this.setLatLngs(this._boundsToLatLngs(latLngBounds));
            },

            _boundsToLatLngs: function (latLngBounds) {
                latLngBounds = L.latLngBounds(latLngBounds);
                return [
                    latLngBounds.getSouthWest(),
                    latLngBounds.getNorthWest(),
                    latLngBounds.getNorthEast(),
                    latLngBounds.getSouthEast()
                ];
            }
        });

        L.rectangle = function (latLngBounds, options) {
            return new L.Rectangle(latLngBounds, options);
        };


        /*
         * L.Circle is a circle overlay (with a certain radius in meters).
         */

        L.Circle = L.Path.extend({
            initialize: function (latlng, radius, options) {
                L.Path.prototype.initialize.call(this, options);

                this._latlng = L.latLng(latlng);
                this._mRadius = radius;
            },

            options: {
                fill: true
            },

            setLatLng: function (latlng) {
                this._latlng = L.latLng(latlng);
                return this.redraw();
            },

            setRadius: function (radius) {
                this._mRadius = radius;
                return this.redraw();
            },

            projectLatlngs: function () {
                var lngRadius = this._getLngRadius(),
                    latlng = this._latlng,
                    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);

                this._point = this._map.latLngToLayerPoint(latlng);
                this._radius = Math.max(this._point.x - pointLeft.x, 1);
            },

            getBounds: function () {
                var lngRadius = this._getLngRadius(),
                    latRadius = (this._mRadius / 40075017) * 360,
                    latlng = this._latlng;

                return new L.LatLngBounds(
                    [latlng.lat - latRadius, latlng.lng - lngRadius],
                    [latlng.lat + latRadius, latlng.lng + lngRadius]);
            },

            getLatLng: function () {
                return this._latlng;
            },

            getPathString: function () {
                var p = this._point,
                    r = this._radius;

                if (this._checkIfEmpty()) {
                    return '';
                }

                if (L.Browser.svg) {
                    return 'M' + p.x + ',' + (p.y - r) +
                        'A' + r + ',' + r + ',0,1,1,' +
                        (p.x - 0.1) + ',' + (p.y - r) + ' z';
                } else {
                    p._round();
                    r = Math.round(r);
                    return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
                }
            },

            getRadius: function () {
                return this._mRadius;
            },

            // TODO Earth hardcoded, move into projection code!

            _getLatRadius: function () {
                return (this._mRadius / 40075017) * 360;
            },

            _getLngRadius: function () {
                return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
            },

            _checkIfEmpty: function () {
                if (!this._map) {
                    return false;
                }
                var vp = this._map._pathViewport,
                    r = this._radius,
                    p = this._point;

                return p.x - r > vp.max.x || p.y - r > vp.max.y ||
                    p.x + r < vp.min.x || p.y + r < vp.min.y;
            }
        });

        L.circle = function (latlng, radius, options) {
            return new L.Circle(latlng, radius, options);
        };


        /*
         * L.CircleMarker is a circle overlay with a permanent pixel radius.
         */

        L.CircleMarker = L.Circle.extend({
            options: {
                radius: 10,
                weight: 2
            },

            initialize: function (latlng, options) {
                L.Circle.prototype.initialize.call(this, latlng, null, options);
                this._radius = this.options.radius;
            },

            projectLatlngs: function () {
                this._point = this._map.latLngToLayerPoint(this._latlng);
            },

            _updateStyle : function () {
                L.Circle.prototype._updateStyle.call(this);
                this.setRadius(this.options.radius);
            },

            setLatLng: function (latlng) {
                L.Circle.prototype.setLatLng.call(this, latlng);
                if (this._popup && this._popup._isOpen) {
                    this._popup.setLatLng(latlng);
                }
                return this;
            },

            setRadius: function (radius) {
                this.options.radius = this._radius = radius;
                return this.redraw();
            },

            getRadius: function () {
                return this._radius;
            }
        });

        L.circleMarker = function (latlng, options) {
            return new L.CircleMarker(latlng, options);
        };


        /*
         * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
         */

        L.Polyline.include(!L.Path.CANVAS ? {} : {
            _containsPoint: function (p, closed) {
                var i, j, k, len, len2, dist, part,
                    w = this.options.weight / 2;

                if (L.Browser.touch) {
                    w += 10; // polyline click tolerance on touch devices
                }

                for (i = 0, len = this._parts.length; i < len; i++) {
                    part = this._parts[i];
                    for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                        if (!closed && (j === 0)) {
                            continue;
                        }

                        dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

                        if (dist <= w) {
                            return true;
                        }
                    }
                }
                return false;
            }
        });


        /*
         * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
         */

        L.Polygon.include(!L.Path.CANVAS ? {} : {
            _containsPoint: function (p) {
                var inside = false,
                    part, p1, p2,
                    i, j, k,
                    len, len2;

                // TODO optimization: check if within bounds first

                if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
                    // click on polygon border
                    return true;
                }

                // ray casting algorithm for detecting if point is in polygon

                for (i = 0, len = this._parts.length; i < len; i++) {
                    part = this._parts[i];

                    for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                        p1 = part[j];
                        p2 = part[k];

                        if (((p1.y > p.y) !== (p2.y > p.y)) &&
                            (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                            inside = !inside;
                        }
                    }
                }

                return inside;
            }
        });


        /*
         * Extends L.Circle with Canvas-specific code.
         */

        L.Circle.include(!L.Path.CANVAS ? {} : {
            _drawPath: function () {
                var p = this._point;
                this._ctx.beginPath();
                this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
            },

            _containsPoint: function (p) {
                var center = this._point,
                    w2 = this.options.stroke ? this.options.weight / 2 : 0;

                return (p.distanceTo(center) <= this._radius + w2);
            }
        });


        /*
         * CircleMarker canvas specific drawing parts.
         */

        L.CircleMarker.include(!L.Path.CANVAS ? {} : {
            _updateStyle: function () {
                L.Path.prototype._updateStyle.call(this);
            }
        });


        /*
         * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
         */

        L.GeoJSON = L.FeatureGroup.extend({

            initialize: function (geojson, options) {
                L.setOptions(this, options);

                this._layers = {};

                if (geojson) {
                    this.addData(geojson);
                }
            },

            addData: function (geojson) {
                var features = L.Util.isArray(geojson) ? geojson : geojson.features,
                    i, len, feature;

                if (features) {
                    for (i = 0, len = features.length; i < len; i++) {
                        // Only add this if geometry or geometries are set and not null
                        feature = features[i];
                        if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                            this.addData(features[i]);
                        }
                    }
                    return this;
                }

                var options = this.options;

                if (options.filter && !options.filter(geojson)) { return; }

                var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
                layer.feature = L.GeoJSON.asFeature(geojson);

                layer.defaultOptions = layer.options;
                this.resetStyle(layer);

                if (options.onEachFeature) {
                    options.onEachFeature(geojson, layer);
                }

                return this.addLayer(layer);
            },

            resetStyle: function (layer) {
                var style = this.options.style;
                if (style) {
                    // reset any custom styles
                    L.Util.extend(layer.options, layer.defaultOptions);

                    this._setLayerStyle(layer, style);
                }
            },

            setStyle: function (style) {
                this.eachLayer(function (layer) {
                    this._setLayerStyle(layer, style);
                }, this);
            },

            _setLayerStyle: function (layer, style) {
                if (typeof style === 'function') {
                    style = style(layer.feature);
                }
                if (layer.setStyle) {
                    layer.setStyle(style);
                }
            }
        });

        L.extend(L.GeoJSON, {
            geometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
                var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
                    coords = geometry.coordinates,
                    layers = [],
                    latlng, latlngs, i, len;

                coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

                switch (geometry.type) {
                    case 'Point':
                        latlng = coordsToLatLng(coords);
                        return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

                    case 'MultiPoint':
                        for (i = 0, len = coords.length; i < len; i++) {
                            latlng = coordsToLatLng(coords[i]);
                            layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
                        }
                        return new L.FeatureGroup(layers);

                    case 'LineString':
                        latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
                        return new L.Polyline(latlngs, vectorOptions);

                    case 'Polygon':
                        if (coords.length === 2 && !coords[1].length) {
                            throw new Error('Invalid GeoJSON object.');
                        }
                        latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                        return new L.Polygon(latlngs, vectorOptions);

                    case 'MultiLineString':
                        latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                        return new L.MultiPolyline(latlngs, vectorOptions);

                    case 'MultiPolygon':
                        latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
                        return new L.MultiPolygon(latlngs, vectorOptions);

                    case 'GeometryCollection':
                        for (i = 0, len = geometry.geometries.length; i < len; i++) {

                            layers.push(this.geometryToLayer({
                                geometry: geometry.geometries[i],
                                type: 'Feature',
                                properties: geojson.properties
                            }, pointToLayer, coordsToLatLng, vectorOptions));
                        }
                        return new L.FeatureGroup(layers);

                    default:
                        throw new Error('Invalid GeoJSON object.');
                }
            },

            coordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng
                return new L.LatLng(coords[1], coords[0], coords[2]);
            },

            coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
                var latlng, i, len,
                    latlngs = [];

                for (i = 0, len = coords.length; i < len; i++) {
                    latlng = levelsDeep ?
                        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
                        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

                    latlngs.push(latlng);
                }

                return latlngs;
            },

            latLngToCoords: function (latlng) {
                var coords = [latlng.lng, latlng.lat];

                if (latlng.alt !== undefined) {
                    coords.push(latlng.alt);
                }
                return coords;
            },

            latLngsToCoords: function (latLngs) {
                var coords = [];

                for (var i = 0, len = latLngs.length; i < len; i++) {
                    coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
                }

                return coords;
            },

            getFeature: function (layer, newGeometry) {
                return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);
            },

            asFeature: function (geoJSON) {
                if (geoJSON.type === 'Feature') {
                    return geoJSON;
                }

                return {
                    type: 'Feature',
                    properties: {},
                    geometry: geoJSON
                };
            }
        });

        var PointToGeoJSON = {
            toGeoJSON: function () {
                return L.GeoJSON.getFeature(this, {
                    type: 'Point',
                    coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
                });
            }
        };

        L.Marker.include(PointToGeoJSON);
        L.Circle.include(PointToGeoJSON);
        L.CircleMarker.include(PointToGeoJSON);

        L.Polyline.include({
            toGeoJSON: function () {
                return L.GeoJSON.getFeature(this, {
                    type: 'LineString',
                    coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
                });
            }
        });

        L.Polygon.include({
            toGeoJSON: function () {
                var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
                    i, len, hole;

                coords[0].push(coords[0][0]);

                if (this._holes) {
                    for (i = 0, len = this._holes.length; i < len; i++) {
                        hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
                        hole.push(hole[0]);
                        coords.push(hole);
                    }
                }

                return L.GeoJSON.getFeature(this, {
                    type: 'Polygon',
                    coordinates: coords
                });
            }
        });

        (function () {
            function multiToGeoJSON(type) {
                return function () {
                    var coords = [];

                    this.eachLayer(function (layer) {
                        coords.push(layer.toGeoJSON().geometry.coordinates);
                    });

                    return L.GeoJSON.getFeature(this, {
                        type: type,
                        coordinates: coords
                    });
                };
            }

            L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});
            L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});

            L.LayerGroup.include({
                toGeoJSON: function () {

                    var geometry = this.feature && this.feature.geometry,
                        jsons = [],
                        json;

                    if (geometry && geometry.type === 'MultiPoint') {
                        return multiToGeoJSON('MultiPoint').call(this);
                    }

                    var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';

                    this.eachLayer(function (layer) {
                        if (layer.toGeoJSON) {
                            json = layer.toGeoJSON();
                            jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
                        }
                    });

                    if (isGeometryCollection) {
                        return L.GeoJSON.getFeature(this, {
                            geometries: jsons,
                            type: 'GeometryCollection'
                        });
                    }

                    return {
                        type: 'FeatureCollection',
                        features: jsons
                    };
                }
            });
        }());

        L.geoJson = function (geojson, options) {
            return new L.GeoJSON(geojson, options);
        };


        /*
         * L.DomEvent contains functions for working with DOM events.
         */

        L.DomEvent = {
            /* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
            addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

                var id = L.stamp(fn),
                    key = '_leaflet_' + type + id,
                    handler, originalHandler, newType;

                if (obj[key]) { return this; }

                handler = function (e) {
                    return fn.call(context || obj, e || L.DomEvent._getEvent());
                };

                if (L.Browser.pointer && type.indexOf('touch') === 0) {
                    return this.addPointerListener(obj, type, handler, id);
                }
                if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
                    this.addDoubleTapListener(obj, handler, id);
                }

                if ('addEventListener' in obj) {

                    if (type === 'mousewheel') {
                        obj.addEventListener('DOMMouseScroll', handler, false);
                        obj.addEventListener(type, handler, false);

                    } else if ((type === 'mouseenter') || (type === 'mouseleave')) {

                        originalHandler = handler;
                        newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

                        handler = function (e) {
                            if (!L.DomEvent._checkMouse(obj, e)) { return; }
                            return originalHandler(e);
                        };

                        obj.addEventListener(newType, handler, false);

                    } else if (type === 'click' && L.Browser.android) {
                        originalHandler = handler;
                        handler = function (e) {
                            return L.DomEvent._filterClick(e, originalHandler);
                        };

                        obj.addEventListener(type, handler, false);
                    } else {
                        obj.addEventListener(type, handler, false);
                    }

                } else if ('attachEvent' in obj) {
                    obj.attachEvent('on' + type, handler);
                }

                obj[key] = handler;

                return this;
            },

            removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

                var id = L.stamp(fn),
                    key = '_leaflet_' + type + id,
                    handler = obj[key];

                if (!handler) { return this; }

                if (L.Browser.pointer && type.indexOf('touch') === 0) {
                    this.removePointerListener(obj, type, id);
                } else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
                    this.removeDoubleTapListener(obj, id);

                } else if ('removeEventListener' in obj) {

                    if (type === 'mousewheel') {
                        obj.removeEventListener('DOMMouseScroll', handler, false);
                        obj.removeEventListener(type, handler, false);

                    } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
                        obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
                    } else {
                        obj.removeEventListener(type, handler, false);
                    }
                } else if ('detachEvent' in obj) {
                    obj.detachEvent('on' + type, handler);
                }

                obj[key] = null;

                return this;
            },

            stopPropagation: function (e) {

                if (e.stopPropagation) {
                    e.stopPropagation();
                } else {
                    e.cancelBubble = true;
                }
                L.DomEvent._skipped(e);

                return this;
            },

            disableScrollPropagation: function (el) {
                var stop = L.DomEvent.stopPropagation;

                return L.DomEvent
                    .on(el, 'mousewheel', stop)
                    .on(el, 'MozMousePixelScroll', stop);
            },

            disableClickPropagation: function (el) {
                var stop = L.DomEvent.stopPropagation;

                for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                    L.DomEvent.on(el, L.Draggable.START[i], stop);
                }

                return L.DomEvent
                    .on(el, 'click', L.DomEvent._fakeStop)
                    .on(el, 'dblclick', stop);
            },

            preventDefault: function (e) {

                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                }
                return this;
            },

            stop: function (e) {
                return L.DomEvent
                    .preventDefault(e)
                    .stopPropagation(e);
            },

            getMousePosition: function (e, container) {
                if (!container) {
                    return new L.Point(e.clientX, e.clientY);
                }

                var rect = container.getBoundingClientRect();

                return new L.Point(
                    e.clientX - rect.left - container.clientLeft,
                    e.clientY - rect.top - container.clientTop);
            },

            getWheelDelta: function (e) {

                var delta = 0;

                if (e.wheelDelta) {
                    delta = e.wheelDelta / 120;
                }
                if (e.detail) {
                    delta = -e.detail / 3;
                }
                return delta;
            },

            _skipEvents: {},

            _fakeStop: function (e) {
                // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
                L.DomEvent._skipEvents[e.type] = true;
            },

            _skipped: function (e) {
                var skipped = this._skipEvents[e.type];
                // reset when checking, as it's only used in map container and propagates outside of the map
                this._skipEvents[e.type] = false;
                return skipped;
            },

            // check if element really left/entered the event target (for mouseenter/mouseleave)
            _checkMouse: function (el, e) {

                var related = e.relatedTarget;

                if (!related) { return true; }

                try {
                    while (related && (related !== el)) {
                        related = related.parentNode;
                    }
                } catch (err) {
                    return false;
                }
                return (related !== el);
            },

            _getEvent: function () { // evil magic for IE
                /*jshint noarg:false */
                var e = window.event;
                if (!e) {
                    var caller = arguments.callee.caller;
                    while (caller) {
                        e = caller['arguments'][0];
                        if (e && window.Event === e.constructor) {
                            break;
                        }
                        caller = caller.caller;
                    }
                }
                return e;
            },

            // this is a horrible workaround for a bug in Android where a single touch triggers two click events
            _filterClick: function (e, handler) {
                var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
                    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

                // are they closer together than 500ms yet more than 100ms?
                // Android typically triggers them ~300ms apart while multiple listeners
                // on the same event should be triggered far faster;
                // or check if click is simulated on the element, and if it is, reject any non-simulated events

                if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
                    L.DomEvent.stop(e);
                    return;
                }
                L.DomEvent._lastClick = timeStamp;

                return handler(e);
            }
        };

        L.DomEvent.on = L.DomEvent.addListener;
        L.DomEvent.off = L.DomEvent.removeListener;


        /*
         * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
         */

        L.Draggable = L.Class.extend({
            includes: L.Mixin.Events,

            statics: {
                START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
                END: {
                    mousedown: 'mouseup',
                    touchstart: 'touchend',
                    pointerdown: 'touchend',
                    MSPointerDown: 'touchend'
                },
                MOVE: {
                    mousedown: 'mousemove',
                    touchstart: 'touchmove',
                    pointerdown: 'touchmove',
                    MSPointerDown: 'touchmove'
                }
            },

            initialize: function (element, dragStartTarget) {
                this._element = element;
                this._dragStartTarget = dragStartTarget || element;
            },

            enable: function () {
                if (this._enabled) { return; }

                for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                    L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
                }

                this._enabled = true;
            },

            disable: function () {
                if (!this._enabled) { return; }

                for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                    L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
                }

                this._enabled = false;
                this._moved = false;
            },

            _onDown: function (e) {
                this._moved = false;

                if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

                L.DomEvent.stopPropagation(e);

                if (L.Draggable._disabled) { return; }

                L.DomUtil.disableImageDrag();
                L.DomUtil.disableTextSelection();

                if (this._moving) { return; }

                var first = e.touches ? e.touches[0] : e;

                this._startPoint = new L.Point(first.clientX, first.clientY);
                this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

                L.DomEvent
                    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
                    .on(document, L.Draggable.END[e.type], this._onUp, this);
            },

            _onMove: function (e) {
                if (e.touches && e.touches.length > 1) {
                    this._moved = true;
                    return;
                }

                var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
                    newPoint = new L.Point(first.clientX, first.clientY),
                    offset = newPoint.subtract(this._startPoint);

                if (!offset.x && !offset.y) { return; }
                if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

                L.DomEvent.preventDefault(e);

                if (!this._moved) {
                    this.fire('dragstart');

                    this._moved = true;
                    this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

                    L.DomUtil.addClass(document.body, 'leaflet-dragging');
                    this._lastTarget = e.target || e.srcElement;
                    L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
                }

                this._newPos = this._startPos.add(offset);
                this._moving = true;

                L.Util.cancelAnimFrame(this._animRequest);
                this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
            },

            _updatePosition: function () {
                this.fire('predrag');
                L.DomUtil.setPosition(this._element, this._newPos);
                this.fire('drag');
            },

            _onUp: function () {
                L.DomUtil.removeClass(document.body, 'leaflet-dragging');

                if (this._lastTarget) {
                    L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
                    this._lastTarget = null;
                }

                for (var i in L.Draggable.MOVE) {
                    L.DomEvent
                        .off(document, L.Draggable.MOVE[i], this._onMove)
                        .off(document, L.Draggable.END[i], this._onUp);
                }

                L.DomUtil.enableImageDrag();
                L.DomUtil.enableTextSelection();

                if (this._moved && this._moving) {
                    // ensure drag is not fired after dragend
                    L.Util.cancelAnimFrame(this._animRequest);

                    this.fire('dragend', {
                        distance: this._newPos.distanceTo(this._startPos)
                    });
                }

                this._moving = false;
            }
        });


        /*
         L.Handler is a base class for handler classes that are used internally to inject
         interaction features like dragging to classes like Map and Marker.
         */

        L.Handler = L.Class.extend({
            initialize: function (map) {
                this._map = map;
            },

            enable: function () {
                if (this._enabled) { return; }

                this._enabled = true;
                this.addHooks();
            },

            disable: function () {
                if (!this._enabled) { return; }

                this._enabled = false;
                this.removeHooks();
            },

            enabled: function () {
                return !!this._enabled;
            }
        });


        /*
         * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
         */

        L.Map.mergeOptions({
            dragging: true,

            inertia: !L.Browser.android23,
            inertiaDeceleration: 3400, // px/s^2
            inertiaMaxSpeed: Infinity, // px/s
            inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
            easeLinearity: 0.25,

            // TODO refactor, move to CRS
            worldCopyJump: false
        });

        L.Map.Drag = L.Handler.extend({
            addHooks: function () {
                if (!this._draggable) {
                    var map = this._map;

                    this._draggable = new L.Draggable(map._mapPane, map._container);

                    this._draggable.on({
                        'dragstart': this._onDragStart,
                        'drag': this._onDrag,
                        'dragend': this._onDragEnd
                    }, this);

                    if (map.options.worldCopyJump) {
                        this._draggable.on('predrag', this._onPreDrag, this);
                        map.on('viewreset', this._onViewReset, this);

                        map.whenReady(this._onViewReset, this);
                    }
                }
                this._draggable.enable();
            },

            removeHooks: function () {
                this._draggable.disable();
            },

            moved: function () {
                return this._draggable && this._draggable._moved;
            },

            _onDragStart: function () {
                var map = this._map;

                if (map._panAnim) {
                    map._panAnim.stop();
                }

                map
                    .fire('movestart')
                    .fire('dragstart');

                if (map.options.inertia) {
                    this._positions = [];
                    this._times = [];
                }
            },

            _onDrag: function () {
                if (this._map.options.inertia) {
                    var time = this._lastTime = +new Date(),
                        pos = this._lastPos = this._draggable._newPos;

                    this._positions.push(pos);
                    this._times.push(time);

                    if (time - this._times[0] > 200) {
                        this._positions.shift();
                        this._times.shift();
                    }
                }

                this._map
                    .fire('move')
                    .fire('drag');
            },

            _onViewReset: function () {
                // TODO fix hardcoded Earth values
                var pxCenter = this._map.getSize()._divideBy(2),
                    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

                this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
                this._worldWidth = this._map.project([0, 180]).x;
            },

            _onPreDrag: function () {
                // TODO refactor to be able to adjust map pane position after zoom
                var worldWidth = this._worldWidth,
                    halfWidth = Math.round(worldWidth / 2),
                    dx = this._initialWorldOffset,
                    x = this._draggable._newPos.x,
                    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
                    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
                    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

                this._draggable._newPos.x = newX;
            },

            _onDragEnd: function (e) {
                var map = this._map,
                    options = map.options,
                    delay = +new Date() - this._lastTime,

                    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

                map.fire('dragend', e);

                if (noInertia) {
                    map.fire('moveend');

                } else {

                    var direction = this._lastPos.subtract(this._positions[0]),
                        duration = (this._lastTime + delay - this._times[0]) / 1000,
                        ease = options.easeLinearity,

                        speedVector = direction.multiplyBy(ease / duration),
                        speed = speedVector.distanceTo([0, 0]),

                        limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
                        limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

                        decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
                        offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

                    if (!offset.x || !offset.y) {
                        map.fire('moveend');

                    } else {
                        offset = map._limitOffset(offset, map.options.maxBounds);

                        L.Util.requestAnimFrame(function () {
                            map.panBy(offset, {
                                duration: decelerationDuration,
                                easeLinearity: ease,
                                noMoveStart: true
                            });
                        });
                    }
                }
            }
        });

        L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


        /*
         * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
         */

        L.Map.mergeOptions({
            doubleClickZoom: true
        });

        L.Map.DoubleClickZoom = L.Handler.extend({
            addHooks: function () {
                this._map.on('dblclick', this._onDoubleClick, this);
            },

            removeHooks: function () {
                this._map.off('dblclick', this._onDoubleClick, this);
            },

            _onDoubleClick: function (e) {
                var map = this._map,
                    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

                if (map.options.doubleClickZoom === 'center') {
                    map.setZoom(zoom);
                } else {
                    map.setZoomAround(e.containerPoint, zoom);
                }
            }
        });

        L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


        /*
         * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
         */

        L.Map.mergeOptions({
            scrollWheelZoom: true
        });

        L.Map.ScrollWheelZoom = L.Handler.extend({
            addHooks: function () {
                L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
                L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
                this._delta = 0;
            },

            removeHooks: function () {
                L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
                L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
            },

            _onWheelScroll: function (e) {
                var delta = L.DomEvent.getWheelDelta(e);

                this._delta += delta;
                this._lastMousePos = this._map.mouseEventToContainerPoint(e);

                if (!this._startTime) {
                    this._startTime = +new Date();
                }

                var left = Math.max(40 - (+new Date() - this._startTime), 0);

                clearTimeout(this._timer);
                this._timer = setTimeout(L.bind(this._performZoom, this), left);

                L.DomEvent.preventDefault(e);
                L.DomEvent.stopPropagation(e);
            },

            _performZoom: function () {
                var map = this._map,
                    delta = this._delta,
                    zoom = map.getZoom();

                delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
                delta = Math.max(Math.min(delta, 4), -4);
                delta = map._limitZoom(zoom + delta) - zoom;

                this._delta = 0;
                this._startTime = null;

                if (!delta) { return; }

                if (map.options.scrollWheelZoom === 'center') {
                    map.setZoom(zoom + delta);
                } else {
                    map.setZoomAround(this._lastMousePos, zoom + delta);
                }
            }
        });

        L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


        /*
         * Extends the event handling code with double tap support for mobile browsers.
         */

        L.extend(L.DomEvent, {

            _touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
            _touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

            // inspired by Zepto touch code by Thomas Fuchs
            addDoubleTapListener: function (obj, handler, id) {
                var last,
                    doubleTap = false,
                    delay = 250,
                    touch,
                    pre = '_leaflet_',
                    touchstart = this._touchstart,
                    touchend = this._touchend,
                    trackedTouches = [];

                function onTouchStart(e) {
                    var count;

                    if (L.Browser.pointer) {
                        trackedTouches.push(e.pointerId);
                        count = trackedTouches.length;
                    } else {
                        count = e.touches.length;
                    }
                    if (count > 1) {
                        return;
                    }

                    var now = Date.now(),
                        delta = now - (last || now);

                    touch = e.touches ? e.touches[0] : e;
                    doubleTap = (delta > 0 && delta <= delay);
                    last = now;
                }

                function onTouchEnd(e) {
                    if (L.Browser.pointer) {
                        var idx = trackedTouches.indexOf(e.pointerId);
                        if (idx === -1) {
                            return;
                        }
                        trackedTouches.splice(idx, 1);
                    }

                    if (doubleTap) {
                        if (L.Browser.pointer) {
                            // work around .type being readonly with MSPointer* events
                            var newTouch = { },
                                prop;

                            // jshint forin:false
                            for (var i in touch) {
                                prop = touch[i];
                                if (typeof prop === 'function') {
                                    newTouch[i] = prop.bind(touch);
                                } else {
                                    newTouch[i] = prop;
                                }
                            }
                            touch = newTouch;
                        }
                        touch.type = 'dblclick';
                        handler(touch);
                        last = null;
                    }
                }
                obj[pre + touchstart + id] = onTouchStart;
                obj[pre + touchend + id] = onTouchEnd;

                // on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
                // will not come through to us, so we will lose track of how many touches are ongoing
                var endElement = L.Browser.pointer ? document.documentElement : obj;

                obj.addEventListener(touchstart, onTouchStart, false);
                endElement.addEventListener(touchend, onTouchEnd, false);

                if (L.Browser.pointer) {
                    endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
                }

                return this;
            },

            removeDoubleTapListener: function (obj, id) {
                var pre = '_leaflet_';

                obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
                (L.Browser.pointer ? document.documentElement : obj).removeEventListener(
                    this._touchend, obj[pre + this._touchend + id], false);

                if (L.Browser.pointer) {
                    document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],
                        false);
                }

                return this;
            }
        });


        /*
         * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
         */

        L.extend(L.DomEvent, {

            //static
            POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
            POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
            POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
            POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

            _pointers: [],
            _pointerDocumentListener: false,

            // Provides a touch events wrapper for (ms)pointer events.
            // Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
            //ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

            addPointerListener: function (obj, type, handler, id) {

                switch (type) {
                    case 'touchstart':
                        return this.addPointerListenerStart(obj, type, handler, id);
                    case 'touchend':
                        return this.addPointerListenerEnd(obj, type, handler, id);
                    case 'touchmove':
                        return this.addPointerListenerMove(obj, type, handler, id);
                    default:
                        throw 'Unknown touch event type';
                }
            },

            addPointerListenerStart: function (obj, type, handler, id) {
                var pre = '_leaflet_',
                    pointers = this._pointers;

                var cb = function (e) {
                    if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
                        L.DomEvent.preventDefault(e);
                    }

                    var alreadyInArray = false;
                    for (var i = 0; i < pointers.length; i++) {
                        if (pointers[i].pointerId === e.pointerId) {
                            alreadyInArray = true;
                            break;
                        }
                    }
                    if (!alreadyInArray) {
                        pointers.push(e);
                    }

                    e.touches = pointers.slice();
                    e.changedTouches = [e];

                    handler(e);
                };

                obj[pre + 'touchstart' + id] = cb;
                obj.addEventListener(this.POINTER_DOWN, cb, false);

                // need to also listen for end events to keep the _pointers list accurate
                // this needs to be on the body and never go away
                if (!this._pointerDocumentListener) {
                    var internalCb = function (e) {
                        for (var i = 0; i < pointers.length; i++) {
                            if (pointers[i].pointerId === e.pointerId) {
                                pointers.splice(i, 1);
                                break;
                            }
                        }
                    };
                    //We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
                    document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
                    document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);

                    this._pointerDocumentListener = true;
                }

                return this;
            },

            addPointerListenerMove: function (obj, type, handler, id) {
                var pre = '_leaflet_',
                    touches = this._pointers;

                function cb(e) {

                    // don't fire touch moves when mouse isn't down
                    if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

                    for (var i = 0; i < touches.length; i++) {
                        if (touches[i].pointerId === e.pointerId) {
                            touches[i] = e;
                            break;
                        }
                    }

                    e.touches = touches.slice();
                    e.changedTouches = [e];

                    handler(e);
                }

                obj[pre + 'touchmove' + id] = cb;
                obj.addEventListener(this.POINTER_MOVE, cb, false);

                return this;
            },

            addPointerListenerEnd: function (obj, type, handler, id) {
                var pre = '_leaflet_',
                    touches = this._pointers;

                var cb = function (e) {
                    for (var i = 0; i < touches.length; i++) {
                        if (touches[i].pointerId === e.pointerId) {
                            touches.splice(i, 1);
                            break;
                        }
                    }

                    e.touches = touches.slice();
                    e.changedTouches = [e];

                    handler(e);
                };

                obj[pre + 'touchend' + id] = cb;
                obj.addEventListener(this.POINTER_UP, cb, false);
                obj.addEventListener(this.POINTER_CANCEL, cb, false);

                return this;
            },

            removePointerListener: function (obj, type, id) {
                var pre = '_leaflet_',
                    cb = obj[pre + type + id];

                switch (type) {
                    case 'touchstart':
                        obj.removeEventListener(this.POINTER_DOWN, cb, false);
                        break;
                    case 'touchmove':
                        obj.removeEventListener(this.POINTER_MOVE, cb, false);
                        break;
                    case 'touchend':
                        obj.removeEventListener(this.POINTER_UP, cb, false);
                        obj.removeEventListener(this.POINTER_CANCEL, cb, false);
                        break;
                }

                return this;
            }
        });


        /*
         * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
         */

        L.Map.mergeOptions({
            touchZoom: L.Browser.touch && !L.Browser.android23,
            bounceAtZoomLimits: true
        });

        L.Map.TouchZoom = L.Handler.extend({
            addHooks: function () {
                L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
            },

            removeHooks: function () {
                L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
            },

            _onTouchStart: function (e) {
                var map = this._map;

                if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

                var p1 = map.mouseEventToLayerPoint(e.touches[0]),
                    p2 = map.mouseEventToLayerPoint(e.touches[1]),
                    viewCenter = map._getCenterLayerPoint();

                this._startCenter = p1.add(p2)._divideBy(2);
                this._startDist = p1.distanceTo(p2);

                this._moved = false;
                this._zooming = true;

                this._centerOffset = viewCenter.subtract(this._startCenter);

                if (map._panAnim) {
                    map._panAnim.stop();
                }

                L.DomEvent
                    .on(document, 'touchmove', this._onTouchMove, this)
                    .on(document, 'touchend', this._onTouchEnd, this);

                L.DomEvent.preventDefault(e);
            },

            _onTouchMove: function (e) {
                var map = this._map;

                if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

                var p1 = map.mouseEventToLayerPoint(e.touches[0]),
                    p2 = map.mouseEventToLayerPoint(e.touches[1]);

                this._scale = p1.distanceTo(p2) / this._startDist;
                this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

                if (this._scale === 1) { return; }

                if (!map.options.bounceAtZoomLimits) {
                    if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
                        (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }
                }

                if (!this._moved) {
                    L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

                    map
                        .fire('movestart')
                        .fire('zoomstart');

                    this._moved = true;
                }

                L.Util.cancelAnimFrame(this._animRequest);
                this._animRequest = L.Util.requestAnimFrame(
                    this._updateOnMove, this, true, this._map._container);

                L.DomEvent.preventDefault(e);
            },

            _updateOnMove: function () {
                var map = this._map,
                    origin = this._getScaleOrigin(),
                    center = map.layerPointToLatLng(origin),
                    zoom = map.getScaleZoom(this._scale);

                map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
            },

            _onTouchEnd: function () {
                if (!this._moved || !this._zooming) {
                    this._zooming = false;
                    return;
                }

                var map = this._map;

                this._zooming = false;
                L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
                L.Util.cancelAnimFrame(this._animRequest);

                L.DomEvent
                    .off(document, 'touchmove', this._onTouchMove)
                    .off(document, 'touchend', this._onTouchEnd);

                var origin = this._getScaleOrigin(),
                    center = map.layerPointToLatLng(origin),

                    oldZoom = map.getZoom(),
                    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
                    roundZoomDelta = (floatZoomDelta > 0 ?
                        Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),

                    zoom = map._limitZoom(oldZoom + roundZoomDelta),
                    scale = map.getZoomScale(zoom) / this._scale;

                map._animateZoom(center, zoom, origin, scale);
            },

            _getScaleOrigin: function () {
                var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
                return this._startCenter.add(centerOffset);
            }
        });

        L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


        /*
         * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
         */

        L.Map.mergeOptions({
            tap: true,
            tapTolerance: 15
        });

        L.Map.Tap = L.Handler.extend({
            addHooks: function () {
                L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
            },

            removeHooks: function () {
                L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
            },

            _onDown: function (e) {
                if (!e.touches) { return; }

                L.DomEvent.preventDefault(e);

                this._fireClick = true;

                // don't simulate click or track longpress if more than 1 touch
                if (e.touches.length > 1) {
                    this._fireClick = false;
                    clearTimeout(this._holdTimeout);
                    return;
                }

                var first = e.touches[0],
                    el = first.target;

                this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

                // if touching a link, highlight it
                if (el.tagName && el.tagName.toLowerCase() === 'a') {
                    L.DomUtil.addClass(el, 'leaflet-active');
                }

                // simulate long hold but setting a timeout
                this._holdTimeout = setTimeout(L.bind(function () {
                    if (this._isTapValid()) {
                        this._fireClick = false;
                        this._onUp();
                        this._simulateEvent('contextmenu', first);
                    }
                }, this), 1000);

                L.DomEvent
                    .on(document, 'touchmove', this._onMove, this)
                    .on(document, 'touchend', this._onUp, this);
            },

            _onUp: function (e) {
                clearTimeout(this._holdTimeout);

                L.DomEvent
                    .off(document, 'touchmove', this._onMove, this)
                    .off(document, 'touchend', this._onUp, this);

                if (this._fireClick && e && e.changedTouches) {

                    var first = e.changedTouches[0],
                        el = first.target;

                    if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
                        L.DomUtil.removeClass(el, 'leaflet-active');
                    }

                    // simulate click if the touch didn't move too much
                    if (this._isTapValid()) {
                        this._simulateEvent('click', first);
                    }
                }
            },

            _isTapValid: function () {
                return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
            },

            _onMove: function (e) {
                var first = e.touches[0];
                this._newPos = new L.Point(first.clientX, first.clientY);
            },

            _simulateEvent: function (type, e) {
                var simulatedEvent = document.createEvent('MouseEvents');

                simulatedEvent._simulated = true;
                e.target._simulatedClick = true;

                simulatedEvent.initMouseEvent(
                    type, true, true, window, 1,
                    e.screenX, e.screenY,
                    e.clientX, e.clientY,
                    false, false, false, false, 0, null);

                e.target.dispatchEvent(simulatedEvent);
            }
        });

        if (L.Browser.touch && !L.Browser.pointer) {
            L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
        }


        /*
         * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
         * (zoom to a selected bounding box), enabled by default.
         */

        L.Map.mergeOptions({
            boxZoom: true
        });

        L.Map.BoxZoom = L.Handler.extend({
            initialize: function (map) {
                this._map = map;
                this._container = map._container;
                this._pane = map._panes.overlayPane;
                this._moved = false;
            },

            addHooks: function () {
                L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
            },

            removeHooks: function () {
                L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
                this._moved = false;
            },

            moved: function () {
                return this._moved;
            },

            _onMouseDown: function (e) {
                this._moved = false;

                if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

                L.DomUtil.disableTextSelection();
                L.DomUtil.disableImageDrag();

                this._startLayerPoint = this._map.mouseEventToLayerPoint(e);

                L.DomEvent
                    .on(document, 'mousemove', this._onMouseMove, this)
                    .on(document, 'mouseup', this._onMouseUp, this)
                    .on(document, 'keydown', this._onKeyDown, this);
            },

            _onMouseMove: function (e) {
                if (!this._moved) {
                    this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
                    L.DomUtil.setPosition(this._box, this._startLayerPoint);

                    //TODO refactor: move cursor to styles
                    this._container.style.cursor = 'crosshair';
                    this._map.fire('boxzoomstart');
                }

                var startPoint = this._startLayerPoint,
                    box = this._box,

                    layerPoint = this._map.mouseEventToLayerPoint(e),
                    offset = layerPoint.subtract(startPoint),

                    newPos = new L.Point(
                        Math.min(layerPoint.x, startPoint.x),
                        Math.min(layerPoint.y, startPoint.y));

                L.DomUtil.setPosition(box, newPos);

                this._moved = true;

                // TODO refactor: remove hardcoded 4 pixels
                box.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
                box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
            },

            _finish: function () {
                if (this._moved) {
                    this._pane.removeChild(this._box);
                    this._container.style.cursor = '';
                }

                L.DomUtil.enableTextSelection();
                L.DomUtil.enableImageDrag();

                L.DomEvent
                    .off(document, 'mousemove', this._onMouseMove)
                    .off(document, 'mouseup', this._onMouseUp)
                    .off(document, 'keydown', this._onKeyDown);
            },

            _onMouseUp: function (e) {

                this._finish();

                var map = this._map,
                    layerPoint = map.mouseEventToLayerPoint(e);

                if (this._startLayerPoint.equals(layerPoint)) { return; }

                var bounds = new L.LatLngBounds(
                    map.layerPointToLatLng(this._startLayerPoint),
                    map.layerPointToLatLng(layerPoint));

                map.fitBounds(bounds);

                map.fire('boxzoomend', {
                    boxZoomBounds: bounds
                });
            },

            _onKeyDown: function (e) {
                if (e.keyCode === 27) {
                    this._finish();
                }
            }
        });

        L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


        /*
         * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
         */

        L.Map.mergeOptions({
            keyboard: true,
            keyboardPanOffset: 80,
            keyboardZoomOffset: 1
        });

        L.Map.Keyboard = L.Handler.extend({

            keyCodes: {
                left:    [37],
                right:   [39],
                down:    [40],
                up:      [38],
                zoomIn:  [187, 107, 61, 171],
                zoomOut: [189, 109, 173]
            },

            initialize: function (map) {
                this._map = map;

                this._setPanOffset(map.options.keyboardPanOffset);
                this._setZoomOffset(map.options.keyboardZoomOffset);
            },

            addHooks: function () {
                var container = this._map._container;

                // make the container focusable by tabbing
                if (container.tabIndex === -1) {
                    container.tabIndex = '0';
                }

                L.DomEvent
                    .on(container, 'focus', this._onFocus, this)
                    .on(container, 'blur', this._onBlur, this)
                    .on(container, 'mousedown', this._onMouseDown, this);

                this._map
                    .on('focus', this._addHooks, this)
                    .on('blur', this._removeHooks, this);
            },

            removeHooks: function () {
                this._removeHooks();

                var container = this._map._container;

                L.DomEvent
                    .off(container, 'focus', this._onFocus, this)
                    .off(container, 'blur', this._onBlur, this)
                    .off(container, 'mousedown', this._onMouseDown, this);

                this._map
                    .off('focus', this._addHooks, this)
                    .off('blur', this._removeHooks, this);
            },

            _onMouseDown: function () {
                if (this._focused) { return; }

                var body = document.body,
                    docEl = document.documentElement,
                    top = body.scrollTop || docEl.scrollTop,
                    left = body.scrollLeft || docEl.scrollLeft;

                this._map._container.focus();

                window.scrollTo(left, top);
            },

            _onFocus: function () {
                this._focused = true;
                this._map.fire('focus');
            },

            _onBlur: function () {
                this._focused = false;
                this._map.fire('blur');
            },

            _setPanOffset: function (pan) {
                var keys = this._panKeys = {},
                    codes = this.keyCodes,
                    i, len;

                for (i = 0, len = codes.left.length; i < len; i++) {
                    keys[codes.left[i]] = [-1 * pan, 0];
                }
                for (i = 0, len = codes.right.length; i < len; i++) {
                    keys[codes.right[i]] = [pan, 0];
                }
                for (i = 0, len = codes.down.length; i < len; i++) {
                    keys[codes.down[i]] = [0, pan];
                }
                for (i = 0, len = codes.up.length; i < len; i++) {
                    keys[codes.up[i]] = [0, -1 * pan];
                }
            },

            _setZoomOffset: function (zoom) {
                var keys = this._zoomKeys = {},
                    codes = this.keyCodes,
                    i, len;

                for (i = 0, len = codes.zoomIn.length; i < len; i++) {
                    keys[codes.zoomIn[i]] = zoom;
                }
                for (i = 0, len = codes.zoomOut.length; i < len; i++) {
                    keys[codes.zoomOut[i]] = -zoom;
                }
            },

            _addHooks: function () {
                L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
            },

            _removeHooks: function () {
                L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
            },

            _onKeyDown: function (e) {
                var key = e.keyCode,
                    map = this._map;

                if (key in this._panKeys) {

                    if (map._panAnim && map._panAnim._inProgress) { return; }

                    map.panBy(this._panKeys[key]);

                    if (map.options.maxBounds) {
                        map.panInsideBounds(map.options.maxBounds);
                    }

                } else if (key in this._zoomKeys) {
                    map.setZoom(map.getZoom() + this._zoomKeys[key]);

                } else {
                    return;
                }

                L.DomEvent.stop(e);
            }
        });

        L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


        /*
         * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
         */

        L.Handler.MarkerDrag = L.Handler.extend({
            initialize: function (marker) {
                this._marker = marker;
            },

            addHooks: function () {
                var icon = this._marker._icon;
                if (!this._draggable) {
                    this._draggable = new L.Draggable(icon, icon);
                }

                this._draggable
                    .on('dragstart', this._onDragStart, this)
                    .on('drag', this._onDrag, this)
                    .on('dragend', this._onDragEnd, this);
                this._draggable.enable();
                L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
            },

            removeHooks: function () {
                this._draggable
                    .off('dragstart', this._onDragStart, this)
                    .off('drag', this._onDrag, this)
                    .off('dragend', this._onDragEnd, this);

                this._draggable.disable();
                L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
            },

            moved: function () {
                return this._draggable && this._draggable._moved;
            },

            _onDragStart: function () {
                this._marker
                    .closePopup()
                    .fire('movestart')
                    .fire('dragstart');
            },

            _onDrag: function () {
                var marker = this._marker,
                    shadow = marker._shadow,
                    iconPos = L.DomUtil.getPosition(marker._icon),
                    latlng = marker._map.layerPointToLatLng(iconPos);

                // update shadow position
                if (shadow) {
                    L.DomUtil.setPosition(shadow, iconPos);
                }

                marker._latlng = latlng;

                marker
                    .fire('move', {latlng: latlng})
                    .fire('drag');
            },

            _onDragEnd: function (e) {
                this._marker
                    .fire('moveend')
                    .fire('dragend', e);
            }
        });


        /*
         * L.Control is a base class for implementing map controls. Handles positioning.
         * All other controls extend from this class.
         */

        L.Control = L.Class.extend({
            options: {
                position: 'topright'
            },

            initialize: function (options) {
                L.setOptions(this, options);
            },

            getPosition: function () {
                return this.options.position;
            },

            setPosition: function (position) {
                var map = this._map;

                if (map) {
                    map.removeControl(this);
                }

                this.options.position = position;

                if (map) {
                    map.addControl(this);
                }

                return this;
            },

            getContainer: function () {
                return this._container;
            },

            addTo: function (map) {
                this._map = map;

                var container = this._container = this.onAdd(map),
                    pos = this.getPosition(),
                    corner = map._controlCorners[pos];

                L.DomUtil.addClass(container, 'leaflet-control');

                if (pos.indexOf('bottom') !== -1) {
                    corner.insertBefore(container, corner.firstChild);
                } else {
                    corner.appendChild(container);
                }

                return this;
            },

            removeFrom: function (map) {
                var pos = this.getPosition(),
                    corner = map._controlCorners[pos];

                corner.removeChild(this._container);
                this._map = null;

                if (this.onRemove) {
                    this.onRemove(map);
                }

                return this;
            },

            _refocusOnMap: function () {
                if (this._map) {
                    this._map.getContainer().focus();
                }
            }
        });

        L.control = function (options) {
            return new L.Control(options);
        };


// adds control-related methods to L.Map

        L.Map.include({
            addControl: function (control) {
                control.addTo(this);
                return this;
            },

            removeControl: function (control) {
                control.removeFrom(this);
                return this;
            },

            _initControlPos: function () {
                var corners = this._controlCorners = {},
                    l = 'leaflet-',
                    container = this._controlContainer =
                        L.DomUtil.create('div', l + 'control-container', this._container);

                function createCorner(vSide, hSide) {
                    var className = l + vSide + ' ' + l + hSide;

                    corners[vSide + hSide] = L.DomUtil.create('div', className, container);
                }

                createCorner('top', 'left');
                createCorner('top', 'right');
                createCorner('bottom', 'left');
                createCorner('bottom', 'right');
            },

            _clearControlPos: function () {
                this._container.removeChild(this._controlContainer);
            }
        });


        /*
         * L.Control.Zoom is used for the default zoom buttons on the map.
         */

        L.Control.Zoom = L.Control.extend({
            options: {
                position: 'topleft',
                zoomInText: '+',
                zoomInTitle: 'Zoom in',
                zoomOutText: '-',
                zoomOutTitle: 'Zoom out'
            },

            onAdd: function (map) {
                var zoomName = 'leaflet-control-zoom',
                    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');

                this._map = map;

                this._zoomInButton  = this._createButton(
                    this.options.zoomInText, this.options.zoomInTitle,
                    zoomName + '-in',  container, this._zoomIn,  this);
                this._zoomOutButton = this._createButton(
                    this.options.zoomOutText, this.options.zoomOutTitle,
                    zoomName + '-out', container, this._zoomOut, this);

                this._updateDisabled();
                map.on('zoomend zoomlevelschange', this._updateDisabled, this);

                return container;
            },

            onRemove: function (map) {
                map.off('zoomend zoomlevelschange', this._updateDisabled, this);
            },

            _zoomIn: function (e) {
                this._map.zoomIn(e.shiftKey ? 3 : 1);
            },

            _zoomOut: function (e) {
                this._map.zoomOut(e.shiftKey ? 3 : 1);
            },

            _createButton: function (html, title, className, container, fn, context) {
                var link = L.DomUtil.create('a', className, container);
                link.innerHTML = html;
                link.href = '#';
                link.title = title;

                var stop = L.DomEvent.stopPropagation;

                L.DomEvent
                    .on(link, 'click', stop)
                    .on(link, 'mousedown', stop)
                    .on(link, 'dblclick', stop)
                    .on(link, 'click', L.DomEvent.preventDefault)
                    .on(link, 'click', fn, context)
                    .on(link, 'click', this._refocusOnMap, context);

                return link;
            },

            _updateDisabled: function () {
                var map = this._map,
                    className = 'leaflet-disabled';

                L.DomUtil.removeClass(this._zoomInButton, className);
                L.DomUtil.removeClass(this._zoomOutButton, className);

                if (map._zoom === map.getMinZoom()) {
                    L.DomUtil.addClass(this._zoomOutButton, className);
                }
                if (map._zoom === map.getMaxZoom()) {
                    L.DomUtil.addClass(this._zoomInButton, className);
                }
            }
        });

        L.Map.mergeOptions({
            zoomControl: true
        });

        L.Map.addInitHook(function () {
            if (this.options.zoomControl) {
                this.zoomControl = new L.Control.Zoom();
                this.addControl(this.zoomControl);
            }
        });

        L.control.zoom = function (options) {
            return new L.Control.Zoom(options);
        };



        /*
         * L.Control.Attribution is used for displaying attribution on the map (added by default).
         */

        L.Control.Attribution = L.Control.extend({
            options: {
                position: 'bottomright',
                prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
            },

            initialize: function (options) {
                L.setOptions(this, options);

                this._attributions = {};
            },

            onAdd: function (map) {
                this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
                L.DomEvent.disableClickPropagation(this._container);

                for (var i in map._layers) {
                    if (map._layers[i].getAttribution) {
                        this.addAttribution(map._layers[i].getAttribution());
                    }
                }

                map
                    .on('layeradd', this._onLayerAdd, this)
                    .on('layerremove', this._onLayerRemove, this);

                this._update();

                return this._container;
            },

            onRemove: function (map) {
                map
                    .off('layeradd', this._onLayerAdd)
                    .off('layerremove', this._onLayerRemove);

            },

            setPrefix: function (prefix) {
                this.options.prefix = prefix;
                this._update();
                return this;
            },

            addAttribution: function (text) {
                if (!text) { return; }

                if (!this._attributions[text]) {
                    this._attributions[text] = 0;
                }
                this._attributions[text]++;

                this._update();

                return this;
            },

            removeAttribution: function (text) {
                if (!text) { return; }

                if (this._attributions[text]) {
                    this._attributions[text]--;
                    this._update();
                }

                return this;
            },

            _update: function () {
                if (!this._map) { return; }

                var attribs = [];

                for (var i in this._attributions) {
                    if (this._attributions[i]) {
                        attribs.push(i);
                    }
                }

                var prefixAndAttribs = [];

                if (this.options.prefix) {
                    prefixAndAttribs.push(this.options.prefix);
                }
                if (attribs.length) {
                    prefixAndAttribs.push(attribs.join(', '));
                }

                this._container.innerHTML = prefixAndAttribs.join(' | ');
            },

            _onLayerAdd: function (e) {
                if (e.layer.getAttribution) {
                    this.addAttribution(e.layer.getAttribution());
                }
            },

            _onLayerRemove: function (e) {
                if (e.layer.getAttribution) {
                    this.removeAttribution(e.layer.getAttribution());
                }
            }
        });

        L.Map.mergeOptions({
            attributionControl: true
        });

        L.Map.addInitHook(function () {
            if (this.options.attributionControl) {
                this.attributionControl = (new L.Control.Attribution()).addTo(this);
            }
        });

        L.control.attribution = function (options) {
            return new L.Control.Attribution(options);
        };


        /*
         * L.Control.Scale is used for displaying metric/imperial scale on the map.
         */

        L.Control.Scale = L.Control.extend({
            options: {
                position: 'bottomleft',
                maxWidth: 100,
                metric: true,
                imperial: true,
                updateWhenIdle: false
            },

            onAdd: function (map) {
                this._map = map;

                var className = 'leaflet-control-scale',
                    container = L.DomUtil.create('div', className),
                    options = this.options;

                this._addScales(options, className, container);

                map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
                map.whenReady(this._update, this);

                return container;
            },

            onRemove: function (map) {
                map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
            },

            _addScales: function (options, className, container) {
                if (options.metric) {
                    this._mScale = L.DomUtil.create('div', className + '-line', container);
                }
                if (options.imperial) {
                    this._iScale = L.DomUtil.create('div', className + '-line', container);
                }
            },

            _update: function () {
                var bounds = this._map.getBounds(),
                    centerLat = bounds.getCenter().lat,
                    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
                    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,

                    size = this._map.getSize(),
                    options = this.options,
                    maxMeters = 0;

                if (size.x > 0) {
                    maxMeters = dist * (options.maxWidth / size.x);
                }

                this._updateScales(options, maxMeters);
            },

            _updateScales: function (options, maxMeters) {
                if (options.metric && maxMeters) {
                    this._updateMetric(maxMeters);
                }

                if (options.imperial && maxMeters) {
                    this._updateImperial(maxMeters);
                }
            },

            _updateMetric: function (maxMeters) {
                var meters = this._getRoundNum(maxMeters);

                this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
                this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
            },

            _updateImperial: function (maxMeters) {
                var maxFeet = maxMeters * 3.2808399,
                    scale = this._iScale,
                    maxMiles, miles, feet;

                if (maxFeet > 5280) {
                    maxMiles = maxFeet / 5280;
                    miles = this._getRoundNum(maxMiles);

                    scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
                    scale.innerHTML = miles + ' mi';

                } else {
                    feet = this._getRoundNum(maxFeet);

                    scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
                    scale.innerHTML = feet + ' ft';
                }
            },

            _getScaleWidth: function (ratio) {
                return Math.round(this.options.maxWidth * ratio) - 10;
            },

            _getRoundNum: function (num) {
                var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
                    d = num / pow10;

                d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

                return pow10 * d;
            }
        });

        L.control.scale = function (options) {
            return new L.Control.Scale(options);
        };


        /*
         * L.Control.Layers is a control to allow users to switch between different layers on the map.
         */

        L.Control.Layers = L.Control.extend({
            options: {
                collapsed: true,
                position: 'topright',
                autoZIndex: true
            },

            initialize: function (baseLayers, overlays, options) {
                L.setOptions(this, options);

                this._layers = {};
                this._lastZIndex = 0;
                this._handlingClick = false;

                for (var i in baseLayers) {
                    this._addLayer(baseLayers[i], i);
                }

                for (i in overlays) {
                    this._addLayer(overlays[i], i, true);
                }
            },

            onAdd: function (map) {
                this._initLayout();
                this._update();

                map
                    .on('layeradd', this._onLayerChange, this)
                    .on('layerremove', this._onLayerChange, this);

                return this._container;
            },

            onRemove: function (map) {
                map
                    .off('layeradd', this._onLayerChange, this)
                    .off('layerremove', this._onLayerChange, this);
            },

            addBaseLayer: function (layer, name) {
                this._addLayer(layer, name);
                this._update();
                return this;
            },

            addOverlay: function (layer, name) {
                this._addLayer(layer, name, true);
                this._update();
                return this;
            },

            removeLayer: function (layer) {
                var id = L.stamp(layer);
                delete this._layers[id];
                this._update();
                return this;
            },

            _initLayout: function () {
                var className = 'leaflet-control-layers',
                    container = this._container = L.DomUtil.create('div', className);

                //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
                container.setAttribute('aria-haspopup', true);

                if (!L.Browser.touch) {
                    L.DomEvent
                        .disableClickPropagation(container)
                        .disableScrollPropagation(container);
                } else {
                    L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
                }

                var form = this._form = L.DomUtil.create('form', className + '-list');

                if (this.options.collapsed) {
                    if (!L.Browser.android) {
                        L.DomEvent
                            .on(container, 'mouseover', this._expand, this)
                            .on(container, 'mouseout', this._collapse, this);
                    }
                    var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
                    link.href = '#';
                    link.title = 'Layers';

                    if (L.Browser.touch) {
                        L.DomEvent
                            .on(link, 'click', L.DomEvent.stop)
                            .on(link, 'click', this._expand, this);
                    }
                    else {
                        L.DomEvent.on(link, 'focus', this._expand, this);
                    }
                    //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
                    L.DomEvent.on(form, 'click', function () {
                        setTimeout(L.bind(this._onInputClick, this), 0);
                    }, this);

                    this._map.on('click', this._collapse, this);
                    // TODO keyboard accessibility
                } else {
                    this._expand();
                }

                this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
                this._separator = L.DomUtil.create('div', className + '-separator', form);
                this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

                container.appendChild(form);
            },

            _addLayer: function (layer, name, overlay) {
                var id = L.stamp(layer);

                this._layers[id] = {
                    layer: layer,
                    name: name,
                    overlay: overlay
                };

                if (this.options.autoZIndex && layer.setZIndex) {
                    this._lastZIndex++;
                    layer.setZIndex(this._lastZIndex);
                }
            },

            _update: function () {
                if (!this._container) {
                    return;
                }

                this._baseLayersList.innerHTML = '';
                this._overlaysList.innerHTML = '';

                var baseLayersPresent = false,
                    overlaysPresent = false,
                    i, obj;

                for (i in this._layers) {
                    obj = this._layers[i];
                    this._addItem(obj);
                    overlaysPresent = overlaysPresent || obj.overlay;
                    baseLayersPresent = baseLayersPresent || !obj.overlay;
                }

                this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
            },

            _onLayerChange: function (e) {
                var obj = this._layers[L.stamp(e.layer)];

                if (!obj) { return; }

                if (!this._handlingClick) {
                    this._update();
                }

                var type = obj.overlay ?
                    (e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
                    (e.type === 'layeradd' ? 'baselayerchange' : null);

                if (type) {
                    this._map.fire(type, obj);
                }
            },

            // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
            _createRadioElement: function (name, checked) {

                var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
                if (checked) {
                    radioHtml += ' checked="checked"';
                }
                radioHtml += '/>';

                var radioFragment = document.createElement('div');
                radioFragment.innerHTML = radioHtml;

                return radioFragment.firstChild;
            },

            _addItem: function (obj) {
                var label = document.createElement('label'),
                    input,
                    checked = this._map.hasLayer(obj.layer);

                if (obj.overlay) {
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.className = 'leaflet-control-layers-selector';
                    input.defaultChecked = checked;
                } else {
                    input = this._createRadioElement('leaflet-base-layers', checked);
                }

                input.layerId = L.stamp(obj.layer);

                L.DomEvent.on(input, 'click', this._onInputClick, this);

                var name = document.createElement('span');
                name.innerHTML = ' ' + obj.name;

                label.appendChild(input);
                label.appendChild(name);

                var container = obj.overlay ? this._overlaysList : this._baseLayersList;
                container.appendChild(label);

                return label;
            },

            _onInputClick: function () {
                var i, input, obj,
                    inputs = this._form.getElementsByTagName('input'),
                    inputsLen = inputs.length;

                this._handlingClick = true;

                for (i = 0; i < inputsLen; i++) {
                    input = inputs[i];
                    obj = this._layers[input.layerId];

                    if (input.checked && !this._map.hasLayer(obj.layer)) {
                        this._map.addLayer(obj.layer);

                    } else if (!input.checked && this._map.hasLayer(obj.layer)) {
                        this._map.removeLayer(obj.layer);
                    }
                }

                this._handlingClick = false;

                this._refocusOnMap();
            },

            _expand: function () {
                L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
            },

            _collapse: function () {
                this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
            }
        });

        L.control.layers = function (baseLayers, overlays, options) {
            return new L.Control.Layers(baseLayers, overlays, options);
        };


        /*
         * L.PosAnimation is used by Leaflet internally for pan animations.
         */

        L.PosAnimation = L.Class.extend({
            includes: L.Mixin.Events,

            run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
                this.stop();

                this._el = el;
                this._inProgress = true;
                this._newPos = newPos;

                this.fire('start');

                el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
                    's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

                L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
                L.DomUtil.setPosition(el, newPos);

                // toggle reflow, Chrome flickers for some reason if you don't do this
                L.Util.falseFn(el.offsetWidth);

                // there's no native way to track value updates of transitioned properties, so we imitate this
                this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
            },

            stop: function () {
                if (!this._inProgress) { return; }

                // if we just removed the transition property, the element would jump to its final position,
                // so we need to make it stay at the current position

                L.DomUtil.setPosition(this._el, this._getPos());
                this._onTransitionEnd();
                L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
            },

            _onStep: function () {
                var stepPos = this._getPos();
                if (!stepPos) {
                    this._onTransitionEnd();
                    return;
                }
                // jshint camelcase: false
                // make L.DomUtil.getPosition return intermediate position value during animation
                this._el._leaflet_pos = stepPos;

                this.fire('step');
            },

            // you can't easily get intermediate values of properties animated with CSS3 Transitions,
            // we need to parse computed style (in case of transform it returns matrix string)

            _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,

            _getPos: function () {
                var left, top, matches,
                    el = this._el,
                    style = window.getComputedStyle(el);

                if (L.Browser.any3d) {
                    matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
                    if (!matches) { return; }
                    left = parseFloat(matches[1]);
                    top  = parseFloat(matches[2]);
                } else {
                    left = parseFloat(style.left);
                    top  = parseFloat(style.top);
                }

                return new L.Point(left, top, true);
            },

            _onTransitionEnd: function () {
                L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

                if (!this._inProgress) { return; }
                this._inProgress = false;

                this._el.style[L.DomUtil.TRANSITION] = '';

                // jshint camelcase: false
                // make sure L.DomUtil.getPosition returns the final position value after animation
                this._el._leaflet_pos = this._newPos;

                clearInterval(this._stepTimer);

                this.fire('step').fire('end');
            }

        });


        /*
         * Extends L.Map to handle panning animations.
         */

        L.Map.include({

            setView: function (center, zoom, options) {

                zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
                center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
                options = options || {};

                if (this._panAnim) {
                    this._panAnim.stop();
                }

                if (this._loaded && !options.reset && options !== true) {

                    if (options.animate !== undefined) {
                        options.zoom = L.extend({animate: options.animate}, options.zoom);
                        options.pan = L.extend({animate: options.animate}, options.pan);
                    }

                    // try animating pan or zoom
                    var animated = (this._zoom !== zoom) ?
                    this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
                        this._tryAnimatedPan(center, options.pan);

                    if (animated) {
                        // prevent resize handler call, the view will refresh after animation anyway
                        clearTimeout(this._sizeTimer);
                        return this;
                    }
                }

                // animation didn't start, just reset the map view
                this._resetView(center, zoom);

                return this;
            },

            panBy: function (offset, options) {
                offset = L.point(offset).round();
                options = options || {};

                if (!offset.x && !offset.y) {
                    return this;
                }

                if (!this._panAnim) {
                    this._panAnim = new L.PosAnimation();

                    this._panAnim.on({
                        'step': this._onPanTransitionStep,
                        'end': this._onPanTransitionEnd
                    }, this);
                }

                // don't fire movestart if animating inertia
                if (!options.noMoveStart) {
                    this.fire('movestart');
                }

                // animate pan unless animate: false specified
                if (options.animate !== false) {
                    L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

                    var newPos = this._getMapPanePos().subtract(offset);
                    this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
                } else {
                    this._rawPanBy(offset);
                    this.fire('move').fire('moveend');
                }

                return this;
            },

            _onPanTransitionStep: function () {
                this.fire('move');
            },

            _onPanTransitionEnd: function () {
                L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
                this.fire('moveend');
            },

            _tryAnimatedPan: function (center, options) {
                // difference between the new and current centers in pixels
                var offset = this._getCenterOffset(center)._floor();

                // don't animate too far unless animate: true specified in options
                if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

                this.panBy(offset, options);

                return true;
            }
        });


        /*
         * L.PosAnimation fallback implementation that powers Leaflet pan animations
         * in browsers that don't support CSS3 Transitions.
         */

        L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({

            run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
                this.stop();

                this._el = el;
                this._inProgress = true;
                this._duration = duration || 0.25;
                this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

                this._startPos = L.DomUtil.getPosition(el);
                this._offset = newPos.subtract(this._startPos);
                this._startTime = +new Date();

                this.fire('start');

                this._animate();
            },

            stop: function () {
                if (!this._inProgress) { return; }

                this._step();
                this._complete();
            },

            _animate: function () {
                // animation loop
                this._animId = L.Util.requestAnimFrame(this._animate, this);
                this._step();
            },

            _step: function () {
                var elapsed = (+new Date()) - this._startTime,
                    duration = this._duration * 1000;

                if (elapsed < duration) {
                    this._runFrame(this._easeOut(elapsed / duration));
                } else {
                    this._runFrame(1);
                    this._complete();
                }
            },

            _runFrame: function (progress) {
                var pos = this._startPos.add(this._offset.multiplyBy(progress));
                L.DomUtil.setPosition(this._el, pos);

                this.fire('step');
            },

            _complete: function () {
                L.Util.cancelAnimFrame(this._animId);

                this._inProgress = false;
                this.fire('end');
            },

            _easeOut: function (t) {
                return 1 - Math.pow(1 - t, this._easeOutPower);
            }
        });


        /*
         * Extends L.Map to handle zoom animations.
         */

        L.Map.mergeOptions({
            zoomAnimation: true,
            zoomAnimationThreshold: 4
        });

        if (L.DomUtil.TRANSITION) {

            L.Map.addInitHook(function () {
                // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
                this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&
                    L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;

                // zoom transitions run with the same duration for all layers, so if one of transitionend events
                // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
                if (this._zoomAnimated) {
                    L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
                }
            });
        }

        L.Map.include(!L.DomUtil.TRANSITION ? {} : {

            _catchTransitionEnd: function (e) {
                if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
                    this._onZoomTransitionEnd();
                }
            },

            _nothingToAnimate: function () {
                return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
            },

            _tryAnimatedZoom: function (center, zoom, options) {

                if (this._animatingZoom) { return true; }

                options = options || {};

                // don't animate if disabled, not supported or zoom difference is too large
                if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
                    Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

                // offset is the pixel coords of the zoom origin relative to the current center
                var scale = this.getZoomScale(zoom),
                    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
                    origin = this._getCenterLayerPoint()._add(offset);

                // don't animate if the zoom origin isn't within one screen from the current center, unless forced
                if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

                this
                    .fire('movestart')
                    .fire('zoomstart');

                this._animateZoom(center, zoom, origin, scale, null, true);

                return true;
            },

            _animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {

                if (!forTouchZoom) {
                    this._animatingZoom = true;
                }

                // put transform transition on all layers with leaflet-zoom-animated class
                L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');

                // remember what center/zoom to set after animation
                this._animateToCenter = center;
                this._animateToZoom = zoom;

                // disable any dragging during animation
                if (L.Draggable) {
                    L.Draggable._disabled = true;
                }

                L.Util.requestAnimFrame(function () {
                    this.fire('zoomanim', {
                        center: center,
                        zoom: zoom,
                        origin: origin,
                        scale: scale,
                        delta: delta,
                        backwards: backwards
                    });
                    // horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689
                    setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
                }, this);
            },

            _onZoomTransitionEnd: function () {
                if (!this._animatingZoom) { return; }

                this._animatingZoom = false;

                L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

                L.Util.requestAnimFrame(function () {
                    this._resetView(this._animateToCenter, this._animateToZoom, true, true);

                    if (L.Draggable) {
                        L.Draggable._disabled = false;
                    }
                }, this);
            }
        });


        /*
         Zoom animation logic for L.TileLayer.
         */

        L.TileLayer.include({
            _animateZoom: function (e) {
                if (!this._animating) {
                    this._animating = true;
                    this._prepareBgBuffer();
                }

                var bg = this._bgBuffer,
                    transform = L.DomUtil.TRANSFORM,
                    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
                    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);

                bg.style[transform] = e.backwards ?
                scaleStr + ' ' + initialTransform :
                initialTransform + ' ' + scaleStr;
            },

            _endZoomAnim: function () {
                var front = this._tileContainer,
                    bg = this._bgBuffer;

                front.style.visibility = '';
                front.parentNode.appendChild(front); // Bring to fore

                // force reflow
                L.Util.falseFn(bg.offsetWidth);

                var zoom = this._map.getZoom();
                if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                    this._clearBgBuffer();
                }

                this._animating = false;
            },

            _clearBgBuffer: function () {
                var map = this._map;

                if (map && !map._animatingZoom && !map.touchZoom._zooming) {
                    this._bgBuffer.innerHTML = '';
                    this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
                }
            },

            _prepareBgBuffer: function () {

                var front = this._tileContainer,
                    bg = this._bgBuffer;

                // if foreground layer doesn't have many tiles but bg layer does,
                // keep the existing bg layer and just zoom it some more

                var bgLoaded = this._getLoadedTilesPercentage(bg),
                    frontLoaded = this._getLoadedTilesPercentage(front);

                if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

                    front.style.visibility = 'hidden';
                    this._stopLoadingImages(front);
                    return;
                }

                // prepare the buffer to become the front tile pane
                bg.style.visibility = 'hidden';
                bg.style[L.DomUtil.TRANSFORM] = '';

                // switch out the current layer to be the new bg layer (and vice-versa)
                this._tileContainer = bg;
                bg = this._bgBuffer = front;

                this._stopLoadingImages(bg);

                //prevent bg buffer from clearing right after zoom
                clearTimeout(this._clearBgBufferTimer);
            },

            _getLoadedTilesPercentage: function (container) {
                var tiles = container.getElementsByTagName('img'),
                    i, len, count = 0;

                for (i = 0, len = tiles.length; i < len; i++) {
                    if (tiles[i].complete) {
                        count++;
                    }
                }
                return count / len;
            },

            // stops loading all tiles in the background layer
            _stopLoadingImages: function (container) {
                var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
                    i, len, tile;

                for (i = 0, len = tiles.length; i < len; i++) {
                    tile = tiles[i];

                    if (!tile.complete) {
                        tile.onload = L.Util.falseFn;
                        tile.onerror = L.Util.falseFn;
                        tile.src = L.Util.emptyImageUrl;

                        tile.parentNode.removeChild(tile);
                    }
                }
            }
        });


        /*
         * Provides L.Map with convenient shortcuts for using browser geolocation features.
         */

        L.Map.include({
            _defaultLocateOptions: {
                watch: false,
                setView: false,
                maxZoom: Infinity,
                timeout: 10000,
                maximumAge: 0,
                enableHighAccuracy: false
            },

            locate: function (/*Object*/ options) {

                options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

                if (!navigator.geolocation) {
                    this._handleGeolocationError({
                        code: 0,
                        message: 'Geolocation not supported.'
                    });
                    return this;
                }

                var onResponse = L.bind(this._handleGeolocationResponse, this),
                    onError = L.bind(this._handleGeolocationError, this);

                if (options.watch) {
                    this._locationWatchId =
                        navigator.geolocation.watchPosition(onResponse, onError, options);
                } else {
                    navigator.geolocation.getCurrentPosition(onResponse, onError, options);
                }
                return this;
            },

            stopLocate: function () {
                if (navigator.geolocation) {
                    navigator.geolocation.clearWatch(this._locationWatchId);
                }
                if (this._locateOptions) {
                    this._locateOptions.setView = false;
                }
                return this;
            },

            _handleGeolocationError: function (error) {
                var c = error.code,
                    message = error.message ||
                        (c === 1 ? 'permission denied' :
                            (c === 2 ? 'position unavailable' : 'timeout'));

                if (this._locateOptions.setView && !this._loaded) {
                    this.fitWorld();
                }

                this.fire('locationerror', {
                    code: c,
                    message: 'Geolocation error: ' + message + '.'
                });
            },

            _handleGeolocationResponse: function (pos) {
                var lat = pos.coords.latitude,
                    lng = pos.coords.longitude,
                    latlng = new L.LatLng(lat, lng),

                    latAccuracy = 180 * pos.coords.accuracy / 40075017,
                    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),

                    bounds = L.latLngBounds(
                        [lat - latAccuracy, lng - lngAccuracy],
                        [lat + latAccuracy, lng + lngAccuracy]),

                    options = this._locateOptions;

                if (options.setView) {
                    var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
                    this.setView(latlng, zoom);
                }

                var data = {
                    latlng: latlng,
                    bounds: bounds,
                    timestamp: pos.timestamp
                };

                for (var i in pos.coords) {
                    if (typeof pos.coords[i] === 'number') {
                        data[i] = pos.coords[i];
                    }
                }

                this.fire('locationfound', data);
            }
        });


    }(window, document));
},{}],81:[function(require,module,exports){
    (function (global){
        /**
         * @license
         * lodash 4.11.1 (Custom Build) <https://lodash.com/>
         * Build: `lodash -d -o ./foo/lodash.js`
         * Copyright jQuery Foundation and other contributors <https://jquery.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */
        ;(function() {

            /** Used as a safe reference for `undefined` in pre-ES5 environments. */
            var undefined;

            /** Used as the semantic version number. */
            var VERSION = '4.11.1';

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;

            /** Used as the `TypeError` message for "Functions" methods. */
            var FUNC_ERROR_TEXT = 'Expected a function';

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';

            /** Used as the internal argument placeholder. */
            var PLACEHOLDER = '__lodash_placeholder__';

            /** Used to compose bitmasks for wrapper metadata. */
            var BIND_FLAG = 1,
                BIND_KEY_FLAG = 2,
                CURRY_BOUND_FLAG = 4,
                CURRY_FLAG = 8,
                CURRY_RIGHT_FLAG = 16,
                PARTIAL_FLAG = 32,
                PARTIAL_RIGHT_FLAG = 64,
                ARY_FLAG = 128,
                REARG_FLAG = 256,
                FLIP_FLAG = 512;

            /** Used to compose bitmasks for comparison styles. */
            var UNORDERED_COMPARE_FLAG = 1,
                PARTIAL_COMPARE_FLAG = 2;

            /** Used as default options for `_.truncate`. */
            var DEFAULT_TRUNC_LENGTH = 30,
                DEFAULT_TRUNC_OMISSION = '...';

            /** Used to detect hot functions by number of calls within a span of milliseconds. */
            var HOT_COUNT = 150,
                HOT_SPAN = 16;

            /** Used to indicate the type of lazy iteratees. */
            var LAZY_FILTER_FLAG = 1,
                LAZY_MAP_FLAG = 2,
                LAZY_WHILE_FLAG = 3;

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0,
                MAX_SAFE_INTEGER = 9007199254740991,
                MAX_INTEGER = 1.7976931348623157e+308,
                NAN = 0 / 0;

            /** Used as references for the maximum length and index of an array. */
            var MAX_ARRAY_LENGTH = 4294967295,
                MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                funcTag = '[object Function]',
                genTag = '[object GeneratorFunction]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                objectTag = '[object Object]',
                promiseTag = '[object Promise]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                symbolTag = '[object Symbol]',
                weakMapTag = '[object WeakMap]',
                weakSetTag = '[object WeakSet]';

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]',
                float32Tag = '[object Float32Array]',
                float64Tag = '[object Float64Array]',
                int8Tag = '[object Int8Array]',
                int16Tag = '[object Int16Array]',
                int32Tag = '[object Int32Array]',
                uint8Tag = '[object Uint8Array]',
                uint8ClampedTag = '[object Uint8ClampedArray]',
                uint16Tag = '[object Uint16Array]',
                uint32Tag = '[object Uint32Array]';

            /** Used to match empty string literals in compiled template source. */
            var reEmptyStringLeading = /\b__p \+= '';/g,
                reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

            /** Used to match HTML entities and HTML characters. */
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
                reUnescapedHtml = /[&<>"'`]/g,
                reHasEscapedHtml = RegExp(reEscapedHtml.source),
                reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

            /** Used to match template delimiters. */
            var reEscape = /<%-([\s\S]+?)%>/g,
                reEvaluate = /<%([\s\S]+?)%>/g,
                reInterpolate = /<%=([\s\S]+?)%>/g;

            /** Used to match property names within property paths. */
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                reIsPlainProp = /^\w*$/,
                rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;

            /**
             * Used to match `RegExp`
             * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
             */
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
                reHasRegExpChar = RegExp(reRegExpChar.source);

            /** Used to match leading and trailing whitespace. */
            var reTrim = /^\s+|\s+$/g,
                reTrimStart = /^\s+/,
                reTrimEnd = /\s+$/;

            /** Used to match non-compound words composed of alphanumeric characters. */
            var reBasicWord = /[a-zA-Z0-9]+/g;

            /** Used to match backslashes in property paths. */
            var reEscapeChar = /\\(\\)?/g;

            /**
             * Used to match
             * [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components).
             */
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

            /** Used to match `RegExp` flags from their coerced string values. */
            var reFlags = /\w*$/;

            /** Used to detect hexadecimal string values. */
            var reHasHexPrefix = /^0x/i;

            /** Used to detect bad signed hexadecimal string values. */
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

            /** Used to detect binary string values. */
            var reIsBinary = /^0b[01]+$/i;

            /** Used to detect host constructors (Safari). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/;

            /** Used to detect octal string values. */
            var reIsOctal = /^0o[0-7]+$/i;

            /** Used to detect unsigned integer values. */
            var reIsUint = /^(?:0|[1-9]\d*)$/;

            /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
            var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

            /** Used to ensure capturing order of template delimiters. */
            var reNoMatch = /($^)/;

            /** Used to match unescaped characters in compiled string literals. */
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

            /** Used to compose unicode character classes. */
            var rsAstralRange = '\\ud800-\\udfff',
                rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
                rsComboSymbolsRange = '\\u20d0-\\u20f0',
                rsDingbatRange = '\\u2700-\\u27bf',
                rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
                rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
                rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
                rsQuoteRange = '\\u2018\\u2019\\u201c\\u201d',
                rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
                rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
                rsVarRange = '\\ufe0e\\ufe0f',
                rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;

            /** Used to compose unicode capture groups. */
            var rsApos = "['\u2019]",
                rsAstral = '[' + rsAstralRange + ']',
                rsBreak = '[' + rsBreakRange + ']',
                rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
                rsDigits = '\\d+',
                rsDingbat = '[' + rsDingbatRange + ']',
                rsLower = '[' + rsLowerRange + ']',
                rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
                rsFitz = '\\ud83c[\\udffb-\\udfff]',
                rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
                rsNonAstral = '[^' + rsAstralRange + ']',
                rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
                rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
                rsUpper = '[' + rsUpperRange + ']',
                rsZWJ = '\\u200d';

            /** Used to compose unicode regexes. */
            var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
                rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
                rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
                rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
                reOptMod = rsModifier + '?',
                rsOptVar = '[' + rsVarRange + ']?',
                rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
                rsSeq = rsOptVar + reOptMod + rsOptJoin,
                rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
                rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

            /** Used to match apostrophes. */
            var reApos = RegExp(rsApos, 'g');

            /**
             * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
             * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
             */
            var reComboMark = RegExp(rsCombo, 'g');

            /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
            var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

            /** Used to match complex or compound words. */
            var reComplexWord = RegExp([
                rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
                rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
                rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
                rsUpper + '+' + rsOptUpperContr,
                rsDigits,
                rsEmoji
            ].join('|'), 'g');

            /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
            var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

            /** Used to detect strings that need a more robust regexp to match words. */
            var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

            /** Used to assign default `context` object properties. */
            var contextProps = [
                'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
                'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
                'Promise', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError',
                'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
                '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
            ];

            /** Used to make template sourceURLs easier to identify. */
            var templateCounter = -1;

            /** Used to identify `toStringTag` values of typed arrays. */
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                        typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                            typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
                        typedArrayTags[errorTag] = typedArrayTags[funcTag] =
                            typedArrayTags[mapTag] = typedArrayTags[numberTag] =
                                typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
                                    typedArrayTags[setTag] = typedArrayTags[stringTag] =
                                        typedArrayTags[weakMapTag] = false;

            /** Used to identify `toStringTag` values supported by `_.clone`. */
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] =
                cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
                    cloneableTags[boolTag] = cloneableTags[dateTag] =
                        cloneableTags[float32Tag] = cloneableTags[float64Tag] =
                            cloneableTags[int8Tag] = cloneableTags[int16Tag] =
                                cloneableTags[int32Tag] = cloneableTags[mapTag] =
                                    cloneableTags[numberTag] = cloneableTags[objectTag] =
                                        cloneableTags[regexpTag] = cloneableTags[setTag] =
                                            cloneableTags[stringTag] = cloneableTags[symbolTag] =
                                                cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                                    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] =
                cloneableTags[weakMapTag] = false;

            /** Used to map latin-1 supplementary letters to basic latin letters. */
            var deburredLetters = {
                '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
                '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
                '\xc7': 'C',  '\xe7': 'c',
                '\xd0': 'D',  '\xf0': 'd',
                '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
                '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
                '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
                '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
                '\xd1': 'N',  '\xf1': 'n',
                '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
                '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
                '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
                '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
                '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
                '\xc6': 'Ae', '\xe6': 'ae',
                '\xde': 'Th', '\xfe': 'th',
                '\xdf': 'ss'
            };

            /** Used to map characters to HTML entities. */
            var htmlEscapes = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;',
                '`': '&#96;'
            };

            /** Used to map HTML entities to characters. */
            var htmlUnescapes = {
                '&amp;': '&',
                '&lt;': '<',
                '&gt;': '>',
                '&quot;': '"',
                '&#39;': "'",
                '&#96;': '`'
            };

            /** Used to determine if values are of the language type `Object`. */
            var objectTypes = {
                'function': true,
                'object': true
            };

            /** Used to escape characters for inclusion in compiled string literals. */
            var stringEscapes = {
                '\\': '\\',
                "'": "'",
                '\n': 'n',
                '\r': 'r',
                '\u2028': 'u2028',
                '\u2029': 'u2029'
            };

            /** Built-in method references without a dependency on `root`. */
            var freeParseFloat = parseFloat,
                freeParseInt = parseInt;

            /** Detect free variable `exports`. */
            var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
                ? exports
                : undefined;

            /** Detect free variable `module`. */
            var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
                ? module
                : undefined;

            /** Detect the popular CommonJS extension `module.exports`. */
            var moduleExports = (freeModule && freeModule.exports === freeExports)
                ? freeExports
                : undefined;

            /** Detect free variable `global` from Node.js. */
            var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

            /** Detect free variable `self`. */
            var freeSelf = checkGlobal(objectTypes[typeof self] && self);

            /** Detect free variable `window`. */
            var freeWindow = checkGlobal(objectTypes[typeof window] && window);

            /** Detect `this` as the global object. */
            var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

            /**
             * Used as a reference to the global object.
             *
             * The `this` value is used if it's the global object to avoid Greasemonkey's
             * restricted `window` object, otherwise the `window` object is used.
             */
            var root = freeGlobal ||
                ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
                freeSelf || thisGlobal || Function('return this')();

            /*--------------------------------------------------------------------------*/

            /**
             * Adds the key-value `pair` to `map`.
             *
             * @private
             * @param {Object} map The map to modify.
             * @param {Array} pair The key-value pair to add.
             * @returns {Object} Returns `map`.
             */
            function addMapEntry(map, pair) {
                // Don't return `Map#set` because it doesn't return the map instance in IE 11.
                map.set(pair[0], pair[1]);
                return map;
            }

            /**
             * Adds `value` to `set`.
             *
             * @private
             * @param {Object} set The set to modify.
             * @param {*} value The value to add.
             * @returns {Object} Returns `set`.
             */
            function addSetEntry(set, value) {
                set.add(value);
                return set;
            }

            /**
             * A faster alternative to `Function#apply`, this function invokes `func`
             * with the `this` binding of `thisArg` and the arguments of `args`.
             *
             * @private
             * @param {Function} func The function to invoke.
             * @param {*} thisArg The `this` binding of `func`.
             * @param {Array} args The arguments to invoke `func` with.
             * @returns {*} Returns the result of `func`.
             */
            function apply(func, thisArg, args) {
                var length = args.length;
                switch (length) {
                    case 0: return func.call(thisArg);
                    case 1: return func.call(thisArg, args[0]);
                    case 2: return func.call(thisArg, args[0], args[1]);
                    case 3: return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
            }

            /**
             * A specialized version of `baseAggregator` for arrays.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} setter The function to set `accumulator` values.
             * @param {Function} iteratee The iteratee to transform keys.
             * @param {Object} accumulator The initial aggregated object.
             * @returns {Function} Returns `accumulator`.
             */
            function arrayAggregator(array, setter, iteratee, accumulator) {
                var index = -1,
                    length = array.length;

                while (++index < length) {
                    var value = array[index];
                    setter(accumulator, value, iteratee(value), array);
                }
                return accumulator;
            }

            /**
             * Creates a new array concatenating `array` with `other`.
             *
             * @private
             * @param {Array} array The first array to concatenate.
             * @param {Array} other The second array to concatenate.
             * @returns {Array} Returns the new concatenated array.
             */
            function arrayConcat(array, other) {
                var index = -1,
                    length = array.length,
                    othIndex = -1,
                    othLength = other.length,
                    result = Array(length + othLength);

                while (++index < length) {
                    result[index] = array[index];
                }
                while (++othIndex < othLength) {
                    result[index++] = other[othIndex];
                }
                return result;
            }

            /**
             * A specialized version of `_.forEach` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns `array`.
             */
            function arrayEach(array, iteratee) {
                var index = -1,
                    length = array.length;

                while (++index < length) {
                    if (iteratee(array[index], index, array) === false) {
                        break;
                    }
                }
                return array;
            }

            /**
             * A specialized version of `_.forEachRight` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns `array`.
             */
            function arrayEachRight(array, iteratee) {
                var length = array.length;

                while (length--) {
                    if (iteratee(array[length], length, array) === false) {
                        break;
                    }
                }
                return array;
            }

            /**
             * A specialized version of `_.every` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {boolean} Returns `true` if all elements pass the predicate check,
             *  else `false`.
             */
            function arrayEvery(array, predicate) {
                var index = -1,
                    length = array.length;

                while (++index < length) {
                    if (!predicate(array[index], index, array)) {
                        return false;
                    }
                }
                return true;
            }

            /**
             * A specialized version of `_.filter` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {Array} Returns the new filtered array.
             */
            function arrayFilter(array, predicate) {
                var index = -1,
                    length = array.length,
                    resIndex = 0,
                    result = [];

                while (++index < length) {
                    var value = array[index];
                    if (predicate(value, index, array)) {
                        result[resIndex++] = value;
                    }
                }
                return result;
            }

            /**
             * A specialized version of `_.includes` for arrays without support for
             * specifying an index to search from.
             *
             * @private
             * @param {Array} array The array to search.
             * @param {*} target The value to search for.
             * @returns {boolean} Returns `true` if `target` is found, else `false`.
             */
            function arrayIncludes(array, value) {
                return !!array.length && baseIndexOf(array, value, 0) > -1;
            }

            /**
             * This function is like `arrayIncludes` except that it accepts a comparator.
             *
             * @private
             * @param {Array} array The array to search.
             * @param {*} target The value to search for.
             * @param {Function} comparator The comparator invoked per element.
             * @returns {boolean} Returns `true` if `target` is found, else `false`.
             */
            function arrayIncludesWith(array, value, comparator) {
                var index = -1,
                    length = array.length;

                while (++index < length) {
                    if (comparator(value, array[index])) {
                        return true;
                    }
                }
                return false;
            }

            /**
             * A specialized version of `_.map` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the new mapped array.
             */
            function arrayMap(array, iteratee) {
                var index = -1,
                    length = array.length,
                    result = Array(length);

                while (++index < length) {
                    result[index] = iteratee(array[index], index, array);
                }
                return result;
            }

            /**
             * Appends the elements of `values` to `array`.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {Array} values The values to append.
             * @returns {Array} Returns `array`.
             */
            function arrayPush(array, values) {
                var index = -1,
                    length = values.length,
                    offset = array.length;

                while (++index < length) {
                    array[offset + index] = values[index];
                }
                return array;
            }

            /**
             * A specialized version of `_.reduce` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {*} [accumulator] The initial value.
             * @param {boolean} [initAccum] Specify using the first element of `array` as
             *  the initial value.
             * @returns {*} Returns the accumulated value.
             */
            function arrayReduce(array, iteratee, accumulator, initAccum) {
                var index = -1,
                    length = array.length;

                if (initAccum && length) {
                    accumulator = array[++index];
                }
                while (++index < length) {
                    accumulator = iteratee(accumulator, array[index], index, array);
                }
                return accumulator;
            }

            /**
             * A specialized version of `_.reduceRight` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {*} [accumulator] The initial value.
             * @param {boolean} [initAccum] Specify using the last element of `array` as
             *  the initial value.
             * @returns {*} Returns the accumulated value.
             */
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                var length = array.length;
                if (initAccum && length) {
                    accumulator = array[--length];
                }
                while (length--) {
                    accumulator = iteratee(accumulator, array[length], length, array);
                }
                return accumulator;
            }

            /**
             * A specialized version of `_.some` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {boolean} Returns `true` if any element passes the predicate check,
             *  else `false`.
             */
            function arraySome(array, predicate) {
                var index = -1,
                    length = array.length;

                while (++index < length) {
                    if (predicate(array[index], index, array)) {
                        return true;
                    }
                }
                return false;
            }

            /**
             * The base implementation of methods like `_.max` and `_.min` which accepts a
             * `comparator` to determine the extremum value.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The iteratee invoked per iteration.
             * @param {Function} comparator The comparator used to compare values.
             * @returns {*} Returns the extremum value.
             */
            function baseExtremum(array, iteratee, comparator) {
                var index = -1,
                    length = array.length;

                while (++index < length) {
                    var value = array[index],
                        current = iteratee(value);

                    if (current != null && (computed === undefined
                                ? current === current
                                : comparator(current, computed)
                        )) {
                        var computed = current,
                            result = value;
                    }
                }
                return result;
            }

            /**
             * The base implementation of methods like `_.find` and `_.findKey`, without
             * support for iteratee shorthands, which iterates over `collection` using
             * `eachFunc`.
             *
             * @private
             * @param {Array|Object} collection The collection to search.
             * @param {Function} predicate The function invoked per iteration.
             * @param {Function} eachFunc The function to iterate over `collection`.
             * @param {boolean} [retKey] Specify returning the key of the found element
             *  instead of the element itself.
             * @returns {*} Returns the found element or its key, else `undefined`.
             */
            function baseFind(collection, predicate, eachFunc, retKey) {
                var result;
                eachFunc(collection, function(value, key, collection) {
                    if (predicate(value, key, collection)) {
                        result = retKey ? key : value;
                        return false;
                    }
                });
                return result;
            }

            /**
             * The base implementation of `_.findIndex` and `_.findLastIndex` without
             * support for iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to search.
             * @param {Function} predicate The function invoked per iteration.
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseFindIndex(array, predicate, fromRight) {
                var length = array.length,
                    index = fromRight ? length : -1;

                while ((fromRight ? index-- : ++index < length)) {
                    if (predicate(array[index], index, array)) {
                        return index;
                    }
                }
                return -1;
            }

            /**
             * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
             *
             * @private
             * @param {Array} array The array to search.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseIndexOf(array, value, fromIndex) {
                if (value !== value) {
                    return indexOfNaN(array, fromIndex);
                }
                var index = fromIndex - 1,
                    length = array.length;

                while (++index < length) {
                    if (array[index] === value) {
                        return index;
                    }
                }
                return -1;
            }

            /**
             * This function is like `baseIndexOf` except that it accepts a comparator.
             *
             * @private
             * @param {Array} array The array to search.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @param {Function} comparator The comparator invoked per element.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseIndexOfWith(array, value, fromIndex, comparator) {
                var index = fromIndex - 1,
                    length = array.length;

                while (++index < length) {
                    if (comparator(array[index], value)) {
                        return index;
                    }
                }
                return -1;
            }

            /**
             * The base implementation of `_.mean` and `_.meanBy` without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {number} Returns the mean.
             */
            function baseMean(array, iteratee) {
                var length = array ? array.length : 0;
                return length ? (baseSum(array, iteratee) / length) : NAN;
            }

            /**
             * The base implementation of `_.reduce` and `_.reduceRight`, without support
             * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
             *
             * @private
             * @param {Array|Object} collection The collection to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {*} accumulator The initial value.
             * @param {boolean} initAccum Specify using the first or last element of
             *  `collection` as the initial value.
             * @param {Function} eachFunc The function to iterate over `collection`.
             * @returns {*} Returns the accumulated value.
             */
            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                eachFunc(collection, function(value, index, collection) {
                    accumulator = initAccum
                        ? (initAccum = false, value)
                        : iteratee(accumulator, value, index, collection);
                });
                return accumulator;
            }

            /**
             * The base implementation of `_.sortBy` which uses `comparer` to define the
             * sort order of `array` and replaces criteria objects with their corresponding
             * values.
             *
             * @private
             * @param {Array} array The array to sort.
             * @param {Function} comparer The function to define sort order.
             * @returns {Array} Returns `array`.
             */
            function baseSortBy(array, comparer) {
                var length = array.length;

                array.sort(comparer);
                while (length--) {
                    array[length] = array[length].value;
                }
                return array;
            }

            /**
             * The base implementation of `_.sum` and `_.sumBy` without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {number} Returns the sum.
             */
            function baseSum(array, iteratee) {
                var result,
                    index = -1,
                    length = array.length;

                while (++index < length) {
                    var current = iteratee(array[index]);
                    if (current !== undefined) {
                        result = result === undefined ? current : (result + current);
                    }
                }
                return result;
            }

            /**
             * The base implementation of `_.times` without support for iteratee shorthands
             * or max array length checks.
             *
             * @private
             * @param {number} n The number of times to invoke `iteratee`.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the array of results.
             */
            function baseTimes(n, iteratee) {
                var index = -1,
                    result = Array(n);

                while (++index < n) {
                    result[index] = iteratee(index);
                }
                return result;
            }

            /**
             * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
             * of key-value pairs for `object` corresponding to the property names of `props`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array} props The property names to get values for.
             * @returns {Object} Returns the new array of key-value pairs.
             */
            function baseToPairs(object, props) {
                return arrayMap(props, function(key) {
                    return [key, object[key]];
                });
            }

            /**
             * The base implementation of `_.unary` without support for storing wrapper metadata.
             *
             * @private
             * @param {Function} func The function to cap arguments for.
             * @returns {Function} Returns the new function.
             */
            function baseUnary(func) {
                return function(value) {
                    return func(value);
                };
            }

            /**
             * The base implementation of `_.values` and `_.valuesIn` which creates an
             * array of `object` property values corresponding to the property names
             * of `props`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array} props The property names to get values for.
             * @returns {Object} Returns the array of property values.
             */
            function baseValues(object, props) {
                return arrayMap(props, function(key) {
                    return object[key];
                });
            }

            /**
             * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
             * that is not found in the character symbols.
             *
             * @private
             * @param {Array} strSymbols The string symbols to inspect.
             * @param {Array} chrSymbols The character symbols to find.
             * @returns {number} Returns the index of the first unmatched string symbol.
             */
            function charsStartIndex(strSymbols, chrSymbols) {
                var index = -1,
                    length = strSymbols.length;

                while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                return index;
            }

            /**
             * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
             * that is not found in the character symbols.
             *
             * @private
             * @param {Array} strSymbols The string symbols to inspect.
             * @param {Array} chrSymbols The character symbols to find.
             * @returns {number} Returns the index of the last unmatched string symbol.
             */
            function charsEndIndex(strSymbols, chrSymbols) {
                var index = strSymbols.length;

                while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                return index;
            }

            /**
             * Checks if `value` is a global object.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {null|Object} Returns `value` if it's a global object, else `null`.
             */
            function checkGlobal(value) {
                return (value && value.Object === Object) ? value : null;
            }

            /**
             * Compares values to sort them in ascending order.
             *
             * @private
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @returns {number} Returns the sort order indicator for `value`.
             */
            function compareAscending(value, other) {
                if (value !== other) {
                    var valIsNull = value === null,
                        valIsUndef = value === undefined,
                        valIsReflexive = value === value;

                    var othIsNull = other === null,
                        othIsUndef = other === undefined,
                        othIsReflexive = other === other;

                    if ((value > other && !othIsNull) || !valIsReflexive ||
                        (valIsNull && !othIsUndef && othIsReflexive) ||
                        (valIsUndef && othIsReflexive)) {
                        return 1;
                    }
                    if ((value < other && !valIsNull) || !othIsReflexive ||
                        (othIsNull && !valIsUndef && valIsReflexive) ||
                        (othIsUndef && valIsReflexive)) {
                        return -1;
                    }
                }
                return 0;
            }

            /**
             * Used by `_.orderBy` to compare multiple properties of a value to another
             * and stable sort them.
             *
             * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
             * specify an order of "desc" for descending or "asc" for ascending sort order
             * of corresponding values.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {boolean[]|string[]} orders The order to sort by for each property.
             * @returns {number} Returns the sort order indicator for `object`.
             */
            function compareMultiple(object, other, orders) {
                var index = -1,
                    objCriteria = object.criteria,
                    othCriteria = other.criteria,
                    length = objCriteria.length,
                    ordersLength = orders.length;

                while (++index < length) {
                    var result = compareAscending(objCriteria[index], othCriteria[index]);
                    if (result) {
                        if (index >= ordersLength) {
                            return result;
                        }
                        var order = orders[index];
                        return result * (order == 'desc' ? -1 : 1);
                    }
                }
                // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                // that causes it, under certain circumstances, to provide the same value for
                // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                // for more details.
                //
                // This also ensures a stable sort in V8 and other engines.
                // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                return object.index - other.index;
            }

            /**
             * Gets the number of `placeholder` occurrences in `array`.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} placeholder The placeholder to search for.
             * @returns {number} Returns the placeholder count.
             */
            function countHolders(array, placeholder) {
                var length = array.length,
                    result = 0;

                while (length--) {
                    if (array[length] === placeholder) {
                        result++;
                    }
                }
                return result;
            }

            /**
             * Creates a function that performs a mathematical operation on two values.
             *
             * @private
             * @param {Function} operator The function to perform the operation.
             * @returns {Function} Returns the new mathematical operation function.
             */
            function createMathOperation(operator) {
                return function(value, other) {
                    var result;
                    if (value === undefined && other === undefined) {
                        return 0;
                    }
                    if (value !== undefined) {
                        result = value;
                    }
                    if (other !== undefined) {
                        result = result === undefined ? other : operator(result, other);
                    }
                    return result;
                };
            }

            /**
             * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
             *
             * @private
             * @param {string} letter The matched letter to deburr.
             * @returns {string} Returns the deburred letter.
             */
            function deburrLetter(letter) {
                return deburredLetters[letter];
            }

            /**
             * Used by `_.escape` to convert characters to HTML entities.
             *
             * @private
             * @param {string} chr The matched character to escape.
             * @returns {string} Returns the escaped character.
             */
            function escapeHtmlChar(chr) {
                return htmlEscapes[chr];
            }

            /**
             * Used by `_.template` to escape characters for inclusion in compiled string literals.
             *
             * @private
             * @param {string} chr The matched character to escape.
             * @returns {string} Returns the escaped character.
             */
            function escapeStringChar(chr) {
                return '\\' + stringEscapes[chr];
            }

            /**
             * Gets the index at which the first occurrence of `NaN` is found in `array`.
             *
             * @private
             * @param {Array} array The array to search.
             * @param {number} fromIndex The index to search from.
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {number} Returns the index of the matched `NaN`, else `-1`.
             */
            function indexOfNaN(array, fromIndex, fromRight) {
                var length = array.length,
                    index = fromIndex + (fromRight ? 0 : -1);

                while ((fromRight ? index-- : ++index < length)) {
                    var other = array[index];
                    if (other !== other) {
                        return index;
                    }
                }
                return -1;
            }

            /**
             * Checks if `value` is a host object in IE < 9.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
             */
            function isHostObject(value) {
                // Many host objects are `Object` objects that can coerce to strings
                // despite having improperly defined `toString` methods.
                var result = false;
                if (value != null && typeof value.toString != 'function') {
                    try {
                        result = !!(value + '');
                    } catch (e) {}
                }
                return result;
            }

            /**
             * Checks if `value` is a valid array-like index.
             *
             * @private
             * @param {*} value The value to check.
             * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
             * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
             */
            function isIndex(value, length) {
                value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return value > -1 && value % 1 == 0 && value < length;
            }

            /**
             * Converts `iterator` to an array.
             *
             * @private
             * @param {Object} iterator The iterator to convert.
             * @returns {Array} Returns the converted array.
             */
            function iteratorToArray(iterator) {
                var data,
                    result = [];

                while (!(data = iterator.next()).done) {
                    result.push(data.value);
                }
                return result;
            }

            /**
             * Converts `map` to an array.
             *
             * @private
             * @param {Object} map The map to convert.
             * @returns {Array} Returns the converted array.
             */
            function mapToArray(map) {
                var index = -1,
                    result = Array(map.size);

                map.forEach(function(value, key) {
                    result[++index] = [key, value];
                });
                return result;
            }

            /**
             * Replaces all `placeholder` elements in `array` with an internal placeholder
             * and returns an array of their indexes.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {*} placeholder The placeholder to replace.
             * @returns {Array} Returns the new array of placeholder indexes.
             */
            function replaceHolders(array, placeholder) {
                var index = -1,
                    length = array.length,
                    resIndex = 0,
                    result = [];

                while (++index < length) {
                    var value = array[index];
                    if (value === placeholder || value === PLACEHOLDER) {
                        array[index] = PLACEHOLDER;
                        result[resIndex++] = index;
                    }
                }
                return result;
            }

            /**
             * Converts `set` to an array.
             *
             * @private
             * @param {Object} set The set to convert.
             * @returns {Array} Returns the converted array.
             */
            function setToArray(set) {
                var index = -1,
                    result = Array(set.size);

                set.forEach(function(value) {
                    result[++index] = value;
                });
                return result;
            }

            /**
             * Gets the number of symbols in `string`.
             *
             * @private
             * @param {string} string The string to inspect.
             * @returns {number} Returns the string size.
             */
            function stringSize(string) {
                if (!(string && reHasComplexSymbol.test(string))) {
                    return string.length;
                }
                var result = reComplexSymbol.lastIndex = 0;
                while (reComplexSymbol.test(string)) {
                    result++;
                }
                return result;
            }

            /**
             * Converts `string` to an array.
             *
             * @private
             * @param {string} string The string to convert.
             * @returns {Array} Returns the converted array.
             */
            function stringToArray(string) {
                return string.match(reComplexSymbol);
            }

            /**
             * Used by `_.unescape` to convert HTML entities to characters.
             *
             * @private
             * @param {string} chr The matched character to unescape.
             * @returns {string} Returns the unescaped character.
             */
            function unescapeHtmlChar(chr) {
                return htmlUnescapes[chr];
            }

            /*--------------------------------------------------------------------------*/

            /**
             * Create a new pristine `lodash` function using the `context` object.
             *
             * @static
             * @memberOf _
             * @since 1.1.0
             * @category Util
             * @param {Object} [context=root] The context object.
             * @returns {Function} Returns a new `lodash` function.
             * @example
             *
             * _.mixin({ 'foo': _.constant('foo') });
             *
             * var lodash = _.runInContext();
             * lodash.mixin({ 'bar': lodash.constant('bar') });
             *
             * _.isFunction(_.foo);
             * // => true
             * _.isFunction(_.bar);
             * // => false
             *
             * lodash.isFunction(lodash.foo);
             * // => false
             * lodash.isFunction(lodash.bar);
             * // => true
             *
             * // Use `context` to mock `Date#getTime` use in `_.now`.
             * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
             *
             * // Create a suped-up `defer` in Node.js.
             * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
             */
            function runInContext(context) {
                context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;

                /** Built-in constructor references. */
                var Date = context.Date,
                    Error = context.Error,
                    Math = context.Math,
                    RegExp = context.RegExp,
                    TypeError = context.TypeError;

                /** Used for built-in method references. */
                var arrayProto = context.Array.prototype,
                    objectProto = context.Object.prototype,
                    stringProto = context.String.prototype;

                /** Used to resolve the decompiled source of functions. */
                var funcToString = context.Function.prototype.toString;

                /** Used to check objects for own properties. */
                var hasOwnProperty = objectProto.hasOwnProperty;

                /** Used to generate unique IDs. */
                var idCounter = 0;

                /** Used to infer the `Object` constructor. */
                var objectCtorString = funcToString.call(Object);

                /**
                 * Used to resolve the
                 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                 * of values.
                 */
                var objectToString = objectProto.toString;

                /** Used to restore the original `_` reference in `_.noConflict`. */
                var oldDash = root._;

                /** Used to detect if a method is native. */
                var reIsNative = RegExp('^' +
                    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
                        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                );

                /** Built-in value references. */
                var Buffer = moduleExports ? context.Buffer : undefined,
                    Reflect = context.Reflect,
                    Symbol = context.Symbol,
                    Uint8Array = context.Uint8Array,
                    clearTimeout = context.clearTimeout,
                    enumerate = Reflect ? Reflect.enumerate : undefined,
                    getOwnPropertySymbols = Object.getOwnPropertySymbols,
                    iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,
                    objectCreate = Object.create,
                    propertyIsEnumerable = objectProto.propertyIsEnumerable,
                    setTimeout = context.setTimeout,
                    splice = arrayProto.splice;

                /* Built-in method references for those with the same name as other `lodash` methods. */
                var nativeCeil = Math.ceil,
                    nativeFloor = Math.floor,
                    nativeGetPrototype = Object.getPrototypeOf,
                    nativeIsFinite = context.isFinite,
                    nativeJoin = arrayProto.join,
                    nativeKeys = Object.keys,
                    nativeMax = Math.max,
                    nativeMin = Math.min,
                    nativeParseInt = context.parseInt,
                    nativeRandom = Math.random,
                    nativeReplace = stringProto.replace,
                    nativeReverse = arrayProto.reverse,
                    nativeSplit = stringProto.split;

                /* Built-in method references that are verified to be native. */
                var DataView = getNative(context, 'DataView'),
                    Map = getNative(context, 'Map'),
                    Promise = getNative(context, 'Promise'),
                    Set = getNative(context, 'Set'),
                    WeakMap = getNative(context, 'WeakMap'),
                    nativeCreate = getNative(Object, 'create');

                /** Used to store function metadata. */
                var metaMap = WeakMap && new WeakMap;

                /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
                var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

                /** Used to lookup unminified function names. */
                var realNames = {};

                /** Used to detect maps, sets, and weakmaps. */
                var dataViewCtorString = toSource(DataView),
                    mapCtorString = toSource(Map),
                    promiseCtorString = toSource(Promise),
                    setCtorString = toSource(Set),
                    weakMapCtorString = toSource(WeakMap);

                /** Used to convert symbols to primitives and strings. */
                var symbolProto = Symbol ? Symbol.prototype : undefined,
                    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
                    symbolToString = symbolProto ? symbolProto.toString : undefined;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a `lodash` object which wraps `value` to enable implicit method
                 * chain sequences. Methods that operate on and return arrays, collections,
                 * and functions can be chained together. Methods that retrieve a single value
                 * or may return a primitive value will automatically end the chain sequence
                 * and return the unwrapped value. Otherwise, the value must be unwrapped
                 * with `_#value`.
                 *
                 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
                 * enabled using `_.chain`.
                 *
                 * The execution of chained methods is lazy, that is, it's deferred until
                 * `_#value` is implicitly or explicitly called.
                 *
                 * Lazy evaluation allows several methods to support shortcut fusion.
                 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
                 * the creation of intermediate arrays and can greatly reduce the number of
                 * iteratee executions. Sections of a chain sequence qualify for shortcut
                 * fusion if the section is applied to an array of at least `200` elements
                 * and any iteratees accept only one argument. The heuristic for whether a
                 * section qualifies for shortcut fusion is subject to change.
                 *
                 * Chaining is supported in custom builds as long as the `_#value` method is
                 * directly or indirectly included in the build.
                 *
                 * In addition to lodash methods, wrappers have `Array` and `String` methods.
                 *
                 * The wrapper `Array` methods are:
                 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
                 *
                 * The wrapper `String` methods are:
                 * `replace` and `split`
                 *
                 * The wrapper methods that support shortcut fusion are:
                 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
                 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
                 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
                 *
                 * The chainable wrapper methods are:
                 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
                 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
                 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
                 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
                 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
                 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
                 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
                 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
                 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
                 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
                 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
                 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
                 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
                 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
                 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
                 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
                 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
                 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
                 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
                 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
                 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
                 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
                 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
                 * `zipObject`, `zipObjectDeep`, and `zipWith`
                 *
                 * The wrapper methods that are **not** chainable by default are:
                 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
                 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,
                 * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,
                 * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,
                 * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
                 * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,
                 * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,
                 * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`, `isBuffer`,
                 * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`, `isError`,
                 * `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`, `isMatch`,
                 * `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`, `isNumber`,
                 * `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`, `isSafeInteger`,
                 * `isSet`, `isString`, `isUndefined`, `isTypedArray`, `isWeakMap`, `isWeakSet`,
                 * `join`, `kebabCase`, `last`, `lastIndexOf`, `lowerCase`, `lowerFirst`,
                 * `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`, `min`, `minBy`, `multiply`,
                 * `noConflict`, `noop`, `now`, `nth`, `pad`, `padEnd`, `padStart`, `parseInt`,
                 * `pop`, `random`, `reduce`, `reduceRight`, `repeat`, `result`, `round`,
                 * `runInContext`, `sample`, `shift`, `size`, `snakeCase`, `some`, `sortedIndex`,
                 * `sortedIndexBy`, `sortedLastIndex`, `sortedLastIndexBy`, `startCase`,
                 * `startsWith`, `subtract`, `sum`, `sumBy`, `template`, `times`, `toInteger`,
                 * `toJSON`, `toLength`, `toLower`, `toNumber`, `toSafeInteger`, `toString`,
                 * `toUpper`, `trim`, `trimEnd`, `trimStart`, `truncate`, `unescape`,
                 * `uniqueId`, `upperCase`, `upperFirst`, `value`, and `words`
                 *
                 * @name _
                 * @constructor
                 * @category Seq
                 * @param {*} value The value to wrap in a `lodash` instance.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * function square(n) {
     *   return n * n;
     * }
                 *
                 * var wrapped = _([1, 2, 3]);
                 *
                 * // Returns an unwrapped value.
                 * wrapped.reduce(_.add);
                 * // => 6
                 *
                 * // Returns a wrapped value.
                 * var squares = wrapped.map(square);
                 *
                 * _.isArray(squares);
                 * // => false
                 *
                 * _.isArray(squares.value());
                 * // => true
                 */
                function lodash(value) {
                    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                        if (value instanceof LodashWrapper) {
                            return value;
                        }
                        if (hasOwnProperty.call(value, '__wrapped__')) {
                            return wrapperClone(value);
                        }
                    }
                    return new LodashWrapper(value);
                }

                /**
                 * The function whose prototype chain sequence wrappers inherit from.
                 *
                 * @private
                 */
                function baseLodash() {
                    // No operation performed.
                }

                /**
                 * The base constructor for creating `lodash` wrapper objects.
                 *
                 * @private
                 * @param {*} value The value to wrap.
                 * @param {boolean} [chainAll] Enable explicit method chain sequences.
                 */
                function LodashWrapper(value, chainAll) {
                    this.__wrapped__ = value;
                    this.__actions__ = [];
                    this.__chain__ = !!chainAll;
                    this.__index__ = 0;
                    this.__values__ = undefined;
                }

                /**
                 * By default, the template delimiters used by lodash are like those in
                 * embedded Ruby (ERB). Change the following template settings to use
                 * alternative delimiters.
                 *
                 * @static
                 * @memberOf _
                 * @type {Object}
                 */
                lodash.templateSettings = {

                    /**
                     * Used to detect `data` property values to be HTML-escaped.
                     *
                     * @memberOf _.templateSettings
                     * @type {RegExp}
                     */
                    'escape': reEscape,

                    /**
                     * Used to detect code to be evaluated.
                     *
                     * @memberOf _.templateSettings
                     * @type {RegExp}
                     */
                    'evaluate': reEvaluate,

                    /**
                     * Used to detect `data` property values to inject.
                     *
                     * @memberOf _.templateSettings
                     * @type {RegExp}
                     */
                    'interpolate': reInterpolate,

                    /**
                     * Used to reference the data object in the template text.
                     *
                     * @memberOf _.templateSettings
                     * @type {string}
                     */
                    'variable': '',

                    /**
                     * Used to import variables into the compiled template.
                     *
                     * @memberOf _.templateSettings
                     * @type {Object}
                     */
                    'imports': {

                        /**
                         * A reference to the `lodash` function.
                         *
                         * @memberOf _.templateSettings.imports
                         * @type {Function}
                         */
                        '_': lodash
                    }
                };

                // Ensure wrappers are instances of `baseLodash`.
                lodash.prototype = baseLodash.prototype;
                lodash.prototype.constructor = lodash;

                LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                LodashWrapper.prototype.constructor = LodashWrapper;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                 *
                 * @private
                 * @constructor
                 * @param {*} value The value to wrap.
                 */
                function LazyWrapper(value) {
                    this.__wrapped__ = value;
                    this.__actions__ = [];
                    this.__dir__ = 1;
                    this.__filtered__ = false;
                    this.__iteratees__ = [];
                    this.__takeCount__ = MAX_ARRAY_LENGTH;
                    this.__views__ = [];
                }

                /**
                 * Creates a clone of the lazy wrapper object.
                 *
                 * @private
                 * @name clone
                 * @memberOf LazyWrapper
                 * @returns {Object} Returns the cloned `LazyWrapper` object.
                 */
                function lazyClone() {
                    var result = new LazyWrapper(this.__wrapped__);
                    result.__actions__ = copyArray(this.__actions__);
                    result.__dir__ = this.__dir__;
                    result.__filtered__ = this.__filtered__;
                    result.__iteratees__ = copyArray(this.__iteratees__);
                    result.__takeCount__ = this.__takeCount__;
                    result.__views__ = copyArray(this.__views__);
                    return result;
                }

                /**
                 * Reverses the direction of lazy iteration.
                 *
                 * @private
                 * @name reverse
                 * @memberOf LazyWrapper
                 * @returns {Object} Returns the new reversed `LazyWrapper` object.
                 */
                function lazyReverse() {
                    if (this.__filtered__) {
                        var result = new LazyWrapper(this);
                        result.__dir__ = -1;
                        result.__filtered__ = true;
                    } else {
                        result = this.clone();
                        result.__dir__ *= -1;
                    }
                    return result;
                }

                /**
                 * Extracts the unwrapped value from its lazy wrapper.
                 *
                 * @private
                 * @name value
                 * @memberOf LazyWrapper
                 * @returns {*} Returns the unwrapped value.
                 */
                function lazyValue() {
                    var array = this.__wrapped__.value(),
                        dir = this.__dir__,
                        isArr = isArray(array),
                        isRight = dir < 0,
                        arrLength = isArr ? array.length : 0,
                        view = getView(0, arrLength, this.__views__),
                        start = view.start,
                        end = view.end,
                        length = end - start,
                        index = isRight ? end : (start - 1),
                        iteratees = this.__iteratees__,
                        iterLength = iteratees.length,
                        resIndex = 0,
                        takeCount = nativeMin(length, this.__takeCount__);

                    if (!isArr || arrLength < LARGE_ARRAY_SIZE ||
                        (arrLength == length && takeCount == length)) {
                        return baseWrapperValue(array, this.__actions__);
                    }
                    var result = [];

                    outer:
                        while (length-- && resIndex < takeCount) {
                            index += dir;

                            var iterIndex = -1,
                                value = array[index];

                            while (++iterIndex < iterLength) {
                                var data = iteratees[iterIndex],
                                    iteratee = data.iteratee,
                                    type = data.type,
                                    computed = iteratee(value);

                                if (type == LAZY_MAP_FLAG) {
                                    value = computed;
                                } else if (!computed) {
                                    if (type == LAZY_FILTER_FLAG) {
                                        continue outer;
                                    } else {
                                        break outer;
                                    }
                                }
                            }
                            result[resIndex++] = value;
                        }
                    return result;
                }

                // Ensure `LazyWrapper` is an instance of `baseLodash`.
                LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                LazyWrapper.prototype.constructor = LazyWrapper;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a hash object.
                 *
                 * @private
                 * @constructor
                 * @returns {Object} Returns the new hash object.
                 */
                function Hash() {}

                /**
                 * Removes `key` and its value from the hash.
                 *
                 * @private
                 * @param {Object} hash The hash to modify.
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function hashDelete(hash, key) {
                    return hashHas(hash, key) && delete hash[key];
                }

                /**
                 * Gets the hash value for `key`.
                 *
                 * @private
                 * @param {Object} hash The hash to query.
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function hashGet(hash, key) {
                    if (nativeCreate) {
                        var result = hash[key];
                        return result === HASH_UNDEFINED ? undefined : result;
                    }
                    return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
                }

                /**
                 * Checks if a hash value for `key` exists.
                 *
                 * @private
                 * @param {Object} hash The hash to query.
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function hashHas(hash, key) {
                    return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
                }

                /**
                 * Sets the hash `key` to `value`.
                 *
                 * @private
                 * @param {Object} hash The hash to modify.
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 */
                function hashSet(hash, key, value) {
                    hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
                }

                // Avoid inheriting from `Object.prototype` when possible.
                Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a map cache object to store key-value pairs.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [values] The values to cache.
                 */
                function MapCache(values) {
                    var index = -1,
                        length = values ? values.length : 0;

                    this.clear();
                    while (++index < length) {
                        var entry = values[index];
                        this.set(entry[0], entry[1]);
                    }
                }

                /**
                 * Removes all key-value entries from the map.
                 *
                 * @private
                 * @name clear
                 * @memberOf MapCache
                 */
                function mapClear() {
                    this.__data__ = {
                        'hash': new Hash,
                        'map': Map ? new Map : [],
                        'string': new Hash
                    };
                }

                /**
                 * Removes `key` and its value from the map.
                 *
                 * @private
                 * @name delete
                 * @memberOf MapCache
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function mapDelete(key) {
                    var data = this.__data__;
                    if (isKeyable(key)) {
                        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
                    }
                    return Map ? data.map['delete'](key) : assocDelete(data.map, key);
                }

                /**
                 * Gets the map value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf MapCache
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function mapGet(key) {
                    var data = this.__data__;
                    if (isKeyable(key)) {
                        return hashGet(typeof key == 'string' ? data.string : data.hash, key);
                    }
                    return Map ? data.map.get(key) : assocGet(data.map, key);
                }

                /**
                 * Checks if a map value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf MapCache
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function mapHas(key) {
                    var data = this.__data__;
                    if (isKeyable(key)) {
                        return hashHas(typeof key == 'string' ? data.string : data.hash, key);
                    }
                    return Map ? data.map.has(key) : assocHas(data.map, key);
                }

                /**
                 * Sets the map `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf MapCache
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the map cache instance.
                 */
                function mapSet(key, value) {
                    var data = this.__data__;
                    if (isKeyable(key)) {
                        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
                    } else if (Map) {
                        data.map.set(key, value);
                    } else {
                        assocSet(data.map, key, value);
                    }
                    return this;
                }

                // Add methods to `MapCache`.
                MapCache.prototype.clear = mapClear;
                MapCache.prototype['delete'] = mapDelete;
                MapCache.prototype.get = mapGet;
                MapCache.prototype.has = mapHas;
                MapCache.prototype.set = mapSet;

                /*------------------------------------------------------------------------*/

                /**
                 *
                 * Creates a set cache object to store unique values.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [values] The values to cache.
                 */
                function SetCache(values) {
                    var index = -1,
                        length = values ? values.length : 0;

                    this.__data__ = new MapCache;
                    while (++index < length) {
                        this.push(values[index]);
                    }
                }

                /**
                 * Checks if `value` is in `cache`.
                 *
                 * @private
                 * @param {Object} cache The set cache to search.
                 * @param {*} value The value to search for.
                 * @returns {number} Returns `true` if `value` is found, else `false`.
                 */
                function cacheHas(cache, value) {
                    var map = cache.__data__;
                    if (isKeyable(value)) {
                        var data = map.__data__,
                            hash = typeof value == 'string' ? data.string : data.hash;

                        return hash[value] === HASH_UNDEFINED;
                    }
                    return map.has(value);
                }

                /**
                 * Adds `value` to the set cache.
                 *
                 * @private
                 * @name push
                 * @memberOf SetCache
                 * @param {*} value The value to cache.
                 */
                function cachePush(value) {
                    var map = this.__data__;
                    if (isKeyable(value)) {
                        var data = map.__data__,
                            hash = typeof value == 'string' ? data.string : data.hash;

                        hash[value] = HASH_UNDEFINED;
                    }
                    else {
                        map.set(value, HASH_UNDEFINED);
                    }
                }

                // Add methods to `SetCache`.
                SetCache.prototype.push = cachePush;

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a stack cache object to store key-value pairs.
                 *
                 * @private
                 * @constructor
                 * @param {Array} [values] The values to cache.
                 */
                function Stack(values) {
                    var index = -1,
                        length = values ? values.length : 0;

                    this.clear();
                    while (++index < length) {
                        var entry = values[index];
                        this.set(entry[0], entry[1]);
                    }
                }

                /**
                 * Removes all key-value entries from the stack.
                 *
                 * @private
                 * @name clear
                 * @memberOf Stack
                 */
                function stackClear() {
                    this.__data__ = { 'array': [], 'map': null };
                }

                /**
                 * Removes `key` and its value from the stack.
                 *
                 * @private
                 * @name delete
                 * @memberOf Stack
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function stackDelete(key) {
                    var data = this.__data__,
                        array = data.array;

                    return array ? assocDelete(array, key) : data.map['delete'](key);
                }

                /**
                 * Gets the stack value for `key`.
                 *
                 * @private
                 * @name get
                 * @memberOf Stack
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function stackGet(key) {
                    var data = this.__data__,
                        array = data.array;

                    return array ? assocGet(array, key) : data.map.get(key);
                }

                /**
                 * Checks if a stack value for `key` exists.
                 *
                 * @private
                 * @name has
                 * @memberOf Stack
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function stackHas(key) {
                    var data = this.__data__,
                        array = data.array;

                    return array ? assocHas(array, key) : data.map.has(key);
                }

                /**
                 * Sets the stack `key` to `value`.
                 *
                 * @private
                 * @name set
                 * @memberOf Stack
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns the stack cache instance.
                 */
                function stackSet(key, value) {
                    var data = this.__data__,
                        array = data.array;

                    if (array) {
                        if (array.length < (LARGE_ARRAY_SIZE - 1)) {
                            assocSet(array, key, value);
                        } else {
                            data.array = null;
                            data.map = new MapCache(array);
                        }
                    }
                    var map = data.map;
                    if (map) {
                        map.set(key, value);
                    }
                    return this;
                }

                // Add methods to `Stack`.
                Stack.prototype.clear = stackClear;
                Stack.prototype['delete'] = stackDelete;
                Stack.prototype.get = stackGet;
                Stack.prototype.has = stackHas;
                Stack.prototype.set = stackSet;

                /*------------------------------------------------------------------------*/

                /**
                 * Removes `key` and its value from the associative array.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {string} key The key of the value to remove.
                 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                 */
                function assocDelete(array, key) {
                    var index = assocIndexOf(array, key);
                    if (index < 0) {
                        return false;
                    }
                    var lastIndex = array.length - 1;
                    if (index == lastIndex) {
                        array.pop();
                    } else {
                        splice.call(array, index, 1);
                    }
                    return true;
                }

                /**
                 * Gets the associative array value for `key`.
                 *
                 * @private
                 * @param {Array} array The array to query.
                 * @param {string} key The key of the value to get.
                 * @returns {*} Returns the entry value.
                 */
                function assocGet(array, key) {
                    var index = assocIndexOf(array, key);
                    return index < 0 ? undefined : array[index][1];
                }

                /**
                 * Checks if an associative array value for `key` exists.
                 *
                 * @private
                 * @param {Array} array The array to query.
                 * @param {string} key The key of the entry to check.
                 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                 */
                function assocHas(array, key) {
                    return assocIndexOf(array, key) > -1;
                }

                /**
                 * Gets the index at which the `key` is found in `array` of key-value pairs.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {*} key The key to search for.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function assocIndexOf(array, key) {
                    var length = array.length;
                    while (length--) {
                        if (eq(array[length][0], key)) {
                            return length;
                        }
                    }
                    return -1;
                }

                /**
                 * Sets the associative array `key` to `value`.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {string} key The key of the value to set.
                 * @param {*} value The value to set.
                 */
                function assocSet(array, key, value) {
                    var index = assocIndexOf(array, key);
                    if (index < 0) {
                        array.push([key, value]);
                    } else {
                        array[index][1] = value;
                    }
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Used by `_.defaults` to customize its `_.assignIn` use.
                 *
                 * @private
                 * @param {*} objValue The destination value.
                 * @param {*} srcValue The source value.
                 * @param {string} key The key of the property to assign.
                 * @param {Object} object The parent object of `objValue`.
                 * @returns {*} Returns the value to assign.
                 */
                function assignInDefaults(objValue, srcValue, key, object) {
                    if (objValue === undefined ||
                        (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                        return srcValue;
                    }
                    return objValue;
                }

                /**
                 * This function is like `assignValue` except that it doesn't assign
                 * `undefined` values.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {string} key The key of the property to assign.
                 * @param {*} value The value to assign.
                 */
                function assignMergeValue(object, key, value) {
                    if ((value !== undefined && !eq(object[key], value)) ||
                        (typeof key == 'number' && value === undefined && !(key in object))) {
                        object[key] = value;
                    }
                }

                /**
                 * Assigns `value` to `key` of `object` if the existing value is not equivalent
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {string} key The key of the property to assign.
                 * @param {*} value The value to assign.
                 */
                function assignValue(object, key, value) {
                    var objValue = object[key];
                    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                        (value === undefined && !(key in object))) {
                        object[key] = value;
                    }
                }

                /**
                 * Aggregates elements of `collection` on `accumulator` with keys transformed
                 * by `iteratee` and values set by `setter`.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} setter The function to set `accumulator` values.
                 * @param {Function} iteratee The iteratee to transform keys.
                 * @param {Object} accumulator The initial aggregated object.
                 * @returns {Function} Returns `accumulator`.
                 */
                function baseAggregator(collection, setter, iteratee, accumulator) {
                    baseEach(collection, function(value, key, collection) {
                        setter(accumulator, value, iteratee(value), collection);
                    });
                    return accumulator;
                }

                /**
                 * The base implementation of `_.assign` without support for multiple sources
                 * or `customizer` functions.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @returns {Object} Returns `object`.
                 */
                function baseAssign(object, source) {
                    return object && copyObject(source, keys(source), object);
                }

                /**
                 * The base implementation of `_.at` without support for individual paths.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {string[]} paths The property paths of elements to pick.
                 * @returns {Array} Returns the new array of picked elements.
                 */
                function baseAt(object, paths) {
                    var index = -1,
                        isNil = object == null,
                        length = paths.length,
                        result = Array(length);

                    while (++index < length) {
                        result[index] = isNil ? undefined : get(object, paths[index]);
                    }
                    return result;
                }

                /**
                 * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
                 *
                 * @private
                 * @param {number} number The number to clamp.
                 * @param {number} [lower] The lower bound.
                 * @param {number} upper The upper bound.
                 * @returns {number} Returns the clamped number.
                 */
                function baseClamp(number, lower, upper) {
                    if (number === number) {
                        if (upper !== undefined) {
                            number = number <= upper ? number : upper;
                        }
                        if (lower !== undefined) {
                            number = number >= lower ? number : lower;
                        }
                    }
                    return number;
                }

                /**
                 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                 * traversed objects.
                 *
                 * @private
                 * @param {*} value The value to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @param {boolean} [isFull] Specify a clone including symbols.
                 * @param {Function} [customizer] The function to customize cloning.
                 * @param {string} [key] The key of `value`.
                 * @param {Object} [object] The parent object of `value`.
                 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                 * @returns {*} Returns the cloned value.
                 */
                function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
                    var result;
                    if (customizer) {
                        result = object ? customizer(value, key, object, stack) : customizer(value);
                    }
                    if (result !== undefined) {
                        return result;
                    }
                    if (!isObject(value)) {
                        return value;
                    }
                    var isArr = isArray(value);
                    if (isArr) {
                        result = initCloneArray(value);
                        if (!isDeep) {
                            return copyArray(value, result);
                        }
                    } else {
                        var tag = getTag(value),
                            isFunc = tag == funcTag || tag == genTag;

                        if (isBuffer(value)) {
                            return cloneBuffer(value, isDeep);
                        }
                        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                            if (isHostObject(value)) {
                                return object ? value : {};
                            }
                            result = initCloneObject(isFunc ? {} : value);
                            if (!isDeep) {
                                return copySymbols(value, baseAssign(result, value));
                            }
                        } else {
                            if (!cloneableTags[tag]) {
                                return object ? value : {};
                            }
                            result = initCloneByTag(value, tag, baseClone, isDeep);
                        }
                    }
                    // Check for circular references and return its corresponding clone.
                    stack || (stack = new Stack);
                    var stacked = stack.get(value);
                    if (stacked) {
                        return stacked;
                    }
                    stack.set(value, result);

                    if (!isArr) {
                        var props = isFull ? getAllKeys(value) : keys(value);
                    }
                    // Recursively populate clone (susceptible to call stack limits).
                    arrayEach(props || value, function(subValue, key) {
                        if (props) {
                            key = subValue;
                            subValue = value[key];
                        }
                        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
                    });
                    return result;
                }

                /**
                 * The base implementation of `_.conforms` which doesn't clone `source`.
                 *
                 * @private
                 * @param {Object} source The object of property predicates to conform to.
                 * @returns {Function} Returns the new function.
                 */
                function baseConforms(source) {
                    var props = keys(source),
                        length = props.length;

                    return function(object) {
                        if (object == null) {
                            return !length;
                        }
                        var index = length;
                        while (index--) {
                            var key = props[index],
                                predicate = source[key],
                                value = object[key];

                            if ((value === undefined &&
                                !(key in Object(object))) || !predicate(value)) {
                                return false;
                            }
                        }
                        return true;
                    };
                }

                /**
                 * The base implementation of `_.create` without support for assigning
                 * properties to the created object.
                 *
                 * @private
                 * @param {Object} prototype The object to inherit from.
                 * @returns {Object} Returns the new object.
                 */
                function baseCreate(proto) {
                    return isObject(proto) ? objectCreate(proto) : {};
                }

                /**
                 * The base implementation of `_.delay` and `_.defer` which accepts an array
                 * of `func` arguments.
                 *
                 * @private
                 * @param {Function} func The function to delay.
                 * @param {number} wait The number of milliseconds to delay invocation.
                 * @param {Object} args The arguments to provide to `func`.
                 * @returns {number} Returns the timer id.
                 */
                function baseDelay(func, wait, args) {
                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    return setTimeout(function() { func.apply(undefined, args); }, wait);
                }

                /**
                 * The base implementation of methods like `_.difference` without support
                 * for excluding multiple arrays or iteratee shorthands.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Array} values The values to exclude.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of filtered values.
                 */
                function baseDifference(array, values, iteratee, comparator) {
                    var index = -1,
                        includes = arrayIncludes,
                        isCommon = true,
                        length = array.length,
                        result = [],
                        valuesLength = values.length;

                    if (!length) {
                        return result;
                    }
                    if (iteratee) {
                        values = arrayMap(values, baseUnary(iteratee));
                    }
                    if (comparator) {
                        includes = arrayIncludesWith;
                        isCommon = false;
                    }
                    else if (values.length >= LARGE_ARRAY_SIZE) {
                        includes = cacheHas;
                        isCommon = false;
                        values = new SetCache(values);
                    }
                    outer:
                        while (++index < length) {
                            var value = array[index],
                                computed = iteratee ? iteratee(value) : value;

                            if (isCommon && computed === computed) {
                                var valuesIndex = valuesLength;
                                while (valuesIndex--) {
                                    if (values[valuesIndex] === computed) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                            else if (!includes(values, computed, comparator)) {
                                result.push(value);
                            }
                        }
                    return result;
                }

                /**
                 * The base implementation of `_.forEach` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 */
                var baseEach = createBaseEach(baseForOwn);

                /**
                 * The base implementation of `_.forEachRight` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 */
                var baseEachRight = createBaseEach(baseForOwnRight, true);

                /**
                 * The base implementation of `_.every` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} predicate The function invoked per iteration.
                 * @returns {boolean} Returns `true` if all elements pass the predicate check,
                 *  else `false`
                 */
                function baseEvery(collection, predicate) {
                    var result = true;
                    baseEach(collection, function(value, index, collection) {
                        result = !!predicate(value, index, collection);
                        return result;
                    });
                    return result;
                }

                /**
                 * The base implementation of `_.fill` without an iteratee call guard.
                 *
                 * @private
                 * @param {Array} array The array to fill.
                 * @param {*} value The value to fill `array` with.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns `array`.
                 */
                function baseFill(array, value, start, end) {
                    var length = array.length;

                    start = toInteger(start);
                    if (start < 0) {
                        start = -start > length ? 0 : (length + start);
                    }
                    end = (end === undefined || end > length) ? length : toInteger(end);
                    if (end < 0) {
                        end += length;
                    }
                    end = start > end ? 0 : toLength(end);
                    while (start < end) {
                        array[start++] = value;
                    }
                    return array;
                }

                /**
                 * The base implementation of `_.filter` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} predicate The function invoked per iteration.
                 * @returns {Array} Returns the new filtered array.
                 */
                function baseFilter(collection, predicate) {
                    var result = [];
                    baseEach(collection, function(value, index, collection) {
                        if (predicate(value, index, collection)) {
                            result.push(value);
                        }
                    });
                    return result;
                }

                /**
                 * The base implementation of `_.flatten` with support for restricting flattening.
                 *
                 * @private
                 * @param {Array} array The array to flatten.
                 * @param {number} depth The maximum recursion depth.
                 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
                 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
                 * @param {Array} [result=[]] The initial result value.
                 * @returns {Array} Returns the new flattened array.
                 */
                function baseFlatten(array, depth, predicate, isStrict, result) {
                    var index = -1,
                        length = array.length;

                    predicate || (predicate = isFlattenable);
                    result || (result = []);

                    while (++index < length) {
                        var value = array[index];
                        if (depth > 0 && predicate(value)) {
                            if (depth > 1) {
                                // Recursively flatten arrays (susceptible to call stack limits).
                                baseFlatten(value, depth - 1, predicate, isStrict, result);
                            } else {
                                arrayPush(result, value);
                            }
                        } else if (!isStrict) {
                            result[result.length] = value;
                        }
                    }
                    return result;
                }

                /**
                 * The base implementation of `baseForOwn` which iterates over `object`
                 * properties returned by `keysFunc` and invokes `iteratee` for each property.
                 * Iteratee functions may exit iteration early by explicitly returning `false`.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @returns {Object} Returns `object`.
                 */
                var baseFor = createBaseFor();

                /**
                 * This function is like `baseFor` except that it iterates over properties
                 * in the opposite order.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @returns {Object} Returns `object`.
                 */
                var baseForRight = createBaseFor(true);

                /**
                 * The base implementation of `_.forOwn` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 */
                function baseForOwn(object, iteratee) {
                    return object && baseFor(object, iteratee, keys);
                }

                /**
                 * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 */
                function baseForOwnRight(object, iteratee) {
                    return object && baseForRight(object, iteratee, keys);
                }

                /**
                 * The base implementation of `_.functions` which creates an array of
                 * `object` function property names filtered from `props`.
                 *
                 * @private
                 * @param {Object} object The object to inspect.
                 * @param {Array} props The property names to filter.
                 * @returns {Array} Returns the new array of filtered property names.
                 */
                function baseFunctions(object, props) {
                    return arrayFilter(props, function(key) {
                        return isFunction(object[key]);
                    });
                }

                /**
                 * The base implementation of `_.get` without support for default values.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to get.
                 * @returns {*} Returns the resolved value.
                 */
                function baseGet(object, path) {
                    path = isKey(path, object) ? [path] : castPath(path);

                    var index = 0,
                        length = path.length;

                    while (object != null && index < length) {
                        object = object[path[index++]];
                    }
                    return (index && index == length) ? object : undefined;
                }

                /**
                 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                 * symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Function} keysFunc The function to get the keys of `object`.
                 * @param {Function} symbolsFunc The function to get the symbols of `object`.
                 * @returns {Array} Returns the array of property names and symbols.
                 */
                function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                    var result = keysFunc(object);
                    return isArray(object)
                        ? result
                        : arrayPush(result, symbolsFunc(object));
                }

                /**
                 * The base implementation of `_.has` without support for deep paths.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} key The key to check.
                 * @returns {boolean} Returns `true` if `key` exists, else `false`.
                 */
                function baseHas(object, key) {
                    // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
                    // that are composed entirely of index properties, return `false` for
                    // `hasOwnProperty` checks of them.
                    return hasOwnProperty.call(object, key) ||
                        (typeof object == 'object' && key in object && getPrototype(object) === null);
                }

                /**
                 * The base implementation of `_.hasIn` without support for deep paths.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} key The key to check.
                 * @returns {boolean} Returns `true` if `key` exists, else `false`.
                 */
                function baseHasIn(object, key) {
                    return key in Object(object);
                }

                /**
                 * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.
                 *
                 * @private
                 * @param {number} number The number to check.
                 * @param {number} start The start of the range.
                 * @param {number} end The end of the range.
                 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
                 */
                function baseInRange(number, start, end) {
                    return number >= nativeMin(start, end) && number < nativeMax(start, end);
                }

                /**
                 * The base implementation of methods like `_.intersection`, without support
                 * for iteratee shorthands, that accepts an array of arrays to inspect.
                 *
                 * @private
                 * @param {Array} arrays The arrays to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of shared values.
                 */
                function baseIntersection(arrays, iteratee, comparator) {
                    var includes = comparator ? arrayIncludesWith : arrayIncludes,
                        length = arrays[0].length,
                        othLength = arrays.length,
                        othIndex = othLength,
                        caches = Array(othLength),
                        maxLength = Infinity,
                        result = [];

                    while (othIndex--) {
                        var array = arrays[othIndex];
                        if (othIndex && iteratee) {
                            array = arrayMap(array, baseUnary(iteratee));
                        }
                        maxLength = nativeMin(array.length, maxLength);
                        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
                            ? new SetCache(othIndex && array)
                            : undefined;
                    }
                    array = arrays[0];

                    var index = -1,
                        seen = caches[0];

                    outer:
                        while (++index < length && result.length < maxLength) {
                            var value = array[index],
                                computed = iteratee ? iteratee(value) : value;

                            if (!(seen
                                        ? cacheHas(seen, computed)
                                        : includes(result, computed, comparator)
                                )) {
                                othIndex = othLength;
                                while (--othIndex) {
                                    var cache = caches[othIndex];
                                    if (!(cache
                                            ? cacheHas(cache, computed)
                                            : includes(arrays[othIndex], computed, comparator))
                                    ) {
                                        continue outer;
                                    }
                                }
                                if (seen) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                    return result;
                }

                /**
                 * The base implementation of `_.invert` and `_.invertBy` which inverts
                 * `object` with values transformed by `iteratee` and set by `setter`.
                 *
                 * @private
                 * @param {Object} object The object to iterate over.
                 * @param {Function} setter The function to set `accumulator` values.
                 * @param {Function} iteratee The iteratee to transform values.
                 * @param {Object} accumulator The initial inverted object.
                 * @returns {Function} Returns `accumulator`.
                 */
                function baseInverter(object, setter, iteratee, accumulator) {
                    baseForOwn(object, function(value, key, object) {
                        setter(accumulator, iteratee(value), key, object);
                    });
                    return accumulator;
                }

                /**
                 * The base implementation of `_.invoke` without support for individual
                 * method arguments.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the method to invoke.
                 * @param {Array} args The arguments to invoke the method with.
                 * @returns {*} Returns the result of the invoked method.
                 */
                function baseInvoke(object, path, args) {
                    if (!isKey(path, object)) {
                        path = castPath(path);
                        object = parent(object, path);
                        path = last(path);
                    }
                    var func = object == null ? object : object[path];
                    return func == null ? undefined : apply(func, object, args);
                }

                /**
                 * The base implementation of `_.isEqual` which supports partial comparisons
                 * and tracks traversed objects.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @param {boolean} [bitmask] The bitmask of comparison flags.
                 *  The bitmask may be composed of the following flags:
                 *     1 - Unordered comparison
                 *     2 - Partial comparison
                 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 */
                function baseIsEqual(value, other, customizer, bitmask, stack) {
                    if (value === other) {
                        return true;
                    }
                    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                        return value !== value && other !== other;
                    }
                    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
                }

                /**
                 * A specialized version of `baseIsEqual` for arrays and objects which performs
                 * deep comparisons and tracks traversed objects enabling objects with circular
                 * references to be compared.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
                 *  for more details.
                 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
                    var objIsArr = isArray(object),
                        othIsArr = isArray(other),
                        objTag = arrayTag,
                        othTag = arrayTag;

                    if (!objIsArr) {
                        objTag = getTag(object);
                        objTag = objTag == argsTag ? objectTag : objTag;
                    }
                    if (!othIsArr) {
                        othTag = getTag(other);
                        othTag = othTag == argsTag ? objectTag : othTag;
                    }
                    var objIsObj = objTag == objectTag && !isHostObject(object),
                        othIsObj = othTag == objectTag && !isHostObject(other),
                        isSameTag = objTag == othTag;

                    if (isSameTag && !objIsObj) {
                        stack || (stack = new Stack);
                        return (objIsArr || isTypedArray(object))
                            ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
                            : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
                    }
                    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                        if (objIsWrapped || othIsWrapped) {
                            var objUnwrapped = objIsWrapped ? object.value() : object,
                                othUnwrapped = othIsWrapped ? other.value() : other;

                            stack || (stack = new Stack);
                            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
                        }
                    }
                    if (!isSameTag) {
                        return false;
                    }
                    stack || (stack = new Stack);
                    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
                }

                /**
                 * The base implementation of `_.isMatch` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property values to match.
                 * @param {Array} matchData The property names, values, and compare flags to match.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                 */
                function baseIsMatch(object, source, matchData, customizer) {
                    var index = matchData.length,
                        length = index,
                        noCustomizer = !customizer;

                    if (object == null) {
                        return !length;
                    }
                    object = Object(object);
                    while (index--) {
                        var data = matchData[index];
                        if ((noCustomizer && data[2])
                                ? data[1] !== object[data[0]]
                                : !(data[0] in object)
                        ) {
                            return false;
                        }
                    }
                    while (++index < length) {
                        data = matchData[index];
                        var key = data[0],
                            objValue = object[key],
                            srcValue = data[1];

                        if (noCustomizer && data[2]) {
                            if (objValue === undefined && !(key in object)) {
                                return false;
                            }
                        } else {
                            var stack = new Stack;
                            if (customizer) {
                                var result = customizer(objValue, srcValue, key, object, source, stack);
                            }
                            if (!(result === undefined
                                        ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
                                        : result
                                )) {
                                return false;
                            }
                        }
                    }
                    return true;
                }

                /**
                 * The base implementation of `_.iteratee`.
                 *
                 * @private
                 * @param {*} [value=_.identity] The value to convert to an iteratee.
                 * @returns {Function} Returns the iteratee.
                 */
                function baseIteratee(value) {
                    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                    if (typeof value == 'function') {
                        return value;
                    }
                    if (value == null) {
                        return identity;
                    }
                    if (typeof value == 'object') {
                        return isArray(value)
                            ? baseMatchesProperty(value[0], value[1])
                            : baseMatches(value);
                    }
                    return property(value);
                }

                /**
                 * The base implementation of `_.keys` which doesn't skip the constructor
                 * property of prototypes or treat sparse arrays as dense.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function baseKeys(object) {
                    return nativeKeys(Object(object));
                }

                /**
                 * The base implementation of `_.keysIn` which doesn't skip the constructor
                 * property of prototypes or treat sparse arrays as dense.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 */
                function baseKeysIn(object) {
                    object = object == null ? object : Object(object);

                    var result = [];
                    for (var key in object) {
                        result.push(key);
                    }
                    return result;
                }

                // Fallback for IE < 9 with es6-shim.
                if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
                    baseKeysIn = function(object) {
                        return iteratorToArray(enumerate(object));
                    };
                }

                /**
                 * The base implementation of `_.map` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} iteratee The function invoked per iteration.
                 * @returns {Array} Returns the new mapped array.
                 */
                function baseMap(collection, iteratee) {
                    var index = -1,
                        result = isArrayLike(collection) ? Array(collection.length) : [];

                    baseEach(collection, function(value, key, collection) {
                        result[++index] = iteratee(value, key, collection);
                    });
                    return result;
                }

                /**
                 * The base implementation of `_.matches` which doesn't clone `source`.
                 *
                 * @private
                 * @param {Object} source The object of property values to match.
                 * @returns {Function} Returns the new function.
                 */
                function baseMatches(source) {
                    var matchData = getMatchData(source);
                    if (matchData.length == 1 && matchData[0][2]) {
                        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                    }
                    return function(object) {
                        return object === source || baseIsMatch(object, source, matchData);
                    };
                }

                /**
                 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
                 *
                 * @private
                 * @param {string} path The path of the property to get.
                 * @param {*} srcValue The value to match.
                 * @returns {Function} Returns the new function.
                 */
                function baseMatchesProperty(path, srcValue) {
                    if (isKey(path) && isStrictComparable(srcValue)) {
                        return matchesStrictComparable(path, srcValue);
                    }
                    return function(object) {
                        var objValue = get(object, path);
                        return (objValue === undefined && objValue === srcValue)
                            ? hasIn(object, path)
                            : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
                    };
                }

                /**
                 * The base implementation of `_.merge` without support for multiple sources.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @param {number} srcIndex The index of `source`.
                 * @param {Function} [customizer] The function to customize merged values.
                 * @param {Object} [stack] Tracks traversed source values and their merged
                 *  counterparts.
                 */
                function baseMerge(object, source, srcIndex, customizer, stack) {
                    if (object === source) {
                        return;
                    }
                    if (!(isArray(source) || isTypedArray(source))) {
                        var props = keysIn(source);
                    }
                    arrayEach(props || source, function(srcValue, key) {
                        if (props) {
                            key = srcValue;
                            srcValue = source[key];
                        }
                        if (isObject(srcValue)) {
                            stack || (stack = new Stack);
                            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                        }
                        else {
                            var newValue = customizer
                                ? customizer(object[key], srcValue, (key + ''), object, source, stack)
                                : undefined;

                            if (newValue === undefined) {
                                newValue = srcValue;
                            }
                            assignMergeValue(object, key, newValue);
                        }
                    });
                }

                /**
                 * A specialized version of `baseMerge` for arrays and objects which performs
                 * deep merges and tracks traversed objects enabling objects with circular
                 * references to be merged.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @param {string} key The key of the value to merge.
                 * @param {number} srcIndex The index of `source`.
                 * @param {Function} mergeFunc The function to merge values.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @param {Object} [stack] Tracks traversed source values and their merged
                 *  counterparts.
                 */
                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                    var objValue = object[key],
                        srcValue = source[key],
                        stacked = stack.get(srcValue);

                    if (stacked) {
                        assignMergeValue(object, key, stacked);
                        return;
                    }
                    var newValue = customizer
                        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
                        : undefined;

                    var isCommon = newValue === undefined;

                    if (isCommon) {
                        newValue = srcValue;
                        if (isArray(srcValue) || isTypedArray(srcValue)) {
                            if (isArray(objValue)) {
                                newValue = objValue;
                            }
                            else if (isArrayLikeObject(objValue)) {
                                newValue = copyArray(objValue);
                            }
                            else {
                                isCommon = false;
                                newValue = baseClone(srcValue, true);
                            }
                        }
                        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                            if (isArguments(objValue)) {
                                newValue = toPlainObject(objValue);
                            }
                            else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
                                isCommon = false;
                                newValue = baseClone(srcValue, true);
                            }
                            else {
                                newValue = objValue;
                            }
                        }
                        else {
                            isCommon = false;
                        }
                    }
                    stack.set(srcValue, newValue);

                    if (isCommon) {
                        // Recursively merge objects and arrays (susceptible to call stack limits).
                        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                    }
                    stack['delete'](srcValue);
                    assignMergeValue(object, key, newValue);
                }

                /**
                 * The base implementation of `_.nth` which doesn't coerce `n` to an integer.
                 *
                 * @private
                 * @param {Array} array The array to query.
                 * @param {number} n The index of the element to return.
                 * @returns {*} Returns the nth element of `array`.
                 */
                function baseNth(array, n) {
                    var length = array.length;
                    if (!length) {
                        return;
                    }
                    n += n < 0 ? length : 0;
                    return isIndex(n, length) ? array[n] : undefined;
                }

                /**
                 * The base implementation of `_.orderBy` without param guards.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                 * @param {string[]} orders The sort orders of `iteratees`.
                 * @returns {Array} Returns the new sorted array.
                 */
                function baseOrderBy(collection, iteratees, orders) {
                    var index = -1;
                    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

                    var result = baseMap(collection, function(value, key, collection) {
                        var criteria = arrayMap(iteratees, function(iteratee) {
                            return iteratee(value);
                        });
                        return { 'criteria': criteria, 'index': ++index, 'value': value };
                    });

                    return baseSortBy(result, function(object, other) {
                        return compareMultiple(object, other, orders);
                    });
                }

                /**
                 * The base implementation of `_.pick` without support for individual
                 * property identifiers.
                 *
                 * @private
                 * @param {Object} object The source object.
                 * @param {string[]} props The property identifiers to pick.
                 * @returns {Object} Returns the new object.
                 */
                function basePick(object, props) {
                    object = Object(object);
                    return arrayReduce(props, function(result, key) {
                        if (key in object) {
                            result[key] = object[key];
                        }
                        return result;
                    }, {});
                }

                /**
                 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Object} object The source object.
                 * @param {Function} predicate The function invoked per property.
                 * @returns {Object} Returns the new object.
                 */
                function basePickBy(object, predicate) {
                    var index = -1,
                        props = getAllKeysIn(object),
                        length = props.length,
                        result = {};

                    while (++index < length) {
                        var key = props[index],
                            value = object[key];

                        if (predicate(value, key)) {
                            result[key] = value;
                        }
                    }
                    return result;
                }

                /**
                 * The base implementation of `_.property` without support for deep paths.
                 *
                 * @private
                 * @param {string} key The key of the property to get.
                 * @returns {Function} Returns the new function.
                 */
                function baseProperty(key) {
                    return function(object) {
                        return object == null ? undefined : object[key];
                    };
                }

                /**
                 * A specialized version of `baseProperty` which supports deep paths.
                 *
                 * @private
                 * @param {Array|string} path The path of the property to get.
                 * @returns {Function} Returns the new function.
                 */
                function basePropertyDeep(path) {
                    return function(object) {
                        return baseGet(object, path);
                    };
                }

                /**
                 * The base implementation of `_.pullAllBy` without support for iteratee
                 * shorthands.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to remove.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns `array`.
                 */
                function basePullAll(array, values, iteratee, comparator) {
                    var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                        index = -1,
                        length = values.length,
                        seen = array;

                    if (iteratee) {
                        seen = arrayMap(array, baseUnary(iteratee));
                    }
                    while (++index < length) {
                        var fromIndex = 0,
                            value = values[index],
                            computed = iteratee ? iteratee(value) : value;

                        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                            if (seen !== array) {
                                splice.call(seen, fromIndex, 1);
                            }
                            splice.call(array, fromIndex, 1);
                        }
                    }
                    return array;
                }

                /**
                 * The base implementation of `_.pullAt` without support for individual
                 * indexes or capturing the removed elements.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {number[]} indexes The indexes of elements to remove.
                 * @returns {Array} Returns `array`.
                 */
                function basePullAt(array, indexes) {
                    var length = array ? indexes.length : 0,
                        lastIndex = length - 1;

                    while (length--) {
                        var index = indexes[length];
                        if (lastIndex == length || index != previous) {
                            var previous = index;
                            if (isIndex(index)) {
                                splice.call(array, index, 1);
                            }
                            else if (!isKey(index, array)) {
                                var path = castPath(index),
                                    object = parent(array, path);

                                if (object != null) {
                                    delete object[last(path)];
                                }
                            }
                            else {
                                delete array[index];
                            }
                        }
                    }
                    return array;
                }

                /**
                 * The base implementation of `_.random` without support for returning
                 * floating-point numbers.
                 *
                 * @private
                 * @param {number} lower The lower bound.
                 * @param {number} upper The upper bound.
                 * @returns {number} Returns the random number.
                 */
                function baseRandom(lower, upper) {
                    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                }

                /**
                 * The base implementation of `_.range` and `_.rangeRight` which doesn't
                 * coerce arguments to numbers.
                 *
                 * @private
                 * @param {number} start The start of the range.
                 * @param {number} end The end of the range.
                 * @param {number} step The value to increment or decrement by.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Array} Returns the new array of numbers.
                 */
                function baseRange(start, end, step, fromRight) {
                    var index = -1,
                        length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                        result = Array(length);

                    while (length--) {
                        result[fromRight ? length : ++index] = start;
                        start += step;
                    }
                    return result;
                }

                /**
                 * The base implementation of `_.repeat` which doesn't coerce arguments.
                 *
                 * @private
                 * @param {string} string The string to repeat.
                 * @param {number} n The number of times to repeat the string.
                 * @returns {string} Returns the repeated string.
                 */
                function baseRepeat(string, n) {
                    var result = '';
                    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                        return result;
                    }
                    // Leverage the exponentiation by squaring algorithm for a faster repeat.
                    // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                    do {
                        if (n % 2) {
                            result += string;
                        }
                        n = nativeFloor(n / 2);
                        if (n) {
                            string += string;
                        }
                    } while (n);

                    return result;
                }

                /**
                 * The base implementation of `_.set`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to set.
                 * @param {*} value The value to set.
                 * @param {Function} [customizer] The function to customize path creation.
                 * @returns {Object} Returns `object`.
                 */
                function baseSet(object, path, value, customizer) {
                    path = isKey(path, object) ? [path] : castPath(path);

                    var index = -1,
                        length = path.length,
                        lastIndex = length - 1,
                        nested = object;

                    while (nested != null && ++index < length) {
                        var key = path[index];
                        if (isObject(nested)) {
                            var newValue = value;
                            if (index != lastIndex) {
                                var objValue = nested[key];
                                newValue = customizer ? customizer(objValue, key, nested) : undefined;
                                if (newValue === undefined) {
                                    newValue = objValue == null
                                        ? (isIndex(path[index + 1]) ? [] : {})
                                        : objValue;
                                }
                            }
                            assignValue(nested, key, newValue);
                        }
                        nested = nested[key];
                    }
                    return object;
                }

                /**
                 * The base implementation of `setData` without support for hot loop detection.
                 *
                 * @private
                 * @param {Function} func The function to associate metadata with.
                 * @param {*} data The metadata.
                 * @returns {Function} Returns `func`.
                 */
                var baseSetData = !metaMap ? identity : function(func, data) {
                    metaMap.set(func, data);
                    return func;
                };

                /**
                 * The base implementation of `_.slice` without an iteratee call guard.
                 *
                 * @private
                 * @param {Array} array The array to slice.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns the slice of `array`.
                 */
                function baseSlice(array, start, end) {
                    var index = -1,
                        length = array.length;

                    if (start < 0) {
                        start = -start > length ? 0 : (length + start);
                    }
                    end = end > length ? length : end;
                    if (end < 0) {
                        end += length;
                    }
                    length = start > end ? 0 : ((end - start) >>> 0);
                    start >>>= 0;

                    var result = Array(length);
                    while (++index < length) {
                        result[index] = array[index + start];
                    }
                    return result;
                }

                /**
                 * The base implementation of `_.some` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} predicate The function invoked per iteration.
                 * @returns {boolean} Returns `true` if any element passes the predicate check,
                 *  else `false`.
                 */
                function baseSome(collection, predicate) {
                    var result;

                    baseEach(collection, function(value, index, collection) {
                        result = predicate(value, index, collection);
                        return !result;
                    });
                    return !!result;
                }

                /**
                 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
                 * performs a binary search of `array` to determine the index at which `value`
                 * should be inserted into `array` in order to maintain its sort order.
                 *
                 * @private
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {boolean} [retHighest] Specify returning the highest qualified index.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 */
                function baseSortedIndex(array, value, retHighest) {
                    var low = 0,
                        high = array ? array.length : low;

                    if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                        while (low < high) {
                            var mid = (low + high) >>> 1,
                                computed = array[mid];

                            if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }
                        return high;
                    }
                    return baseSortedIndexBy(array, value, identity, retHighest);
                }

                /**
                 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
                 * which invokes `iteratee` for `value` and each element of `array` to compute
                 * their sort ranking. The iteratee is invoked with one argument; (value).
                 *
                 * @private
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {Function} iteratee The iteratee invoked per element.
                 * @param {boolean} [retHighest] Specify returning the highest qualified index.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 */
                function baseSortedIndexBy(array, value, iteratee, retHighest) {
                    value = iteratee(value);

                    var low = 0,
                        high = array ? array.length : 0,
                        valIsNaN = value !== value,
                        valIsNull = value === null,
                        valIsUndef = value === undefined;

                    while (low < high) {
                        var mid = nativeFloor((low + high) / 2),
                            computed = iteratee(array[mid]),
                            isDef = computed !== undefined,
                            isReflexive = computed === computed;

                        if (valIsNaN) {
                            var setLow = isReflexive || retHighest;
                        } else if (valIsNull) {
                            setLow = isReflexive && isDef && (retHighest || computed != null);
                        } else if (valIsUndef) {
                            setLow = isReflexive && (retHighest || isDef);
                        } else if (computed == null) {
                            setLow = false;
                        } else {
                            setLow = retHighest ? (computed <= value) : (computed < value);
                        }
                        if (setLow) {
                            low = mid + 1;
                        } else {
                            high = mid;
                        }
                    }
                    return nativeMin(high, MAX_ARRAY_INDEX);
                }

                /**
                 * The base implementation of `_.sortedUniq`.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @returns {Array} Returns the new duplicate free array.
                 */
                function baseSortedUniq(array) {
                    return baseSortedUniqBy(array);
                }

                /**
                 * The base implementation of `_.sortedUniqBy` without support for iteratee
                 * shorthands.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 */
                function baseSortedUniqBy(array, iteratee) {
                    var index = 0,
                        length = array.length,
                        value = array[0],
                        computed = iteratee ? iteratee(value) : value,
                        seen = computed,
                        resIndex = 1,
                        result = [value];

                    while (++index < length) {
                        value = array[index],
                            computed = iteratee ? iteratee(value) : value;

                        if (!eq(computed, seen)) {
                            seen = computed;
                            result[resIndex++] = value;
                        }
                    }
                    return result;
                }

                /**
                 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 */
                function baseUniq(array, iteratee, comparator) {
                    var index = -1,
                        includes = arrayIncludes,
                        length = array.length,
                        isCommon = true,
                        result = [],
                        seen = result;

                    if (comparator) {
                        isCommon = false;
                        includes = arrayIncludesWith;
                    }
                    else if (length >= LARGE_ARRAY_SIZE) {
                        var set = iteratee ? null : createSet(array);
                        if (set) {
                            return setToArray(set);
                        }
                        isCommon = false;
                        includes = cacheHas;
                        seen = new SetCache;
                    }
                    else {
                        seen = iteratee ? [] : result;
                    }
                    outer:
                        while (++index < length) {
                            var value = array[index],
                                computed = iteratee ? iteratee(value) : value;

                            if (isCommon && computed === computed) {
                                var seenIndex = seen.length;
                                while (seenIndex--) {
                                    if (seen[seenIndex] === computed) {
                                        continue outer;
                                    }
                                }
                                if (iteratee) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                            else if (!includes(seen, computed, comparator)) {
                                if (seen !== result) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                    return result;
                }

                /**
                 * The base implementation of `_.unset`.
                 *
                 * @private
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to unset.
                 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                 */
                function baseUnset(object, path) {
                    path = isKey(path, object) ? [path] : castPath(path);
                    object = parent(object, path);
                    var key = last(path);
                    return (object != null && has(object, key)) ? delete object[key] : true;
                }

                /**
                 * The base implementation of `_.update`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to update.
                 * @param {Function} updater The function to produce the updated value.
                 * @param {Function} [customizer] The function to customize path creation.
                 * @returns {Object} Returns `object`.
                 */
                function baseUpdate(object, path, updater, customizer) {
                    return baseSet(object, path, updater(baseGet(object, path)), customizer);
                }

                /**
                 * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
                 * without support for iteratee shorthands.
                 *
                 * @private
                 * @param {Array} array The array to query.
                 * @param {Function} predicate The function invoked per iteration.
                 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Array} Returns the slice of `array`.
                 */
                function baseWhile(array, predicate, isDrop, fromRight) {
                    var length = array.length,
                        index = fromRight ? length : -1;

                    while ((fromRight ? index-- : ++index < length) &&
                    predicate(array[index], index, array)) {}

                    return isDrop
                        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
                        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                }

                /**
                 * The base implementation of `wrapperValue` which returns the result of
                 * performing a sequence of actions on the unwrapped `value`, where each
                 * successive action is supplied the return value of the previous.
                 *
                 * @private
                 * @param {*} value The unwrapped value.
                 * @param {Array} actions Actions to perform to resolve the unwrapped value.
                 * @returns {*} Returns the resolved value.
                 */
                function baseWrapperValue(value, actions) {
                    var result = value;
                    if (result instanceof LazyWrapper) {
                        result = result.value();
                    }
                    return arrayReduce(actions, function(result, action) {
                        return action.func.apply(action.thisArg, arrayPush([result], action.args));
                    }, result);
                }

                /**
                 * The base implementation of methods like `_.xor`, without support for
                 * iteratee shorthands, that accepts an array of arrays to inspect.
                 *
                 * @private
                 * @param {Array} arrays The arrays to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of values.
                 */
                function baseXor(arrays, iteratee, comparator) {
                    var index = -1,
                        length = arrays.length;

                    while (++index < length) {
                        var result = result
                            ? arrayPush(
                            baseDifference(result, arrays[index], iteratee, comparator),
                            baseDifference(arrays[index], result, iteratee, comparator)
                        )
                            : arrays[index];
                    }
                    return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];
                }

                /**
                 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
                 *
                 * @private
                 * @param {Array} props The property identifiers.
                 * @param {Array} values The property values.
                 * @param {Function} assignFunc The function to assign values.
                 * @returns {Object} Returns the new object.
                 */
                function baseZipObject(props, values, assignFunc) {
                    var index = -1,
                        length = props.length,
                        valsLength = values.length,
                        result = {};

                    while (++index < length) {
                        var value = index < valsLength ? values[index] : undefined;
                        assignFunc(result, props[index], value);
                    }
                    return result;
                }

                /**
                 * Casts `value` to an empty array if it's not an array like object.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {Array|Object} Returns the cast array-like object.
                 */
                function castArrayLikeObject(value) {
                    return isArrayLikeObject(value) ? value : [];
                }

                /**
                 * Casts `value` to `identity` if it's not a function.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {Function} Returns cast function.
                 */
                function castFunction(value) {
                    return typeof value == 'function' ? value : identity;
                }

                /**
                 * Casts `value` to a path array if it's not one.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {Array} Returns the cast property path array.
                 */
                function castPath(value) {
                    return isArray(value) ? value : stringToPath(value);
                }

                /**
                 * Casts `array` to a slice if it's needed.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {number} start The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns the cast slice.
                 */
                function castSlice(array, start, end) {
                    var length = array.length;
                    end = end === undefined ? length : end;
                    return (!start && end >= length) ? array : baseSlice(array, start, end);
                }

                /**
                 * Creates a clone of  `buffer`.
                 *
                 * @private
                 * @param {Buffer} buffer The buffer to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Buffer} Returns the cloned buffer.
                 */
                function cloneBuffer(buffer, isDeep) {
                    if (isDeep) {
                        return buffer.slice();
                    }
                    var result = new buffer.constructor(buffer.length);
                    buffer.copy(result);
                    return result;
                }

                /**
                 * Creates a clone of `arrayBuffer`.
                 *
                 * @private
                 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                 * @returns {ArrayBuffer} Returns the cloned array buffer.
                 */
                function cloneArrayBuffer(arrayBuffer) {
                    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                    return result;
                }

                /**
                 * Creates a clone of `dataView`.
                 *
                 * @private
                 * @param {Object} dataView The data view to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned data view.
                 */
                function cloneDataView(dataView, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                }

                /**
                 * Creates a clone of `map`.
                 *
                 * @private
                 * @param {Object} map The map to clone.
                 * @param {Function} cloneFunc The function to clone values.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned map.
                 */
                function cloneMap(map, isDeep, cloneFunc) {
                    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
                    return arrayReduce(array, addMapEntry, new map.constructor);
                }

                /**
                 * Creates a clone of `regexp`.
                 *
                 * @private
                 * @param {Object} regexp The regexp to clone.
                 * @returns {Object} Returns the cloned regexp.
                 */
                function cloneRegExp(regexp) {
                    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                    result.lastIndex = regexp.lastIndex;
                    return result;
                }

                /**
                 * Creates a clone of `set`.
                 *
                 * @private
                 * @param {Object} set The set to clone.
                 * @param {Function} cloneFunc The function to clone values.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned set.
                 */
                function cloneSet(set, isDeep, cloneFunc) {
                    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
                    return arrayReduce(array, addSetEntry, new set.constructor);
                }

                /**
                 * Creates a clone of the `symbol` object.
                 *
                 * @private
                 * @param {Object} symbol The symbol object to clone.
                 * @returns {Object} Returns the cloned symbol object.
                 */
                function cloneSymbol(symbol) {
                    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                }

                /**
                 * Creates a clone of `typedArray`.
                 *
                 * @private
                 * @param {Object} typedArray The typed array to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the cloned typed array.
                 */
                function cloneTypedArray(typedArray, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                }

                /**
                 * Creates an array that is the composition of partially applied arguments,
                 * placeholders, and provided arguments into a single array of arguments.
                 *
                 * @private
                 * @param {Array|Object} args The provided arguments.
                 * @param {Array} partials The arguments to prepend to those provided.
                 * @param {Array} holders The `partials` placeholder indexes.
                 * @params {boolean} [isCurried] Specify composing for a curried function.
                 * @returns {Array} Returns the new array of composed arguments.
                 */
                function composeArgs(args, partials, holders, isCurried) {
                    var argsIndex = -1,
                        argsLength = args.length,
                        holdersLength = holders.length,
                        leftIndex = -1,
                        leftLength = partials.length,
                        rangeLength = nativeMax(argsLength - holdersLength, 0),
                        result = Array(leftLength + rangeLength),
                        isUncurried = !isCurried;

                    while (++leftIndex < leftLength) {
                        result[leftIndex] = partials[leftIndex];
                    }
                    while (++argsIndex < holdersLength) {
                        if (isUncurried || argsIndex < argsLength) {
                            result[holders[argsIndex]] = args[argsIndex];
                        }
                    }
                    while (rangeLength--) {
                        result[leftIndex++] = args[argsIndex++];
                    }
                    return result;
                }

                /**
                 * This function is like `composeArgs` except that the arguments composition
                 * is tailored for `_.partialRight`.
                 *
                 * @private
                 * @param {Array|Object} args The provided arguments.
                 * @param {Array} partials The arguments to append to those provided.
                 * @param {Array} holders The `partials` placeholder indexes.
                 * @params {boolean} [isCurried] Specify composing for a curried function.
                 * @returns {Array} Returns the new array of composed arguments.
                 */
                function composeArgsRight(args, partials, holders, isCurried) {
                    var argsIndex = -1,
                        argsLength = args.length,
                        holdersIndex = -1,
                        holdersLength = holders.length,
                        rightIndex = -1,
                        rightLength = partials.length,
                        rangeLength = nativeMax(argsLength - holdersLength, 0),
                        result = Array(rangeLength + rightLength),
                        isUncurried = !isCurried;

                    while (++argsIndex < rangeLength) {
                        result[argsIndex] = args[argsIndex];
                    }
                    var offset = argsIndex;
                    while (++rightIndex < rightLength) {
                        result[offset + rightIndex] = partials[rightIndex];
                    }
                    while (++holdersIndex < holdersLength) {
                        if (isUncurried || argsIndex < argsLength) {
                            result[offset + holders[holdersIndex]] = args[argsIndex++];
                        }
                    }
                    return result;
                }

                /**
                 * Copies the values of `source` to `array`.
                 *
                 * @private
                 * @param {Array} source The array to copy values from.
                 * @param {Array} [array=[]] The array to copy values to.
                 * @returns {Array} Returns `array`.
                 */
                function copyArray(source, array) {
                    var index = -1,
                        length = source.length;

                    array || (array = Array(length));
                    while (++index < length) {
                        array[index] = source[index];
                    }
                    return array;
                }

                /**
                 * Copies properties of `source` to `object`.
                 *
                 * @private
                 * @param {Object} source The object to copy properties from.
                 * @param {Array} props The property identifiers to copy.
                 * @param {Object} [object={}] The object to copy properties to.
                 * @param {Function} [customizer] The function to customize copied values.
                 * @returns {Object} Returns `object`.
                 */
                function copyObject(source, props, object, customizer) {
                    object || (object = {});

                    var index = -1,
                        length = props.length;

                    while (++index < length) {
                        var key = props[index];

                        var newValue = customizer
                            ? customizer(object[key], source[key], key, object, source)
                            : source[key];

                        assignValue(object, key, newValue);
                    }
                    return object;
                }

                /**
                 * Copies own symbol properties of `source` to `object`.
                 *
                 * @private
                 * @param {Object} source The object to copy symbols from.
                 * @param {Object} [object={}] The object to copy symbols to.
                 * @returns {Object} Returns `object`.
                 */
                function copySymbols(source, object) {
                    return copyObject(source, getSymbols(source), object);
                }

                /**
                 * Creates a function like `_.groupBy`.
                 *
                 * @private
                 * @param {Function} setter The function to set accumulator values.
                 * @param {Function} [initializer] The accumulator object initializer.
                 * @returns {Function} Returns the new aggregator function.
                 */
                function createAggregator(setter, initializer) {
                    return function(collection, iteratee) {
                        var func = isArray(collection) ? arrayAggregator : baseAggregator,
                            accumulator = initializer ? initializer() : {};

                        return func(collection, setter, getIteratee(iteratee), accumulator);
                    };
                }

                /**
                 * Creates a function like `_.assign`.
                 *
                 * @private
                 * @param {Function} assigner The function to assign values.
                 * @returns {Function} Returns the new assigner function.
                 */
                function createAssigner(assigner) {
                    return rest(function(object, sources) {
                        var index = -1,
                            length = sources.length,
                            customizer = length > 1 ? sources[length - 1] : undefined,
                            guard = length > 2 ? sources[2] : undefined;

                        customizer = typeof customizer == 'function'
                            ? (length--, customizer)
                            : undefined;

                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                            customizer = length < 3 ? undefined : customizer;
                            length = 1;
                        }
                        object = Object(object);
                        while (++index < length) {
                            var source = sources[index];
                            if (source) {
                                assigner(object, source, index, customizer);
                            }
                        }
                        return object;
                    });
                }

                /**
                 * Creates a `baseEach` or `baseEachRight` function.
                 *
                 * @private
                 * @param {Function} eachFunc The function to iterate over a collection.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new base function.
                 */
                function createBaseEach(eachFunc, fromRight) {
                    return function(collection, iteratee) {
                        if (collection == null) {
                            return collection;
                        }
                        if (!isArrayLike(collection)) {
                            return eachFunc(collection, iteratee);
                        }
                        var length = collection.length,
                            index = fromRight ? length : -1,
                            iterable = Object(collection);

                        while ((fromRight ? index-- : ++index < length)) {
                            if (iteratee(iterable[index], index, iterable) === false) {
                                break;
                            }
                        }
                        return collection;
                    };
                }

                /**
                 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
                 *
                 * @private
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new base function.
                 */
                function createBaseFor(fromRight) {
                    return function(object, iteratee, keysFunc) {
                        var index = -1,
                            iterable = Object(object),
                            props = keysFunc(object),
                            length = props.length;

                        while (length--) {
                            var key = props[fromRight ? length : ++index];
                            if (iteratee(iterable[key], key, iterable) === false) {
                                break;
                            }
                        }
                        return object;
                    };
                }

                /**
                 * Creates a function that wraps `func` to invoke it with the optional `this`
                 * binding of `thisArg`.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
                 *  for more details.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createBaseWrapper(func, bitmask, thisArg) {
                    var isBind = bitmask & BIND_FLAG,
                        Ctor = createCtorWrapper(func);

                    function wrapper() {
                        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                        return fn.apply(isBind ? thisArg : this, arguments);
                    }
                    return wrapper;
                }

                /**
                 * Creates a function like `_.lowerFirst`.
                 *
                 * @private
                 * @param {string} methodName The name of the `String` case method to use.
                 * @returns {Function} Returns the new function.
                 */
                function createCaseFirst(methodName) {
                    return function(string) {
                        string = toString(string);

                        var strSymbols = reHasComplexSymbol.test(string)
                            ? stringToArray(string)
                            : undefined;

                        var chr = strSymbols
                            ? strSymbols[0]
                            : string.charAt(0);

                        var trailing = strSymbols
                            ? castSlice(strSymbols, 1).join('')
                            : string.slice(1);

                        return chr[methodName]() + trailing;
                    };
                }

                /**
                 * Creates a function like `_.camelCase`.
                 *
                 * @private
                 * @param {Function} callback The function to combine each word.
                 * @returns {Function} Returns the new compounder function.
                 */
                function createCompounder(callback) {
                    return function(string) {
                        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
                    };
                }

                /**
                 * Creates a function that produces an instance of `Ctor` regardless of
                 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                 *
                 * @private
                 * @param {Function} Ctor The constructor to wrap.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createCtorWrapper(Ctor) {
                    return function() {
                        // Use a `switch` statement to work with class constructors. See
                        // http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                        // for more details.
                        var args = arguments;
                        switch (args.length) {
                            case 0: return new Ctor;
                            case 1: return new Ctor(args[0]);
                            case 2: return new Ctor(args[0], args[1]);
                            case 3: return new Ctor(args[0], args[1], args[2]);
                            case 4: return new Ctor(args[0], args[1], args[2], args[3]);
                            case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                            case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                            case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                        }
                        var thisBinding = baseCreate(Ctor.prototype),
                            result = Ctor.apply(thisBinding, args);

                        // Mimic the constructor's `return` behavior.
                        // See https://es5.github.io/#x13.2.2 for more details.
                        return isObject(result) ? result : thisBinding;
                    };
                }

                /**
                 * Creates a function that wraps `func` to enable currying.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
                 *  for more details.
                 * @param {number} arity The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createCurryWrapper(func, bitmask, arity) {
                    var Ctor = createCtorWrapper(func);

                    function wrapper() {
                        var length = arguments.length,
                            args = Array(length),
                            index = length,
                            placeholder = getPlaceholder(wrapper);

                        while (index--) {
                            args[index] = arguments[index];
                        }
                        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
                            ? []
                            : replaceHolders(args, placeholder);

                        length -= holders.length;
                        if (length < arity) {
                            return createRecurryWrapper(
                                func, bitmask, createHybridWrapper, wrapper.placeholder, undefined,
                                args, holders, undefined, undefined, arity - length);
                        }
                        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                        return apply(fn, this, args);
                    }
                    return wrapper;
                }

                /**
                 * Creates a `_.flow` or `_.flowRight` function.
                 *
                 * @private
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new flow function.
                 */
                function createFlow(fromRight) {
                    return rest(function(funcs) {
                        funcs = baseFlatten(funcs, 1);

                        var length = funcs.length,
                            index = length,
                            prereq = LodashWrapper.prototype.thru;

                        if (fromRight) {
                            funcs.reverse();
                        }
                        while (index--) {
                            var func = funcs[index];
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                                var wrapper = new LodashWrapper([], true);
                            }
                        }
                        index = wrapper ? index : length;
                        while (++index < length) {
                            func = funcs[index];

                            var funcName = getFuncName(func),
                                data = funcName == 'wrapper' ? getData(func) : undefined;

                            if (data && isLaziable(data[0]) &&
                                data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) &&
                                !data[4].length && data[9] == 1
                            ) {
                                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                            } else {
                                wrapper = (func.length == 1 && isLaziable(func))
                                    ? wrapper[funcName]()
                                    : wrapper.thru(func);
                            }
                        }
                        return function() {
                            var args = arguments,
                                value = args[0];

                            if (wrapper && args.length == 1 &&
                                isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                                return wrapper.plant(value).value();
                            }
                            var index = 0,
                                result = length ? funcs[index].apply(this, args) : value;

                            while (++index < length) {
                                result = funcs[index].call(this, result);
                            }
                            return result;
                        };
                    });
                }

                /**
                 * Creates a function that wraps `func` to invoke it with optional `this`
                 * binding of `thisArg`, partial application, and currying.
                 *
                 * @private
                 * @param {Function|string} func The function or method name to wrap.
                 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
                 *  for more details.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {Array} [partials] The arguments to prepend to those provided to
                 *  the new function.
                 * @param {Array} [holders] The `partials` placeholder indexes.
                 * @param {Array} [partialsRight] The arguments to append to those provided
                 *  to the new function.
                 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                 * @param {Array} [argPos] The argument positions of the new function.
                 * @param {number} [ary] The arity cap of `func`.
                 * @param {number} [arity] The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                    var isAry = bitmask & ARY_FLAG,
                        isBind = bitmask & BIND_FLAG,
                        isBindKey = bitmask & BIND_KEY_FLAG,
                        isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
                        isFlip = bitmask & FLIP_FLAG,
                        Ctor = isBindKey ? undefined : createCtorWrapper(func);

                    function wrapper() {
                        var length = arguments.length,
                            index = length,
                            args = Array(length);

                        while (index--) {
                            args[index] = arguments[index];
                        }
                        if (isCurried) {
                            var placeholder = getPlaceholder(wrapper),
                                holdersCount = countHolders(args, placeholder);
                        }
                        if (partials) {
                            args = composeArgs(args, partials, holders, isCurried);
                        }
                        if (partialsRight) {
                            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                        }
                        length -= holdersCount;
                        if (isCurried && length < arity) {
                            var newHolders = replaceHolders(args, placeholder);
                            return createRecurryWrapper(
                                func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg,
                                args, newHolders, argPos, ary, arity - length
                            );
                        }
                        var thisBinding = isBind ? thisArg : this,
                            fn = isBindKey ? thisBinding[func] : func;

                        length = args.length;
                        if (argPos) {
                            args = reorder(args, argPos);
                        } else if (isFlip && length > 1) {
                            args.reverse();
                        }
                        if (isAry && ary < length) {
                            args.length = ary;
                        }
                        if (this && this !== root && this instanceof wrapper) {
                            fn = Ctor || createCtorWrapper(fn);
                        }
                        return fn.apply(thisBinding, args);
                    }
                    return wrapper;
                }

                /**
                 * Creates a function like `_.invertBy`.
                 *
                 * @private
                 * @param {Function} setter The function to set accumulator values.
                 * @param {Function} toIteratee The function to resolve iteratees.
                 * @returns {Function} Returns the new inverter function.
                 */
                function createInverter(setter, toIteratee) {
                    return function(object, iteratee) {
                        return baseInverter(object, setter, toIteratee(iteratee), {});
                    };
                }

                /**
                 * Creates a function like `_.over`.
                 *
                 * @private
                 * @param {Function} arrayFunc The function to iterate over iteratees.
                 * @returns {Function} Returns the new invoker function.
                 */
                function createOver(arrayFunc) {
                    return rest(function(iteratees) {
                        iteratees = (iteratees.length == 1 && isArray(iteratees[0]))
                            ? arrayMap(iteratees[0], baseUnary(getIteratee()))
                            : arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(getIteratee()));

                        return rest(function(args) {
                            var thisArg = this;
                            return arrayFunc(iteratees, function(iteratee) {
                                return apply(iteratee, thisArg, args);
                            });
                        });
                    });
                }

                /**
                 * Creates the padding for `string` based on `length`. The `chars` string
                 * is truncated if the number of characters exceeds `length`.
                 *
                 * @private
                 * @param {number} length The padding length.
                 * @param {string} [chars=' '] The string used as padding.
                 * @returns {string} Returns the padding for `string`.
                 */
                function createPadding(length, chars) {
                    chars = chars === undefined ? ' ' : (chars + '');

                    var charsLength = chars.length;
                    if (charsLength < 2) {
                        return charsLength ? baseRepeat(chars, length) : chars;
                    }
                    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                    return reHasComplexSymbol.test(chars)
                        ? castSlice(stringToArray(result), 0, length).join('')
                        : result.slice(0, length);
                }

                /**
                 * Creates a function that wraps `func` to invoke it with the `this` binding
                 * of `thisArg` and `partials` prepended to the arguments it receives.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
                 *  for more details.
                 * @param {*} thisArg The `this` binding of `func`.
                 * @param {Array} partials The arguments to prepend to those provided to
                 *  the new function.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createPartialWrapper(func, bitmask, thisArg, partials) {
                    var isBind = bitmask & BIND_FLAG,
                        Ctor = createCtorWrapper(func);

                    function wrapper() {
                        var argsIndex = -1,
                            argsLength = arguments.length,
                            leftIndex = -1,
                            leftLength = partials.length,
                            args = Array(leftLength + argsLength),
                            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

                        while (++leftIndex < leftLength) {
                            args[leftIndex] = partials[leftIndex];
                        }
                        while (argsLength--) {
                            args[leftIndex++] = arguments[++argsIndex];
                        }
                        return apply(fn, isBind ? thisArg : this, args);
                    }
                    return wrapper;
                }

                /**
                 * Creates a `_.range` or `_.rangeRight` function.
                 *
                 * @private
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {Function} Returns the new range function.
                 */
                function createRange(fromRight) {
                    return function(start, end, step) {
                        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                            end = step = undefined;
                        }
                        // Ensure the sign of `-0` is preserved.
                        start = toNumber(start);
                        start = start === start ? start : 0;
                        if (end === undefined) {
                            end = start;
                            start = 0;
                        } else {
                            end = toNumber(end) || 0;
                        }
                        step = step === undefined ? (start < end ? 1 : -1) : (toNumber(step) || 0);
                        return baseRange(start, end, step, fromRight);
                    };
                }

                /**
                 * Creates a function that wraps `func` to continue currying.
                 *
                 * @private
                 * @param {Function} func The function to wrap.
                 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
                 *  for more details.
                 * @param {Function} wrapFunc The function to create the `func` wrapper.
                 * @param {*} placeholder The placeholder value.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {Array} [partials] The arguments to prepend to those provided to
                 *  the new function.
                 * @param {Array} [holders] The `partials` placeholder indexes.
                 * @param {Array} [argPos] The argument positions of the new function.
                 * @param {number} [ary] The arity cap of `func`.
                 * @param {number} [arity] The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                    var isCurry = bitmask & CURRY_FLAG,
                        newHolders = isCurry ? holders : undefined,
                        newHoldersRight = isCurry ? undefined : holders,
                        newPartials = isCurry ? partials : undefined,
                        newPartialsRight = isCurry ? undefined : partials;

                    bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                    if (!(bitmask & CURRY_BOUND_FLAG)) {
                        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                    }
                    var newData = [
                        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
                        newHoldersRight, argPos, ary, arity
                    ];

                    var result = wrapFunc.apply(undefined, newData);
                    if (isLaziable(func)) {
                        setData(result, newData);
                    }
                    result.placeholder = placeholder;
                    return result;
                }

                /**
                 * Creates a function like `_.round`.
                 *
                 * @private
                 * @param {string} methodName The name of the `Math` method to use when rounding.
                 * @returns {Function} Returns the new round function.
                 */
                function createRound(methodName) {
                    var func = Math[methodName];
                    return function(number, precision) {
                        number = toNumber(number);
                        precision = toInteger(precision);
                        if (precision) {
                            // Shift with exponential notation to avoid floating-point issues.
                            // See [MDN](https://mdn.io/round#Examples) for more details.
                            var pair = (toString(number) + 'e').split('e'),
                                value = func(pair[0] + 'e' + (+pair[1] + precision));

                            pair = (toString(value) + 'e').split('e');
                            return +(pair[0] + 'e' + (+pair[1] - precision));
                        }
                        return func(number);
                    };
                }

                /**
                 * Creates a set of `values`.
                 *
                 * @private
                 * @param {Array} values The values to add to the set.
                 * @returns {Object} Returns the new set.
                 */
                var createSet = !(Set && new Set([1, 2]).size === 2) ? noop : function(values) {
                    return new Set(values);
                };

                /**
                 * Creates a function that either curries or invokes `func` with optional
                 * `this` binding and partially applied arguments.
                 *
                 * @private
                 * @param {Function|string} func The function or method name to wrap.
                 * @param {number} bitmask The bitmask of wrapper flags.
                 *  The bitmask may be composed of the following flags:
                 *     1 - `_.bind`
                 *     2 - `_.bindKey`
                 *     4 - `_.curry` or `_.curryRight` of a bound function
                 *     8 - `_.curry`
                 *    16 - `_.curryRight`
                 *    32 - `_.partial`
                 *    64 - `_.partialRight`
                 *   128 - `_.rearg`
                 *   256 - `_.ary`
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {Array} [partials] The arguments to be partially applied.
                 * @param {Array} [holders] The `partials` placeholder indexes.
                 * @param {Array} [argPos] The argument positions of the new function.
                 * @param {number} [ary] The arity cap of `func`.
                 * @param {number} [arity] The arity of `func`.
                 * @returns {Function} Returns the new wrapped function.
                 */
                function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                    var isBindKey = bitmask & BIND_KEY_FLAG;
                    if (!isBindKey && typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    var length = partials ? partials.length : 0;
                    if (!length) {
                        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                        partials = holders = undefined;
                    }
                    ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                    arity = arity === undefined ? arity : toInteger(arity);
                    length -= holders ? holders.length : 0;

                    if (bitmask & PARTIAL_RIGHT_FLAG) {
                        var partialsRight = partials,
                            holdersRight = holders;

                        partials = holders = undefined;
                    }
                    var data = isBindKey ? undefined : getData(func);

                    var newData = [
                        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
                        argPos, ary, arity
                    ];

                    if (data) {
                        mergeData(newData, data);
                    }
                    func = newData[0];
                    bitmask = newData[1];
                    thisArg = newData[2];
                    partials = newData[3];
                    holders = newData[4];
                    arity = newData[9] = newData[9] == null
                        ? (isBindKey ? 0 : func.length)
                        : nativeMax(newData[9] - length, 0);

                    if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
                        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
                    }
                    if (!bitmask || bitmask == BIND_FLAG) {
                        var result = createBaseWrapper(func, bitmask, thisArg);
                    } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
                        result = createCurryWrapper(func, bitmask, arity);
                    } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
                        result = createPartialWrapper(func, bitmask, thisArg, partials);
                    } else {
                        result = createHybridWrapper.apply(undefined, newData);
                    }
                    var setter = data ? baseSetData : setData;
                    return setter(result, newData);
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for arrays with support for
                 * partial deep comparisons.
                 *
                 * @private
                 * @param {Array} array The array to compare.
                 * @param {Array} other The other array to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
                 *  for more details.
                 * @param {Object} stack Tracks traversed `array` and `other` objects.
                 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                 */
                function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
                    var index = -1,
                        isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                        isUnordered = bitmask & UNORDERED_COMPARE_FLAG,
                        arrLength = array.length,
                        othLength = other.length;

                    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                        return false;
                    }
                    // Assume cyclic values are equal.
                    var stacked = stack.get(array);
                    if (stacked) {
                        return stacked == other;
                    }
                    var result = true;
                    stack.set(array, other);

                    // Ignore non-index properties.
                    while (++index < arrLength) {
                        var arrValue = array[index],
                            othValue = other[index];

                        if (customizer) {
                            var compared = isPartial
                                ? customizer(othValue, arrValue, index, other, array, stack)
                                : customizer(arrValue, othValue, index, array, other, stack);
                        }
                        if (compared !== undefined) {
                            if (compared) {
                                continue;
                            }
                            result = false;
                            break;
                        }
                        // Recursively compare arrays (susceptible to call stack limits).
                        if (isUnordered) {
                            if (!arraySome(other, function(othValue) {
                                    return arrValue === othValue ||
                                        equalFunc(arrValue, othValue, customizer, bitmask, stack);
                                })) {
                                result = false;
                                break;
                            }
                        } else if (!(
                                arrValue === othValue ||
                                equalFunc(arrValue, othValue, customizer, bitmask, stack)
                            )) {
                            result = false;
                            break;
                        }
                    }
                    stack['delete'](array);
                    return result;
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for comparing objects of
                 * the same `toStringTag`.
                 *
                 * **Note:** This function only supports comparing values with tags of
                 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {string} tag The `toStringTag` of the objects to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
                 *  for more details.
                 * @param {Object} stack Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
                    switch (tag) {
                        case dataViewTag:
                            if ((object.byteLength != other.byteLength) ||
                                (object.byteOffset != other.byteOffset)) {
                                return false;
                            }
                            object = object.buffer;
                            other = other.buffer;

                        case arrayBufferTag:
                            if ((object.byteLength != other.byteLength) ||
                                !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                                return false;
                            }
                            return true;

                        case boolTag:
                        case dateTag:
                            // Coerce dates and booleans to numbers, dates to milliseconds and
                            // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
                            // not equal.
                            return +object == +other;

                        case errorTag:
                            return object.name == other.name && object.message == other.message;

                        case numberTag:
                            // Treat `NaN` vs. `NaN` as equal.
                            return (object != +object) ? other != +other : object == +other;

                        case regexpTag:
                        case stringTag:
                            // Coerce regexes to strings and treat strings, primitives and objects,
                            // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
                            // for more details.
                            return object == (other + '');

                        case mapTag:
                            var convert = mapToArray;

                        case setTag:
                            var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                            convert || (convert = setToArray);

                            if (object.size != other.size && !isPartial) {
                                return false;
                            }
                            // Assume cyclic values are equal.
                            var stacked = stack.get(object);
                            if (stacked) {
                                return stacked == other;
                            }
                            bitmask |= UNORDERED_COMPARE_FLAG;
                            stack.set(object, other);

                            // Recursively compare objects (susceptible to call stack limits).
                            return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

                        case symbolTag:
                            if (symbolValueOf) {
                                return symbolValueOf.call(object) == symbolValueOf.call(other);
                            }
                    }
                    return false;
                }

                /**
                 * A specialized version of `baseIsEqualDeep` for objects with support for
                 * partial deep comparisons.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {Function} equalFunc The function to determine equivalents of values.
                 * @param {Function} customizer The function to customize comparisons.
                 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
                 *  for more details.
                 * @param {Object} stack Tracks traversed `object` and `other` objects.
                 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                 */
                function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
                    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                        objProps = keys(object),
                        objLength = objProps.length,
                        othProps = keys(other),
                        othLength = othProps.length;

                    if (objLength != othLength && !isPartial) {
                        return false;
                    }
                    var index = objLength;
                    while (index--) {
                        var key = objProps[index];
                        if (!(isPartial ? key in other : baseHas(other, key))) {
                            return false;
                        }
                    }
                    // Assume cyclic values are equal.
                    var stacked = stack.get(object);
                    if (stacked) {
                        return stacked == other;
                    }
                    var result = true;
                    stack.set(object, other);

                    var skipCtor = isPartial;
                    while (++index < objLength) {
                        key = objProps[index];
                        var objValue = object[key],
                            othValue = other[key];

                        if (customizer) {
                            var compared = isPartial
                                ? customizer(othValue, objValue, key, other, object, stack)
                                : customizer(objValue, othValue, key, object, other, stack);
                        }
                        // Recursively compare objects (susceptible to call stack limits).
                        if (!(compared === undefined
                                    ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
                                    : compared
                            )) {
                            result = false;
                            break;
                        }
                        skipCtor || (skipCtor = key == 'constructor');
                    }
                    if (result && !skipCtor) {
                        var objCtor = object.constructor,
                            othCtor = other.constructor;

                        // Non `Object` object instances with different constructors are not equal.
                        if (objCtor != othCtor &&
                            ('constructor' in object && 'constructor' in other) &&
                            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                            result = false;
                        }
                    }
                    stack['delete'](object);
                    return result;
                }

                /**
                 * Creates an array of own enumerable property names and symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names and symbols.
                 */
                function getAllKeys(object) {
                    return baseGetAllKeys(object, keys, getSymbols);
                }

                /**
                 * Creates an array of own and inherited enumerable property names and
                 * symbols of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names and symbols.
                 */
                function getAllKeysIn(object) {
                    return baseGetAllKeys(object, keysIn, getSymbolsIn);
                }

                /**
                 * Gets metadata for `func`.
                 *
                 * @private
                 * @param {Function} func The function to query.
                 * @returns {*} Returns the metadata for `func`.
                 */
                var getData = !metaMap ? noop : function(func) {
                    return metaMap.get(func);
                };

                /**
                 * Gets the name of `func`.
                 *
                 * @private
                 * @param {Function} func The function to query.
                 * @returns {string} Returns the function name.
                 */
                function getFuncName(func) {
                    var result = (func.name + ''),
                        array = realNames[result],
                        length = hasOwnProperty.call(realNames, result) ? array.length : 0;

                    while (length--) {
                        var data = array[length],
                            otherFunc = data.func;
                        if (otherFunc == null || otherFunc == func) {
                            return data.name;
                        }
                    }
                    return result;
                }

                /**
                 * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
                 * this function returns the custom method, otherwise it returns `baseIteratee`.
                 * If arguments are provided, the chosen function is invoked with them and
                 * its result is returned.
                 *
                 * @private
                 * @param {*} [value] The value to convert to an iteratee.
                 * @param {number} [arity] The arity of the created iteratee.
                 * @returns {Function} Returns the chosen function or its result.
                 */
                function getIteratee() {
                    var result = lodash.iteratee || iteratee;
                    result = result === iteratee ? baseIteratee : result;
                    return arguments.length ? result(arguments[0], arguments[1]) : result;
                }

                /**
                 * Gets the "length" property value of `object`.
                 *
                 * **Note:** This function is used to avoid a
                 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
                 * Safari on at least iOS 8.1-8.3 ARM64.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {*} Returns the "length" value.
                 */
                var getLength = baseProperty('length');

                /**
                 * Gets the property names, values, and compare flags of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the match data of `object`.
                 */
                function getMatchData(object) {
                    var result = toPairs(object),
                        length = result.length;

                    while (length--) {
                        result[length][2] = isStrictComparable(result[length][1]);
                    }
                    return result;
                }

                /**
                 * Gets the native function at `key` of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {string} key The key of the method to get.
                 * @returns {*} Returns the function if it's native, else `undefined`.
                 */
                function getNative(object, key) {
                    var value = object[key];
                    return isNative(value) ? value : undefined;
                }

                /**
                 * Gets the argument placeholder value for `func`.
                 *
                 * @private
                 * @param {Function} func The function to inspect.
                 * @returns {*} Returns the placeholder value.
                 */
                function getPlaceholder(func) {
                    var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
                    return object.placeholder;
                }

                /**
                 * Gets the `[[Prototype]]` of `value`.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @returns {null|Object} Returns the `[[Prototype]]`.
                 */
                function getPrototype(value) {
                    return nativeGetPrototype(Object(value));
                }

                /**
                 * Creates an array of the own enumerable symbol properties of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of symbols.
                 */
                function getSymbols(object) {
                    // Coerce `object` to an object to avoid non-object errors in V8.
                    // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
                    return getOwnPropertySymbols(Object(object));
                }

                // Fallback for IE < 11.
                if (!getOwnPropertySymbols) {
                    getSymbols = function() {
                        return [];
                    };
                }

                /**
                 * Creates an array of the own and inherited enumerable symbol properties
                 * of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of symbols.
                 */
                var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function(object) {
                    var result = [];
                    while (object) {
                        arrayPush(result, getSymbols(object));
                        object = getPrototype(object);
                    }
                    return result;
                };

                /**
                 * Gets the `toStringTag` of `value`.
                 *
                 * @private
                 * @param {*} value The value to query.
                 * @returns {string} Returns the `toStringTag`.
                 */
                function getTag(value) {
                    return objectToString.call(value);
                }

                // Fallback for data views, maps, sets, and weak maps in IE 11,
                // for data views in Edge, and promises in Node.js.
                if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                    (Map && getTag(new Map) != mapTag) ||
                    (Promise && getTag(Promise.resolve()) != promiseTag) ||
                    (Set && getTag(new Set) != setTag) ||
                    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
                    getTag = function(value) {
                        var result = objectToString.call(value),
                            Ctor = result == objectTag ? value.constructor : undefined,
                            ctorString = Ctor ? toSource(Ctor) : undefined;

                        if (ctorString) {
                            switch (ctorString) {
                                case dataViewCtorString: return dataViewTag;
                                case mapCtorString: return mapTag;
                                case promiseCtorString: return promiseTag;
                                case setCtorString: return setTag;
                                case weakMapCtorString: return weakMapTag;
                            }
                        }
                        return result;
                    };
                }

                /**
                 * Gets the view, applying any `transforms` to the `start` and `end` positions.
                 *
                 * @private
                 * @param {number} start The start of the view.
                 * @param {number} end The end of the view.
                 * @param {Array} transforms The transformations to apply to the view.
                 * @returns {Object} Returns an object containing the `start` and `end`
                 *  positions of the view.
                 */
                function getView(start, end, transforms) {
                    var index = -1,
                        length = transforms.length;

                    while (++index < length) {
                        var data = transforms[index],
                            size = data.size;

                        switch (data.type) {
                            case 'drop':      start += size; break;
                            case 'dropRight': end -= size; break;
                            case 'take':      end = nativeMin(end, start + size); break;
                            case 'takeRight': start = nativeMax(start, end - size); break;
                        }
                    }
                    return { 'start': start, 'end': end };
                }

                /**
                 * Checks if `path` exists on `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path to check.
                 * @param {Function} hasFunc The function to check properties.
                 * @returns {boolean} Returns `true` if `path` exists, else `false`.
                 */
                function hasPath(object, path, hasFunc) {
                    path = isKey(path, object) ? [path] : castPath(path);

                    var result,
                        index = -1,
                        length = path.length;

                    while (++index < length) {
                        var key = path[index];
                        if (!(result = object != null && hasFunc(object, key))) {
                            break;
                        }
                        object = object[key];
                    }
                    if (result) {
                        return result;
                    }
                    var length = object ? object.length : 0;
                    return !!length && isLength(length) && isIndex(key, length) &&
                        (isArray(object) || isString(object) || isArguments(object));
                }

                /**
                 * Initializes an array clone.
                 *
                 * @private
                 * @param {Array} array The array to clone.
                 * @returns {Array} Returns the initialized clone.
                 */
                function initCloneArray(array) {
                    var length = array.length,
                        result = array.constructor(length);

                    // Add properties assigned by `RegExp#exec`.
                    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                        result.index = array.index;
                        result.input = array.input;
                    }
                    return result;
                }

                /**
                 * Initializes an object clone.
                 *
                 * @private
                 * @param {Object} object The object to clone.
                 * @returns {Object} Returns the initialized clone.
                 */
                function initCloneObject(object) {
                    return (typeof object.constructor == 'function' && !isPrototype(object))
                        ? baseCreate(getPrototype(object))
                        : {};
                }

                /**
                 * Initializes an object clone based on its `toStringTag`.
                 *
                 * **Note:** This function only supports cloning values with tags of
                 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                 *
                 * @private
                 * @param {Object} object The object to clone.
                 * @param {string} tag The `toStringTag` of the object to clone.
                 * @param {Function} cloneFunc The function to clone values.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Object} Returns the initialized clone.
                 */
                function initCloneByTag(object, tag, cloneFunc, isDeep) {
                    var Ctor = object.constructor;
                    switch (tag) {
                        case arrayBufferTag:
                            return cloneArrayBuffer(object);

                        case boolTag:
                        case dateTag:
                            return new Ctor(+object);

                        case dataViewTag:
                            return cloneDataView(object, isDeep);

                        case float32Tag: case float64Tag:
                        case int8Tag: case int16Tag: case int32Tag:
                        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
                        return cloneTypedArray(object, isDeep);

                        case mapTag:
                            return cloneMap(object, isDeep, cloneFunc);

                        case numberTag:
                        case stringTag:
                            return new Ctor(object);

                        case regexpTag:
                            return cloneRegExp(object);

                        case setTag:
                            return cloneSet(object, isDeep, cloneFunc);

                        case symbolTag:
                            return cloneSymbol(object);
                    }
                }

                /**
                 * Creates an array of index keys for `object` values of arrays,
                 * `arguments` objects, and strings, otherwise `null` is returned.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @returns {Array|null} Returns index keys, else `null`.
                 */
                function indexKeys(object) {
                    var length = object ? object.length : undefined;
                    if (isLength(length) &&
                        (isArray(object) || isString(object) || isArguments(object))) {
                        return baseTimes(length, String);
                    }
                    return null;
                }

                /**
                 * Checks if `value` is a flattenable `arguments` object or array.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
                 */
                function isFlattenable(value) {
                    return isArrayLikeObject(value) && (isArray(value) || isArguments(value));
                }

                /**
                 * Checks if `value` is a flattenable array and not a `_.matchesProperty`
                 * iteratee shorthand.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
                 */
                function isFlattenableIteratee(value) {
                    return isArray(value) && !(value.length == 2 && !isFunction(value[0]));
                }

                /**
                 * Checks if the given arguments are from an iteratee call.
                 *
                 * @private
                 * @param {*} value The potential iteratee value argument.
                 * @param {*} index The potential iteratee index or key argument.
                 * @param {*} object The potential iteratee object argument.
                 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
                 *  else `false`.
                 */
                function isIterateeCall(value, index, object) {
                    if (!isObject(object)) {
                        return false;
                    }
                    var type = typeof index;
                    if (type == 'number'
                            ? (isArrayLike(object) && isIndex(index, object.length))
                            : (type == 'string' && index in object)
                    ) {
                        return eq(object[index], value);
                    }
                    return false;
                }

                /**
                 * Checks if `value` is a property name and not a property path.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @param {Object} [object] The object to query keys on.
                 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                 */
                function isKey(value, object) {
                    var type = typeof value;
                    if (type == 'number' || type == 'symbol') {
                        return true;
                    }
                    return !isArray(value) &&
                        (isSymbol(value) || reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
                        (object != null && value in Object(object)));
                }

                /**
                 * Checks if `value` is suitable for use as unique object key.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                 */
                function isKeyable(value) {
                    var type = typeof value;
                    return type == 'number' || type == 'boolean' ||
                        (type == 'string' && value != '__proto__') || value == null;
                }

                /**
                 * Checks if `func` has a lazy counterpart.
                 *
                 * @private
                 * @param {Function} func The function to check.
                 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
                 *  else `false`.
                 */
                function isLaziable(func) {
                    var funcName = getFuncName(func),
                        other = lodash[funcName];

                    if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                        return false;
                    }
                    if (func === other) {
                        return true;
                    }
                    var data = getData(other);
                    return !!data && func === data[0];
                }

                /**
                 * Checks if `value` is likely a prototype object.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                 */
                function isPrototype(value) {
                    var Ctor = value && value.constructor,
                        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

                    return value === proto;
                }

                /**
                 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` if suitable for strict
                 *  equality comparisons, else `false`.
                 */
                function isStrictComparable(value) {
                    return value === value && !isObject(value);
                }

                /**
                 * A specialized version of `matchesProperty` for source values suitable
                 * for strict equality comparisons, i.e. `===`.
                 *
                 * @private
                 * @param {string} key The key of the property to get.
                 * @param {*} srcValue The value to match.
                 * @returns {Function} Returns the new function.
                 */
                function matchesStrictComparable(key, srcValue) {
                    return function(object) {
                        if (object == null) {
                            return false;
                        }
                        return object[key] === srcValue &&
                            (srcValue !== undefined || (key in Object(object)));
                    };
                }

                /**
                 * Merges the function metadata of `source` into `data`.
                 *
                 * Merging metadata reduces the number of wrappers used to invoke a function.
                 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                 * may be applied regardless of execution order. Methods like `_.ary` and
                 * `_.rearg` modify function arguments, making the order in which they are
                 * executed important, preventing the merging of metadata. However, we make
                 * an exception for a safe combined case where curried functions have `_.ary`
                 * and or `_.rearg` applied.
                 *
                 * @private
                 * @param {Array} data The destination metadata.
                 * @param {Array} source The source metadata.
                 * @returns {Array} Returns `data`.
                 */
                function mergeData(data, source) {
                    var bitmask = data[1],
                        srcBitmask = source[1],
                        newBitmask = bitmask | srcBitmask,
                        isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);

                    var isCombo =
                        ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||
                        ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
                        ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));

                    // Exit early if metadata can't be merged.
                    if (!(isCommon || isCombo)) {
                        return data;
                    }
                    // Use source `thisArg` if available.
                    if (srcBitmask & BIND_FLAG) {
                        data[2] = source[2];
                        // Set when currying a bound function.
                        newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
                    }
                    // Compose partial arguments.
                    var value = source[3];
                    if (value) {
                        var partials = data[3];
                        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                    }
                    // Compose partial right arguments.
                    value = source[5];
                    if (value) {
                        partials = data[5];
                        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                    }
                    // Use source `argPos` if available.
                    value = source[7];
                    if (value) {
                        data[7] = value;
                    }
                    // Use source `ary` if it's smaller.
                    if (srcBitmask & ARY_FLAG) {
                        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                    }
                    // Use source `arity` if one is not provided.
                    if (data[9] == null) {
                        data[9] = source[9];
                    }
                    // Use source `func` and merge bitmasks.
                    data[0] = source[0];
                    data[1] = newBitmask;

                    return data;
                }

                /**
                 * Used by `_.defaultsDeep` to customize its `_.merge` use.
                 *
                 * @private
                 * @param {*} objValue The destination value.
                 * @param {*} srcValue The source value.
                 * @param {string} key The key of the property to merge.
                 * @param {Object} object The parent object of `objValue`.
                 * @param {Object} source The parent object of `srcValue`.
                 * @param {Object} [stack] Tracks traversed source values and their merged
                 *  counterparts.
                 * @returns {*} Returns the value to assign.
                 */
                function mergeDefaults(objValue, srcValue, key, object, source, stack) {
                    if (isObject(objValue) && isObject(srcValue)) {
                        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
                    }
                    return objValue;
                }

                /**
                 * Gets the parent value at `path` of `object`.
                 *
                 * @private
                 * @param {Object} object The object to query.
                 * @param {Array} path The path to get the parent value of.
                 * @returns {*} Returns the parent value.
                 */
                function parent(object, path) {
                    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                }

                /**
                 * Reorder `array` according to the specified indexes where the element at
                 * the first index is assigned as the first element, the element at
                 * the second index is assigned as the second element, and so on.
                 *
                 * @private
                 * @param {Array} array The array to reorder.
                 * @param {Array} indexes The arranged array indexes.
                 * @returns {Array} Returns `array`.
                 */
                function reorder(array, indexes) {
                    var arrLength = array.length,
                        length = nativeMin(indexes.length, arrLength),
                        oldArray = copyArray(array);

                    while (length--) {
                        var index = indexes[length];
                        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                    }
                    return array;
                }

                /**
                 * Sets metadata for `func`.
                 *
                 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                 * period of time, it will trip its breaker and transition to an identity
                 * function to avoid garbage collection pauses in V8. See
                 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
                 * for more details.
                 *
                 * @private
                 * @param {Function} func The function to associate metadata with.
                 * @param {*} data The metadata.
                 * @returns {Function} Returns `func`.
                 */
                var setData = (function() {
                    var count = 0,
                        lastCalled = 0;

                    return function(key, value) {
                        var stamp = now(),
                            remaining = HOT_SPAN - (stamp - lastCalled);

                        lastCalled = stamp;
                        if (remaining > 0) {
                            if (++count >= HOT_COUNT) {
                                return key;
                            }
                        } else {
                            count = 0;
                        }
                        return baseSetData(key, value);
                    };
                }());

                /**
                 * Converts `string` to a property path array.
                 *
                 * @private
                 * @param {string} string The string to convert.
                 * @returns {Array} Returns the property path array.
                 */
                var stringToPath = memoize(function(string) {
                    var result = [];
                    toString(string).replace(rePropName, function(match, number, quote, string) {
                        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
                    });
                    return result;
                });

                /**
                 * Converts `value` to a string key if it's not a string or symbol.
                 *
                 * @private
                 * @param {*} value The value to inspect.
                 * @returns {string|symbol} Returns the key.
                 */
                function toKey(key) {
                    return (typeof key == 'string' || isSymbol(key)) ? key : (key + '');
                }

                /**
                 * Converts `func` to its source code.
                 *
                 * @private
                 * @param {Function} func The function to process.
                 * @returns {string} Returns the source code.
                 */
                function toSource(func) {
                    if (func != null) {
                        try {
                            return funcToString.call(func);
                        } catch (e) {}
                        try {
                            return (func + '');
                        } catch (e) {}
                    }
                    return '';
                }

                /**
                 * Creates a clone of `wrapper`.
                 *
                 * @private
                 * @param {Object} wrapper The wrapper to clone.
                 * @returns {Object} Returns the cloned wrapper.
                 */
                function wrapperClone(wrapper) {
                    if (wrapper instanceof LazyWrapper) {
                        return wrapper.clone();
                    }
                    var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                    result.__actions__ = copyArray(wrapper.__actions__);
                    result.__index__  = wrapper.__index__;
                    result.__values__ = wrapper.__values__;
                    return result;
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an array of elements split into groups the length of `size`.
                 * If `array` can't be split evenly, the final chunk will be the remaining
                 * elements.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to process.
                 * @param {number} [size=1] The length of each chunk
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the new array containing chunks.
                 * @example
                 *
                 * _.chunk(['a', 'b', 'c', 'd'], 2);
                 * // => [['a', 'b'], ['c', 'd']]
                 *
                 * _.chunk(['a', 'b', 'c', 'd'], 3);
                 * // => [['a', 'b', 'c'], ['d']]
                 */
                function chunk(array, size, guard) {
                    if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
                        size = 1;
                    } else {
                        size = nativeMax(toInteger(size), 0);
                    }
                    var length = array ? array.length : 0;
                    if (!length || size < 1) {
                        return [];
                    }
                    var index = 0,
                        resIndex = 0,
                        result = Array(nativeCeil(length / size));

                    while (index < length) {
                        result[resIndex++] = baseSlice(array, index, (index += size));
                    }
                    return result;
                }

                /**
                 * Creates an array with all falsey values removed. The values `false`, `null`,
                 * `0`, `""`, `undefined`, and `NaN` are falsey.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to compact.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * _.compact([0, 1, false, 2, '', 3]);
                 * // => [1, 2, 3]
                 */
                function compact(array) {
                    var index = -1,
                        length = array ? array.length : 0,
                        resIndex = 0,
                        result = [];

                    while (++index < length) {
                        var value = array[index];
                        if (value) {
                            result[resIndex++] = value;
                        }
                    }
                    return result;
                }

                /**
                 * Creates a new array concatenating `array` with any additional arrays
                 * and/or values.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to concatenate.
                 * @param {...*} [values] The values to concatenate.
                 * @returns {Array} Returns the new concatenated array.
                 * @example
                 *
                 * var array = [1];
                 * var other = _.concat(array, 2, [3], [[4]]);
                 *
                 * console.log(other);
                 * // => [1, 2, 3, [4]]
                 *
                 * console.log(array);
                 * // => [1]
                 */
                function concat() {
                    var length = arguments.length,
                        array = castArray(arguments[0]);

                    if (length < 2) {
                        return length ? copyArray(array) : [];
                    }
                    var args = Array(length - 1);
                    while (length--) {
                        args[length - 1] = arguments[length];
                    }
                    return arrayConcat(array, baseFlatten(args, 1));
                }

                /**
                 * Creates an array of unique `array` values not included in the other given
                 * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons. The order of result values is determined by the
                 * order they occur in the first array.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {...Array} [values] The values to exclude.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * _.difference([3, 2, 1], [4, 2]);
                 * // => [3, 1]
                 */
                var difference = rest(function(array, values) {
                    return isArrayLikeObject(array)
                        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
                        : [];
                });

                /**
                 * This method is like `_.difference` except that it accepts `iteratee` which
                 * is invoked for each element of `array` and `values` to generate the criterion
                 * by which they're compared. Result values are chosen from the first array.
                 * The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {...Array} [values] The values to exclude.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
                 * // => [3.1, 1.3]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
                 * // => [{ 'x': 2 }]
                 */
                var differenceBy = rest(function(array, values) {
                    var iteratee = last(values);
                    if (isArrayLikeObject(iteratee)) {
                        iteratee = undefined;
                    }
                    return isArrayLikeObject(array)
                        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee))
                        : [];
                });

                /**
                 * This method is like `_.difference` except that it accepts `comparator`
                 * which is invoked to compare elements of `array` to `values`. Result values
                 * are chosen from the first array. The comparator is invoked with two arguments:
                 * (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {...Array} [values] The values to exclude.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                 *
                 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
                 * // => [{ 'x': 2, 'y': 1 }]
                 */
                var differenceWith = rest(function(array, values) {
                    var comparator = last(values);
                    if (isArrayLikeObject(comparator)) {
                        comparator = undefined;
                    }
                    return isArrayLikeObject(array)
                        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
                        : [];
                });

                /**
                 * Creates a slice of `array` with `n` elements dropped from the beginning.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.5.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=1] The number of elements to drop.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.drop([1, 2, 3]);
                 * // => [2, 3]
                 *
                 * _.drop([1, 2, 3], 2);
                 * // => [3]
                 *
                 * _.drop([1, 2, 3], 5);
                 * // => []
                 *
                 * _.drop([1, 2, 3], 0);
                 * // => [1, 2, 3]
                 */
                function drop(array, n, guard) {
                    var length = array ? array.length : 0;
                    if (!length) {
                        return [];
                    }
                    n = (guard || n === undefined) ? 1 : toInteger(n);
                    return baseSlice(array, n < 0 ? 0 : n, length);
                }

                /**
                 * Creates a slice of `array` with `n` elements dropped from the end.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=1] The number of elements to drop.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.dropRight([1, 2, 3]);
                 * // => [1, 2]
                 *
                 * _.dropRight([1, 2, 3], 2);
                 * // => [1]
                 *
                 * _.dropRight([1, 2, 3], 5);
                 * // => []
                 *
                 * _.dropRight([1, 2, 3], 0);
                 * // => [1, 2, 3]
                 */
                function dropRight(array, n, guard) {
                    var length = array ? array.length : 0;
                    if (!length) {
                        return [];
                    }
                    n = (guard || n === undefined) ? 1 : toInteger(n);
                    n = length - n;
                    return baseSlice(array, 0, n < 0 ? 0 : n);
                }

                /**
                 * Creates a slice of `array` excluding elements dropped from the end.
                 * Elements are dropped until `predicate` returns falsey. The predicate is
                 * invoked with three arguments: (value, index, array).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': true },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': false }
                 * ];
                 *
                 * _.dropRightWhile(users, function(o) { return !o.active; });
                 * // => objects for ['barney']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
                 * // => objects for ['barney', 'fred']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.dropRightWhile(users, ['active', false]);
                 * // => objects for ['barney']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.dropRightWhile(users, 'active');
                 * // => objects for ['barney', 'fred', 'pebbles']
                 */
                function dropRightWhile(array, predicate) {
                    return (array && array.length)
                        ? baseWhile(array, getIteratee(predicate, 3), true, true)
                        : [];
                }

                /**
                 * Creates a slice of `array` excluding elements dropped from the beginning.
                 * Elements are dropped until `predicate` returns falsey. The predicate is
                 * invoked with three arguments: (value, index, array).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': false },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': true }
                 * ];
                 *
                 * _.dropWhile(users, function(o) { return !o.active; });
                 * // => objects for ['pebbles']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.dropWhile(users, { 'user': 'barney', 'active': false });
                 * // => objects for ['fred', 'pebbles']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.dropWhile(users, ['active', false]);
                 * // => objects for ['pebbles']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.dropWhile(users, 'active');
                 * // => objects for ['barney', 'fred', 'pebbles']
                 */
                function dropWhile(array, predicate) {
                    return (array && array.length)
                        ? baseWhile(array, getIteratee(predicate, 3), true)
                        : [];
                }

                /**
                 * Fills elements of `array` with `value` from `start` up to, but not
                 * including, `end`.
                 *
                 * **Note:** This method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.2.0
                 * @category Array
                 * @param {Array} array The array to fill.
                 * @param {*} value The value to fill `array` with.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [1, 2, 3];
                 *
                 * _.fill(array, 'a');
                 * console.log(array);
                 * // => ['a', 'a', 'a']
                 *
                 * _.fill(Array(3), 2);
                 * // => [2, 2, 2]
                 *
                 * _.fill([4, 6, 8, 10], '*', 1, 3);
                 * // => [4, '*', '*', 10]
                 */
                function fill(array, value, start, end) {
                    var length = array ? array.length : 0;
                    if (!length) {
                        return [];
                    }
                    if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                        start = 0;
                        end = length;
                    }
                    return baseFill(array, value, start, end);
                }

                /**
                 * This method is like `_.find` except that it returns the index of the first
                 * element `predicate` returns truthy for instead of the element itself.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.1.0
                 * @category Array
                 * @param {Array} array The array to search.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {number} Returns the index of the found element, else `-1`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': false },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': true }
                 * ];
                 *
                 * _.findIndex(users, function(o) { return o.user == 'barney'; });
                 * // => 0
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.findIndex(users, { 'user': 'fred', 'active': false });
                 * // => 1
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.findIndex(users, ['active', false]);
                 * // => 0
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.findIndex(users, 'active');
                 * // => 2
                 */
                function findIndex(array, predicate) {
                    return (array && array.length)
                        ? baseFindIndex(array, getIteratee(predicate, 3))
                        : -1;
                }

                /**
                 * This method is like `_.findIndex` except that it iterates over elements
                 * of `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Array
                 * @param {Array} array The array to search.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {number} Returns the index of the found element, else `-1`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': true },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': false }
                 * ];
                 *
                 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
                 * // => 2
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
                 * // => 0
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.findLastIndex(users, ['active', false]);
                 * // => 2
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.findLastIndex(users, 'active');
                 * // => 0
                 */
                function findLastIndex(array, predicate) {
                    return (array && array.length)
                        ? baseFindIndex(array, getIteratee(predicate, 3), true)
                        : -1;
                }

                /**
                 * Flattens `array` a single level deep.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to flatten.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * _.flatten([1, [2, [3, [4]], 5]]);
                 * // => [1, 2, [3, [4]], 5]
                 */
                function flatten(array) {
                    var length = array ? array.length : 0;
                    return length ? baseFlatten(array, 1) : [];
                }

                /**
                 * Recursively flattens `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to flatten.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * _.flattenDeep([1, [2, [3, [4]], 5]]);
                 * // => [1, 2, 3, 4, 5]
                 */
                function flattenDeep(array) {
                    var length = array ? array.length : 0;
                    return length ? baseFlatten(array, INFINITY) : [];
                }

                /**
                 * Recursively flatten `array` up to `depth` times.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.4.0
                 * @category Array
                 * @param {Array} array The array to flatten.
                 * @param {number} [depth=1] The maximum recursion depth.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * var array = [1, [2, [3, [4]], 5]];
                 *
                 * _.flattenDepth(array, 1);
                 * // => [1, 2, [3, [4]], 5]
                 *
                 * _.flattenDepth(array, 2);
                 * // => [1, 2, 3, [4], 5]
                 */
                function flattenDepth(array, depth) {
                    var length = array ? array.length : 0;
                    if (!length) {
                        return [];
                    }
                    depth = depth === undefined ? 1 : toInteger(depth);
                    return baseFlatten(array, depth);
                }

                /**
                 * The inverse of `_.toPairs`; this method returns an object composed
                 * from key-value `pairs`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} pairs The key-value pairs.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * _.fromPairs([['fred', 30], ['barney', 40]]);
                 * // => { 'fred': 30, 'barney': 40 }
                 */
                function fromPairs(pairs) {
                    var index = -1,
                        length = pairs ? pairs.length : 0,
                        result = {};

                    while (++index < length) {
                        var pair = pairs[index];
                        result[pair[0]] = pair[1];
                    }
                    return result;
                }

                /**
                 * Gets the first element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @alias first
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {*} Returns the first element of `array`.
                 * @example
                 *
                 * _.head([1, 2, 3]);
                 * // => 1
                 *
                 * _.head([]);
                 * // => undefined
                 */
                function head(array) {
                    return (array && array.length) ? array[0] : undefined;
                }

                /**
                 * Gets the index at which the first occurrence of `value` is found in `array`
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons. If `fromIndex` is negative, it's used as the
                 * offset from the end of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.indexOf([1, 2, 1, 2], 2);
                 * // => 1
                 *
                 * // Search from the `fromIndex`.
                 * _.indexOf([1, 2, 1, 2], 2, 2);
                 * // => 3
                 */
                function indexOf(array, value, fromIndex) {
                    var length = array ? array.length : 0;
                    if (!length) {
                        return -1;
                    }
                    fromIndex = toInteger(fromIndex);
                    if (fromIndex < 0) {
                        fromIndex = nativeMax(length + fromIndex, 0);
                    }
                    return baseIndexOf(array, value, fromIndex);
                }

                /**
                 * Gets all but the last element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.initial([1, 2, 3]);
                 * // => [1, 2]
                 */
                function initial(array) {
                    return dropRight(array, 1);
                }

                /**
                 * Creates an array of unique values that are included in all given arrays
                 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons. The order of result values is determined by the
                 * order they occur in the first array.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @returns {Array} Returns the new array of intersecting values.
                 * @example
                 *
                 * _.intersection([2, 1], [4, 2], [1, 2]);
                 * // => [2]
                 */
                var intersection = rest(function(arrays) {
                    var mapped = arrayMap(arrays, castArrayLikeObject);
                    return (mapped.length && mapped[0] === arrays[0])
                        ? baseIntersection(mapped)
                        : [];
                });

                /**
                 * This method is like `_.intersection` except that it accepts `iteratee`
                 * which is invoked for each element of each `arrays` to generate the criterion
                 * by which they're compared. Result values are chosen from the first array.
                 * The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {Array} Returns the new array of intersecting values.
                 * @example
                 *
                 * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
                 * // => [2.1]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 1 }]
                 */
                var intersectionBy = rest(function(arrays) {
                    var iteratee = last(arrays),
                        mapped = arrayMap(arrays, castArrayLikeObject);

                    if (iteratee === last(mapped)) {
                        iteratee = undefined;
                    } else {
                        mapped.pop();
                    }
                    return (mapped.length && mapped[0] === arrays[0])
                        ? baseIntersection(mapped, getIteratee(iteratee))
                        : [];
                });

                /**
                 * This method is like `_.intersection` except that it accepts `comparator`
                 * which is invoked to compare elements of `arrays`. Result values are chosen
                 * from the first array. The comparator is invoked with two arguments:
                 * (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of intersecting values.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                 *
                 * _.intersectionWith(objects, others, _.isEqual);
                 * // => [{ 'x': 1, 'y': 2 }]
                 */
                var intersectionWith = rest(function(arrays) {
                    var comparator = last(arrays),
                        mapped = arrayMap(arrays, castArrayLikeObject);

                    if (comparator === last(mapped)) {
                        comparator = undefined;
                    } else {
                        mapped.pop();
                    }
                    return (mapped.length && mapped[0] === arrays[0])
                        ? baseIntersection(mapped, undefined, comparator)
                        : [];
                });

                /**
                 * Converts all elements in `array` into a string separated by `separator`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to convert.
                 * @param {string} [separator=','] The element separator.
                 * @returns {string} Returns the joined string.
                 * @example
                 *
                 * _.join(['a', 'b', 'c'], '~');
                 * // => 'a~b~c'
                 */
                function join(array, separator) {
                    return array ? nativeJoin.call(array, separator) : '';
                }

                /**
                 * Gets the last element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {*} Returns the last element of `array`.
                 * @example
                 *
                 * _.last([1, 2, 3]);
                 * // => 3
                 */
                function last(array) {
                    var length = array ? array.length : 0;
                    return length ? array[length - 1] : undefined;
                }

                /**
                 * This method is like `_.indexOf` except that it iterates over elements of
                 * `array` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=array.length-1] The index to search from.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.lastIndexOf([1, 2, 1, 2], 2);
                 * // => 3
                 *
                 * // Search from the `fromIndex`.
                 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
                 * // => 1
                 */
                function lastIndexOf(array, value, fromIndex) {
                    var length = array ? array.length : 0;
                    if (!length) {
                        return -1;
                    }
                    var index = length;
                    if (fromIndex !== undefined) {
                        index = toInteger(fromIndex);
                        index = (
                                index < 0
                                    ? nativeMax(length + index, 0)
                                    : nativeMin(index, length - 1)
                            ) + 1;
                    }
                    if (value !== value) {
                        return indexOfNaN(array, index, true);
                    }
                    while (index--) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * Gets the nth element of `array`. If `n` is negative, the nth element
                 * from the end is returned.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.11.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=0] The index of the element to return.
                 * @returns {*} Returns the nth element of `array`.
                 * @example
                 *
                 * var array = ['a', 'b', 'c', 'd'];
                 *
                 * _.nth(array, 1);
                 * // => 'b'
                 *
                 * _.nth(array, -2);
                 * // => 'c';
                 */
                function nth(array, n) {
                    return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
                }

                /**
                 * Removes all given values from `array` using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
                 * to remove elements from an array by predicate.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {...*} [values] The values to remove.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [1, 2, 3, 1, 2, 3];
                 *
                 * _.pull(array, 2, 3);
                 * console.log(array);
                 * // => [1, 1]
                 */
                var pull = rest(pullAll);

                /**
                 * This method is like `_.pull` except that it accepts an array of values to remove.
                 *
                 * **Note:** Unlike `_.difference`, this method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to remove.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [1, 2, 3, 1, 2, 3];
                 *
                 * _.pullAll(array, [2, 3]);
                 * console.log(array);
                 * // => [1, 1]
                 */
                function pullAll(array, values) {
                    return (array && array.length && values && values.length)
                        ? basePullAll(array, values)
                        : array;
                }

                /**
                 * This method is like `_.pullAll` except that it accepts `iteratee` which is
                 * invoked for each element of `array` and `values` to generate the criterion
                 * by which they're compared. The iteratee is invoked with one argument: (value).
                 *
                 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to remove.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
                 *
                 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
                 * console.log(array);
                 * // => [{ 'x': 2 }]
                 */
                function pullAllBy(array, values, iteratee) {
                    return (array && array.length && values && values.length)
                        ? basePullAll(array, values, getIteratee(iteratee))
                        : array;
                }

                /**
                 * This method is like `_.pullAll` except that it accepts `comparator` which
                 * is invoked to compare elements of `array` to `values`. The comparator is
                 * invoked with two arguments: (arrVal, othVal).
                 *
                 * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.6.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {Array} values The values to remove.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
                 *
                 * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
                 * console.log(array);
                 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
                 */
                function pullAllWith(array, values, comparator) {
                    return (array && array.length && values && values.length)
                        ? basePullAll(array, values, undefined, comparator)
                        : array;
                }

                /**
                 * Removes elements from `array` corresponding to `indexes` and returns an
                 * array of removed elements.
                 *
                 * **Note:** Unlike `_.at`, this method mutates `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
                 * @returns {Array} Returns the new array of removed elements.
                 * @example
                 *
                 * var array = [5, 10, 15, 20];
                 * var evens = _.pullAt(array, 1, 3);
                 *
                 * console.log(array);
                 * // => [5, 15]
                 *
                 * console.log(evens);
                 * // => [10, 20]
                 */
                var pullAt = rest(function(array, indexes) {
                    indexes = arrayMap(baseFlatten(indexes, 1), String);

                    var result = baseAt(array, indexes);
                    basePullAt(array, indexes.sort(compareAscending));
                    return result;
                });

                /**
                 * Removes all elements from `array` that `predicate` returns truthy for
                 * and returns an array of the removed elements. The predicate is invoked
                 * with three arguments: (value, index, array).
                 *
                 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
                 * to pull elements from an array by value.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the new array of removed elements.
                 * @example
                 *
                 * var array = [1, 2, 3, 4];
                 * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
                 *
                 * console.log(array);
                 * // => [1, 3]
                 *
                 * console.log(evens);
                 * // => [2, 4]
                 */
                function remove(array, predicate) {
                    var result = [];
                    if (!(array && array.length)) {
                        return result;
                    }
                    var index = -1,
                        indexes = [],
                        length = array.length;

                    predicate = getIteratee(predicate, 3);
                    while (++index < length) {
                        var value = array[index];
                        if (predicate(value, index, array)) {
                            result.push(value);
                            indexes.push(index);
                        }
                    }
                    basePullAt(array, indexes);
                    return result;
                }

                /**
                 * Reverses `array` so that the first element becomes the last, the second
                 * element becomes the second to last, and so on.
                 *
                 * **Note:** This method mutates `array` and is based on
                 * [`Array#reverse`](https://mdn.io/Array/reverse).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to modify.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [1, 2, 3];
                 *
                 * _.reverse(array);
                 * // => [3, 2, 1]
                 *
                 * console.log(array);
                 * // => [3, 2, 1]
                 */
                function reverse(array) {
                    return array ? nativeReverse.call(array) : array;
                }

                /**
                 * Creates a slice of `array` from `start` up to, but not including, `end`.
                 *
                 * **Note:** This method is used instead of
                 * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
                 * returned.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to slice.
                 * @param {number} [start=0] The start position.
                 * @param {number} [end=array.length] The end position.
                 * @returns {Array} Returns the slice of `array`.
                 */
                function slice(array, start, end) {
                    var length = array ? array.length : 0;
                    if (!length) {
                        return [];
                    }
                    if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                        start = 0;
                        end = length;
                    }
                    else {
                        start = start == null ? 0 : toInteger(start);
                        end = end === undefined ? length : toInteger(end);
                    }
                    return baseSlice(array, start, end);
                }

                /**
                 * Uses a binary search to determine the lowest index at which `value`
                 * should be inserted into `array` in order to maintain its sort order.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * _.sortedIndex([30, 50], 40);
                 * // => 1
                 *
                 * _.sortedIndex([4, 5], 4);
                 * // => 0
                 */
                function sortedIndex(array, value) {
                    return baseSortedIndex(array, value);
                }

                /**
                 * This method is like `_.sortedIndex` except that it accepts `iteratee`
                 * which is invoked for `value` and each element of `array` to compute their
                 * sort ranking. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
                 *
                 * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
                 * // => 1
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
                 * // => 0
                 */
                function sortedIndexBy(array, value, iteratee) {
                    return baseSortedIndexBy(array, value, getIteratee(iteratee));
                }

                /**
                 * This method is like `_.indexOf` except that it performs a binary
                 * search on a sorted `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.sortedIndexOf([1, 1, 2, 2], 2);
                 * // => 2
                 */
                function sortedIndexOf(array, value) {
                    var length = array ? array.length : 0;
                    if (length) {
                        var index = baseSortedIndex(array, value);
                        if (index < length && eq(array[index], value)) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * This method is like `_.sortedIndex` except that it returns the highest
                 * index at which `value` should be inserted into `array` in order to
                 * maintain its sort order.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * _.sortedLastIndex([4, 5], 4);
                 * // => 1
                 */
                function sortedLastIndex(array, value) {
                    return baseSortedIndex(array, value, true);
                }

                /**
                 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
                 * which is invoked for `value` and each element of `array` to compute their
                 * sort ranking. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The sorted array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
                 * // => 1
                 */
                function sortedLastIndexBy(array, value, iteratee) {
                    return baseSortedIndexBy(array, value, getIteratee(iteratee), true);
                }

                /**
                 * This method is like `_.lastIndexOf` except that it performs a binary
                 * search on a sorted `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 * @example
                 *
                 * _.sortedLastIndexOf([1, 1, 2, 2], 2);
                 * // => 3
                 */
                function sortedLastIndexOf(array, value) {
                    var length = array ? array.length : 0;
                    if (length) {
                        var index = baseSortedIndex(array, value, true) - 1;
                        if (eq(array[index], value)) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * This method is like `_.uniq` except that it's designed and optimized
                 * for sorted arrays.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * _.sortedUniq([1, 1, 2]);
                 * // => [1, 2]
                 */
                function sortedUniq(array) {
                    return (array && array.length)
                        ? baseSortedUniq(array)
                        : [];
                }

                /**
                 * This method is like `_.uniqBy` except that it's designed and optimized
                 * for sorted arrays.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The iteratee invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
                 * // => [1.1, 2.3]
                 */
                function sortedUniqBy(array, iteratee) {
                    return (array && array.length)
                        ? baseSortedUniqBy(array, getIteratee(iteratee))
                        : [];
                }

                /**
                 * Gets all but the first element of `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.tail([1, 2, 3]);
                 * // => [2, 3]
                 */
                function tail(array) {
                    return drop(array, 1);
                }

                /**
                 * Creates a slice of `array` with `n` elements taken from the beginning.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=1] The number of elements to take.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.take([1, 2, 3]);
                 * // => [1]
                 *
                 * _.take([1, 2, 3], 2);
                 * // => [1, 2]
                 *
                 * _.take([1, 2, 3], 5);
                 * // => [1, 2, 3]
                 *
                 * _.take([1, 2, 3], 0);
                 * // => []
                 */
                function take(array, n, guard) {
                    if (!(array && array.length)) {
                        return [];
                    }
                    n = (guard || n === undefined) ? 1 : toInteger(n);
                    return baseSlice(array, 0, n < 0 ? 0 : n);
                }

                /**
                 * Creates a slice of `array` with `n` elements taken from the end.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {number} [n=1] The number of elements to take.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * _.takeRight([1, 2, 3]);
                 * // => [3]
                 *
                 * _.takeRight([1, 2, 3], 2);
                 * // => [2, 3]
                 *
                 * _.takeRight([1, 2, 3], 5);
                 * // => [1, 2, 3]
                 *
                 * _.takeRight([1, 2, 3], 0);
                 * // => []
                 */
                function takeRight(array, n, guard) {
                    var length = array ? array.length : 0;
                    if (!length) {
                        return [];
                    }
                    n = (guard || n === undefined) ? 1 : toInteger(n);
                    n = length - n;
                    return baseSlice(array, n < 0 ? 0 : n, length);
                }

                /**
                 * Creates a slice of `array` with elements taken from the end. Elements are
                 * taken until `predicate` returns falsey. The predicate is invoked with
                 * three arguments: (value, index, array).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': true },
                 *   { 'user': 'fred',    'active': false },
                 *   { 'user': 'pebbles', 'active': false }
                 * ];
                 *
                 * _.takeRightWhile(users, function(o) { return !o.active; });
                 * // => objects for ['fred', 'pebbles']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
                 * // => objects for ['pebbles']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.takeRightWhile(users, ['active', false]);
                 * // => objects for ['fred', 'pebbles']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.takeRightWhile(users, 'active');
                 * // => []
                 */
                function takeRightWhile(array, predicate) {
                    return (array && array.length)
                        ? baseWhile(array, getIteratee(predicate, 3), false, true)
                        : [];
                }

                /**
                 * Creates a slice of `array` with elements taken from the beginning. Elements
                 * are taken until `predicate` returns falsey. The predicate is invoked with
                 * three arguments: (value, index, array).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Array
                 * @param {Array} array The array to query.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the slice of `array`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'active': false },
                 *   { 'user': 'fred',    'active': false},
                 *   { 'user': 'pebbles', 'active': true }
                 * ];
                 *
                 * _.takeWhile(users, function(o) { return !o.active; });
                 * // => objects for ['barney', 'fred']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.takeWhile(users, { 'user': 'barney', 'active': false });
                 * // => objects for ['barney']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.takeWhile(users, ['active', false]);
                 * // => objects for ['barney', 'fred']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.takeWhile(users, 'active');
                 * // => []
                 */
                function takeWhile(array, predicate) {
                    return (array && array.length)
                        ? baseWhile(array, getIteratee(predicate, 3))
                        : [];
                }

                /**
                 * Creates an array of unique values, in order, from all given arrays using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @returns {Array} Returns the new array of combined values.
                 * @example
                 *
                 * _.union([2, 1], [4, 2], [1, 2]);
                 * // => [2, 1, 4]
                 */
                var union = rest(function(arrays) {
                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                });

                /**
                 * This method is like `_.union` except that it accepts `iteratee` which is
                 * invoked for each element of each `arrays` to generate the criterion by
                 * which uniqueness is computed. The iteratee is invoked with one argument:
                 * (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {Array} Returns the new array of combined values.
                 * @example
                 *
                 * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
                 * // => [2.1, 1.2, 4.3]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 1 }, { 'x': 2 }]
                 */
                var unionBy = rest(function(arrays) {
                    var iteratee = last(arrays);
                    if (isArrayLikeObject(iteratee)) {
                        iteratee = undefined;
                    }
                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee));
                });

                /**
                 * This method is like `_.union` except that it accepts `comparator` which
                 * is invoked to compare elements of `arrays`. The comparator is invoked
                 * with two arguments: (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of combined values.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                 *
                 * _.unionWith(objects, others, _.isEqual);
                 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
                 */
                var unionWith = rest(function(arrays) {
                    var comparator = last(arrays);
                    if (isArrayLikeObject(comparator)) {
                        comparator = undefined;
                    }
                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
                });

                /**
                 * Creates a duplicate-free version of an array, using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons, in which only the first occurrence of each
                 * element is kept.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * _.uniq([2, 1, 2]);
                 * // => [2, 1]
                 */
                function uniq(array) {
                    return (array && array.length)
                        ? baseUniq(array)
                        : [];
                }

                /**
                 * This method is like `_.uniq` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the criterion by which
                 * uniqueness is computed. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
                 * // => [2.1, 1.2]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 1 }, { 'x': 2 }]
                 */
                function uniqBy(array, iteratee) {
                    return (array && array.length)
                        ? baseUniq(array, getIteratee(iteratee))
                        : [];
                }

                /**
                 * This method is like `_.uniq` except that it accepts `comparator` which
                 * is invoked to compare elements of `array`. The comparator is invoked with
                 * two arguments: (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {Array} array The array to inspect.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new duplicate free array.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
                 *
                 * _.uniqWith(objects, _.isEqual);
                 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
                 */
                function uniqWith(array, comparator) {
                    return (array && array.length)
                        ? baseUniq(array, undefined, comparator)
                        : [];
                }

                /**
                 * This method is like `_.zip` except that it accepts an array of grouped
                 * elements and creates an array regrouping the elements to their pre-zip
                 * configuration.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.2.0
                 * @category Array
                 * @param {Array} array The array of grouped elements to process.
                 * @returns {Array} Returns the new array of regrouped elements.
                 * @example
                 *
                 * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
                 * // => [['fred', 30, true], ['barney', 40, false]]
                 *
                 * _.unzip(zipped);
                 * // => [['fred', 'barney'], [30, 40], [true, false]]
                 */
                function unzip(array) {
                    if (!(array && array.length)) {
                        return [];
                    }
                    var length = 0;
                    array = arrayFilter(array, function(group) {
                        if (isArrayLikeObject(group)) {
                            length = nativeMax(group.length, length);
                            return true;
                        }
                    });
                    return baseTimes(length, function(index) {
                        return arrayMap(array, baseProperty(index));
                    });
                }

                /**
                 * This method is like `_.unzip` except that it accepts `iteratee` to specify
                 * how regrouped values should be combined. The iteratee is invoked with the
                 * elements of each group: (...group).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.8.0
                 * @category Array
                 * @param {Array} array The array of grouped elements to process.
                 * @param {Function} [iteratee=_.identity] The function to combine
                 *  regrouped values.
                 * @returns {Array} Returns the new array of regrouped elements.
                 * @example
                 *
                 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
                 * // => [[1, 10, 100], [2, 20, 200]]
                 *
                 * _.unzipWith(zipped, _.add);
                 * // => [3, 30, 300]
                 */
                function unzipWith(array, iteratee) {
                    if (!(array && array.length)) {
                        return [];
                    }
                    var result = unzip(array);
                    if (iteratee == null) {
                        return result;
                    }
                    return arrayMap(result, function(group) {
                        return apply(iteratee, undefined, group);
                    });
                }

                /**
                 * Creates an array excluding all given values using
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * for equality comparisons.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {Array} array The array to filter.
                 * @param {...*} [values] The values to exclude.
                 * @returns {Array} Returns the new array of filtered values.
                 * @example
                 *
                 * _.without([1, 2, 1, 3], 1, 2);
                 * // => [3]
                 */
                var without = rest(function(array, values) {
                    return isArrayLikeObject(array)
                        ? baseDifference(array, values)
                        : [];
                });

                /**
                 * Creates an array of unique values that is the
                 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
                 * of the given arrays. The order of result values is determined by the order
                 * they occur in the arrays.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @returns {Array} Returns the new array of values.
                 * @example
                 *
                 * _.xor([2, 1], [4, 2]);
                 * // => [1, 4]
                 */
                var xor = rest(function(arrays) {
                    return baseXor(arrayFilter(arrays, isArrayLikeObject));
                });

                /**
                 * This method is like `_.xor` except that it accepts `iteratee` which is
                 * invoked for each element of each `arrays` to generate the criterion by
                 * which by which they're compared. The iteratee is invoked with one argument:
                 * (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {Array} Returns the new array of values.
                 * @example
                 *
                 * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
                 * // => [1.2, 4.3]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 2 }]
                 */
                var xorBy = rest(function(arrays) {
                    var iteratee = last(arrays);
                    if (isArrayLikeObject(iteratee)) {
                        iteratee = undefined;
                    }
                    return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));
                });

                /**
                 * This method is like `_.xor` except that it accepts `comparator` which is
                 * invoked to compare elements of `arrays`. The comparator is invoked with
                 * two arguments: (arrVal, othVal).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to inspect.
                 * @param {Function} [comparator] The comparator invoked per element.
                 * @returns {Array} Returns the new array of values.
                 * @example
                 *
                 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                 *
                 * _.xorWith(objects, others, _.isEqual);
                 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
                 */
                var xorWith = rest(function(arrays) {
                    var comparator = last(arrays);
                    if (isArrayLikeObject(comparator)) {
                        comparator = undefined;
                    }
                    return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
                });

                /**
                 * Creates an array of grouped elements, the first of which contains the
                 * first elements of the given arrays, the second of which contains the
                 * second elements of the given arrays, and so on.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to process.
                 * @returns {Array} Returns the new array of grouped elements.
                 * @example
                 *
                 * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                 * // => [['fred', 30, true], ['barney', 40, false]]
                 */
                var zip = rest(unzip);

                /**
                 * This method is like `_.fromPairs` except that it accepts two arrays,
                 * one of property identifiers and one of corresponding values.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.4.0
                 * @category Array
                 * @param {Array} [props=[]] The property identifiers.
                 * @param {Array} [values=[]] The property values.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * _.zipObject(['a', 'b'], [1, 2]);
                 * // => { 'a': 1, 'b': 2 }
                 */
                function zipObject(props, values) {
                    return baseZipObject(props || [], values || [], assignValue);
                }

                /**
                 * This method is like `_.zipObject` except that it supports property paths.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.1.0
                 * @category Array
                 * @param {Array} [props=[]] The property identifiers.
                 * @param {Array} [values=[]] The property values.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
                 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
                 */
                function zipObjectDeep(props, values) {
                    return baseZipObject(props || [], values || [], baseSet);
                }

                /**
                 * This method is like `_.zip` except that it accepts `iteratee` to specify
                 * how grouped values should be combined. The iteratee is invoked with the
                 * elements of each group: (...group).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.8.0
                 * @category Array
                 * @param {...Array} [arrays] The arrays to process.
                 * @param {Function} [iteratee=_.identity] The function to combine grouped values.
                 * @returns {Array} Returns the new array of grouped elements.
                 * @example
                 *
                 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
                 * // => [111, 222]
                 */
                var zipWith = rest(function(arrays) {
                    var length = arrays.length,
                        iteratee = length > 1 ? arrays[length - 1] : undefined;

                    iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
                    return unzipWith(arrays, iteratee);
                });

                /*------------------------------------------------------------------------*/

                /**
                 * Creates a `lodash` wrapper instance that wraps `value` with explicit method
                 * chain sequences enabled. The result of such sequences must be unwrapped
                 * with `_#value`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.3.0
                 * @category Seq
                 * @param {*} value The value to wrap.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'age': 36 },
                 *   { 'user': 'fred',    'age': 40 },
                 *   { 'user': 'pebbles', 'age': 1 }
                 * ];
                 *
                 * var youngest = _
                 *   .chain(users)
                 *   .sortBy('age')
                 *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
                 *   .head()
                 *   .value();
                 * // => 'pebbles is 1'
                 */
                function chain(value) {
                    var result = lodash(value);
                    result.__chain__ = true;
                    return result;
                }

                /**
                 * This method invokes `interceptor` and returns `value`. The interceptor
                 * is invoked with one argument; (value). The purpose of this method is to
                 * "tap into" a method chain sequence in order to modify intermediate results.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Seq
                 * @param {*} value The value to provide to `interceptor`.
                 * @param {Function} interceptor The function to invoke.
                 * @returns {*} Returns `value`.
                 * @example
                 *
                 * _([1, 2, 3])
                 *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
                 *  .reverse()
                 *  .value();
                 * // => [2, 1]
                 */
                function tap(value, interceptor) {
                    interceptor(value);
                    return value;
                }

                /**
                 * This method is like `_.tap` except that it returns the result of `interceptor`.
                 * The purpose of this method is to "pass thru" values replacing intermediate
                 * results in a method chain sequence.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Seq
                 * @param {*} value The value to provide to `interceptor`.
                 * @param {Function} interceptor The function to invoke.
                 * @returns {*} Returns the result of `interceptor`.
                 * @example
                 *
                 * _('  abc  ')
                 *  .chain()
                 *  .trim()
                 *  .thru(function(value) {
     *    return [value];
     *  })
                 *  .value();
                 * // => ['abc']
                 */
                function thru(value, interceptor) {
                    return interceptor(value);
                }

                /**
                 * This method is the wrapper version of `_.at`.
                 *
                 * @name at
                 * @memberOf _
                 * @since 1.0.0
                 * @category Seq
                 * @param {...(string|string[])} [paths] The property paths of elements to pick.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
                 *
                 * _(object).at(['a[0].b.c', 'a[1]']).value();
                 * // => [3, 4]
                 *
                 * _(['a', 'b', 'c']).at(0, 2).value();
                 * // => ['a', 'c']
                 */
                var wrapperAt = rest(function(paths) {
                    paths = baseFlatten(paths, 1);
                    var length = paths.length,
                        start = length ? paths[0] : 0,
                        value = this.__wrapped__,
                        interceptor = function(object) { return baseAt(object, paths); };

                    if (length > 1 || this.__actions__.length ||
                        !(value instanceof LazyWrapper) || !isIndex(start)) {
                        return this.thru(interceptor);
                    }
                    value = value.slice(start, +start + (length ? 1 : 0));
                    value.__actions__.push({
                        'func': thru,
                        'args': [interceptor],
                        'thisArg': undefined
                    });
                    return new LodashWrapper(value, this.__chain__).thru(function(array) {
                        if (length && !array.length) {
                            array.push(undefined);
                        }
                        return array;
                    });
                });

                /**
                 * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
                 *
                 * @name chain
                 * @memberOf _
                 * @since 0.1.0
                 * @category Seq
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36 },
                 *   { 'user': 'fred',   'age': 40 }
                 * ];
                 *
                 * // A sequence without explicit chaining.
                 * _(users).head();
                 * // => { 'user': 'barney', 'age': 36 }
                 *
                 * // A sequence with explicit chaining.
                 * _(users)
                 *   .chain()
                 *   .head()
                 *   .pick('user')
                 *   .value();
                 * // => { 'user': 'barney' }
                 */
                function wrapperChain() {
                    return chain(this);
                }

                /**
                 * Executes the chain sequence and returns the wrapped result.
                 *
                 * @name commit
                 * @memberOf _
                 * @since 3.2.0
                 * @category Seq
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var array = [1, 2];
                 * var wrapped = _(array).push(3);
                 *
                 * console.log(array);
                 * // => [1, 2]
                 *
                 * wrapped = wrapped.commit();
                 * console.log(array);
                 * // => [1, 2, 3]
                 *
                 * wrapped.last();
                 * // => 3
                 *
                 * console.log(array);
                 * // => [1, 2, 3]
                 */
                function wrapperCommit() {
                    return new LodashWrapper(this.value(), this.__chain__);
                }

                /**
                 * Gets the next value on a wrapped object following the
                 * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
                 *
                 * @name next
                 * @memberOf _
                 * @since 4.0.0
                 * @category Seq
                 * @returns {Object} Returns the next iterator value.
                 * @example
                 *
                 * var wrapped = _([1, 2]);
                 *
                 * wrapped.next();
                 * // => { 'done': false, 'value': 1 }
                 *
                 * wrapped.next();
                 * // => { 'done': false, 'value': 2 }
                 *
                 * wrapped.next();
                 * // => { 'done': true, 'value': undefined }
                 */
                function wrapperNext() {
                    if (this.__values__ === undefined) {
                        this.__values__ = toArray(this.value());
                    }
                    var done = this.__index__ >= this.__values__.length,
                        value = done ? undefined : this.__values__[this.__index__++];

                    return { 'done': done, 'value': value };
                }

                /**
                 * Enables the wrapper to be iterable.
                 *
                 * @name Symbol.iterator
                 * @memberOf _
                 * @since 4.0.0
                 * @category Seq
                 * @returns {Object} Returns the wrapper object.
                 * @example
                 *
                 * var wrapped = _([1, 2]);
                 *
                 * wrapped[Symbol.iterator]() === wrapped;
                 * // => true
                 *
                 * Array.from(wrapped);
                 * // => [1, 2]
                 */
                function wrapperToIterator() {
                    return this;
                }

                /**
                 * Creates a clone of the chain sequence planting `value` as the wrapped value.
                 *
                 * @name plant
                 * @memberOf _
                 * @since 3.2.0
                 * @category Seq
                 * @param {*} value The value to plant.
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * function square(n) {
     *   return n * n;
     * }
                 *
                 * var wrapped = _([1, 2]).map(square);
                 * var other = wrapped.plant([3, 4]);
                 *
                 * other.value();
                 * // => [9, 16]
                 *
                 * wrapped.value();
                 * // => [1, 4]
                 */
                function wrapperPlant(value) {
                    var result,
                        parent = this;

                    while (parent instanceof baseLodash) {
                        var clone = wrapperClone(parent);
                        clone.__index__ = 0;
                        clone.__values__ = undefined;
                        if (result) {
                            previous.__wrapped__ = clone;
                        } else {
                            result = clone;
                        }
                        var previous = clone;
                        parent = parent.__wrapped__;
                    }
                    previous.__wrapped__ = value;
                    return result;
                }

                /**
                 * This method is the wrapper version of `_.reverse`.
                 *
                 * **Note:** This method mutates the wrapped array.
                 *
                 * @name reverse
                 * @memberOf _
                 * @since 0.1.0
                 * @category Seq
                 * @returns {Object} Returns the new `lodash` wrapper instance.
                 * @example
                 *
                 * var array = [1, 2, 3];
                 *
                 * _(array).reverse().value()
                 * // => [3, 2, 1]
                 *
                 * console.log(array);
                 * // => [3, 2, 1]
                 */
                function wrapperReverse() {
                    var value = this.__wrapped__;
                    if (value instanceof LazyWrapper) {
                        var wrapped = value;
                        if (this.__actions__.length) {
                            wrapped = new LazyWrapper(this);
                        }
                        wrapped = wrapped.reverse();
                        wrapped.__actions__.push({
                            'func': thru,
                            'args': [reverse],
                            'thisArg': undefined
                        });
                        return new LodashWrapper(wrapped, this.__chain__);
                    }
                    return this.thru(reverse);
                }

                /**
                 * Executes the chain sequence to resolve the unwrapped value.
                 *
                 * @name value
                 * @memberOf _
                 * @since 0.1.0
                 * @alias toJSON, valueOf
                 * @category Seq
                 * @returns {*} Returns the resolved unwrapped value.
                 * @example
                 *
                 * _([1, 2, 3]).value();
                 * // => [1, 2, 3]
                 */
                function wrapperValue() {
                    return baseWrapperValue(this.__wrapped__, this.__actions__);
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Creates an object composed of keys generated from the results of running
                 * each element of `collection` thru `iteratee`. The corresponding value of
                 * each key is the number of times the key was returned by `iteratee`. The
                 * iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.5.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee to transform keys.
                 * @returns {Object} Returns the composed aggregate object.
                 * @example
                 *
                 * _.countBy([6.1, 4.2, 6.3], Math.floor);
                 * // => { '4': 1, '6': 2 }
                 *
                 * _.countBy(['one', 'two', 'three'], 'length');
                 * // => { '3': 2, '5': 1 }
                 */
                var countBy = createAggregator(function(result, value, key) {
                    hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
                });

                /**
                 * Checks if `predicate` returns truthy for **all** elements of `collection`.
                 * Iteration is stopped once `predicate` returns falsey. The predicate is
                 * invoked with three arguments: (value, index|key, collection).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {boolean} Returns `true` if all elements pass the predicate check,
                 *  else `false`.
                 * @example
                 *
                 * _.every([true, 1, null, 'yes'], Boolean);
                 * // => false
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': false },
                 *   { 'user': 'fred',   'age': 40, 'active': false }
                 * ];
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.every(users, { 'user': 'barney', 'active': false });
                 * // => false
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.every(users, ['active', false]);
                 * // => true
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.every(users, 'active');
                 * // => false
                 */
                function every(collection, predicate, guard) {
                    var func = isArray(collection) ? arrayEvery : baseEvery;
                    if (guard && isIterateeCall(collection, predicate, guard)) {
                        predicate = undefined;
                    }
                    return func(collection, getIteratee(predicate, 3));
                }

                /**
                 * Iterates over elements of `collection`, returning an array of all elements
                 * `predicate` returns truthy for. The predicate is invoked with three
                 * arguments: (value, index|key, collection).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the new filtered array.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': true },
                 *   { 'user': 'fred',   'age': 40, 'active': false }
                 * ];
                 *
                 * _.filter(users, function(o) { return !o.active; });
                 * // => objects for ['fred']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.filter(users, { 'age': 36, 'active': true });
                 * // => objects for ['barney']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.filter(users, ['active', false]);
                 * // => objects for ['fred']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.filter(users, 'active');
                 * // => objects for ['barney']
                 */
                function filter(collection, predicate) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    return func(collection, getIteratee(predicate, 3));
                }

                /**
                 * Iterates over elements of `collection`, returning the first element
                 * `predicate` returns truthy for. The predicate is invoked with three
                 * arguments: (value, index|key, collection).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to search.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {*} Returns the matched element, else `undefined`.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'age': 36, 'active': true },
                 *   { 'user': 'fred',    'age': 40, 'active': false },
                 *   { 'user': 'pebbles', 'age': 1,  'active': true }
                 * ];
                 *
                 * _.find(users, function(o) { return o.age < 40; });
                 * // => object for 'barney'
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.find(users, { 'age': 1, 'active': true });
                 * // => object for 'pebbles'
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.find(users, ['active', false]);
                 * // => object for 'fred'
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.find(users, 'active');
                 * // => object for 'barney'
                 */
                function find(collection, predicate) {
                    predicate = getIteratee(predicate, 3);
                    if (isArray(collection)) {
                        var index = baseFindIndex(collection, predicate);
                        return index > -1 ? collection[index] : undefined;
                    }
                    return baseFind(collection, predicate, baseEach);
                }

                /**
                 * This method is like `_.find` except that it iterates over elements of
                 * `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to search.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {*} Returns the matched element, else `undefined`.
                 * @example
                 *
                 * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
                 * // => 3
                 */
                function findLast(collection, predicate) {
                    predicate = getIteratee(predicate, 3);
                    if (isArray(collection)) {
                        var index = baseFindIndex(collection, predicate, true);
                        return index > -1 ? collection[index] : undefined;
                    }
                    return baseFind(collection, predicate, baseEachRight);
                }

                /**
                 * Creates a flattened array of values by running each element in `collection`
                 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
                 * with three arguments: (value, index|key, collection).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * function duplicate(n) {
     *   return [n, n];
     * }
                 *
                 * _.flatMap([1, 2], duplicate);
                 * // => [1, 1, 2, 2]
                 */
                function flatMap(collection, iteratee) {
                    return baseFlatten(map(collection, iteratee), 1);
                }

                /**
                 * This method is like `_.flatMap` except that it recursively flattens the
                 * mapped results.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * function duplicate(n) {
     *   return [[[n, n]]];
     * }
                 *
                 * _.flatMapDeep([1, 2], duplicate);
                 * // => [1, 1, 2, 2]
                 */
                function flatMapDeep(collection, iteratee) {
                    return baseFlatten(map(collection, iteratee), INFINITY);
                }

                /**
                 * This method is like `_.flatMap` except that it recursively flattens the
                 * mapped results up to `depth` times.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The function invoked per iteration.
                 * @param {number} [depth=1] The maximum recursion depth.
                 * @returns {Array} Returns the new flattened array.
                 * @example
                 *
                 * function duplicate(n) {
     *   return [[[n, n]]];
     * }
                 *
                 * _.flatMapDepth([1, 2], duplicate, 2);
                 * // => [[1, 1], [2, 2]]
                 */
                function flatMapDepth(collection, iteratee, depth) {
                    depth = depth === undefined ? 1 : toInteger(depth);
                    return baseFlatten(map(collection, iteratee), depth);
                }

                /**
                 * Iterates over elements of `collection` and invokes `iteratee` for each element.
                 * The iteratee is invoked with three arguments: (value, index|key, collection).
                 * Iteratee functions may exit iteration early by explicitly returning `false`.
                 *
                 * **Note:** As with other "Collections" methods, objects with a "length"
                 * property are iterated like arrays. To avoid this behavior use `_.forIn`
                 * or `_.forOwn` for object iteration.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @alias each
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 * @example
                 *
                 * _([1, 2]).forEach(function(value) {
     *   console.log(value);
     * });
                 * // => Logs `1` then `2`.
                 *
                 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
                 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                 */
                function forEach(collection, iteratee) {
                    return (typeof iteratee == 'function' && isArray(collection))
                        ? arrayEach(collection, iteratee)
                        : baseEach(collection, getIteratee(iteratee));
                }

                /**
                 * This method is like `_.forEach` except that it iterates over elements of
                 * `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @alias eachRight
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array|Object} Returns `collection`.
                 * @example
                 *
                 * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
                 * // => Logs `2` then `1`.
                 */
                function forEachRight(collection, iteratee) {
                    return (typeof iteratee == 'function' && isArray(collection))
                        ? arrayEachRight(collection, iteratee)
                        : baseEachRight(collection, getIteratee(iteratee));
                }

                /**
                 * Creates an object composed of keys generated from the results of running
                 * each element of `collection` thru `iteratee`. The order of grouped values
                 * is determined by the order they occur in `collection`. The corresponding
                 * value of each key is an array of elements responsible for generating the
                 * key. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee to transform keys.
                 * @returns {Object} Returns the composed aggregate object.
                 * @example
                 *
                 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
                 * // => { '4': [4.2], '6': [6.1, 6.3] }
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.groupBy(['one', 'two', 'three'], 'length');
                 * // => { '3': ['one', 'two'], '5': ['three'] }
                 */
                var groupBy = createAggregator(function(result, value, key) {
                    if (hasOwnProperty.call(result, key)) {
                        result[key].push(value);
                    } else {
                        result[key] = [value];
                    }
                });

                /**
                 * Checks if `value` is in `collection`. If `collection` is a string, it's
                 * checked for a substring of `value`, otherwise
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * is used for equality comparisons. If `fromIndex` is negative, it's used as
                 * the offset from the end of `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object|string} collection The collection to search.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
                 * @returns {boolean} Returns `true` if `value` is found, else `false`.
                 * @example
                 *
                 * _.includes([1, 2, 3], 1);
                 * // => true
                 *
                 * _.includes([1, 2, 3], 1, 2);
                 * // => false
                 *
                 * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
                 * // => true
                 *
                 * _.includes('pebbles', 'eb');
                 * // => true
                 */
                function includes(collection, value, fromIndex, guard) {
                    collection = isArrayLike(collection) ? collection : values(collection);
                    fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

                    var length = collection.length;
                    if (fromIndex < 0) {
                        fromIndex = nativeMax(length + fromIndex, 0);
                    }
                    return isString(collection)
                        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
                        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
                }

                /**
                 * Invokes the method at `path` of each element in `collection`, returning
                 * an array of the results of each invoked method. Any additional arguments
                 * are provided to each invoked method. If `methodName` is a function, it's
                 * invoked for and `this` bound to, each element in `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|string} path The path of the method to invoke or
                 *  the function invoked per iteration.
                 * @param {...*} [args] The arguments to invoke each method with.
                 * @returns {Array} Returns the array of results.
                 * @example
                 *
                 * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
                 * // => [[1, 5, 7], [1, 2, 3]]
                 *
                 * _.invokeMap([123, 456], String.prototype.split, '');
                 * // => [['1', '2', '3'], ['4', '5', '6']]
                 */
                var invokeMap = rest(function(collection, path, args) {
                    var index = -1,
                        isFunc = typeof path == 'function',
                        isProp = isKey(path),
                        result = isArrayLike(collection) ? Array(collection.length) : [];

                    baseEach(collection, function(value) {
                        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
                        result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
                    });
                    return result;
                });

                /**
                 * Creates an object composed of keys generated from the results of running
                 * each element of `collection` thru `iteratee`. The corresponding value of
                 * each key is the last element responsible for generating the key. The
                 * iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee to transform keys.
                 * @returns {Object} Returns the composed aggregate object.
                 * @example
                 *
                 * var array = [
                 *   { 'dir': 'left', 'code': 97 },
                 *   { 'dir': 'right', 'code': 100 }
                 * ];
                 *
                 * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
                 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                 *
                 * _.keyBy(array, 'dir');
                 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                 */
                var keyBy = createAggregator(function(result, value, key) {
                    result[key] = value;
                });

                /**
                 * Creates an array of values by running each element in `collection` thru
                 * `iteratee`. The iteratee is invoked with three arguments:
                 * (value, index|key, collection).
                 *
                 * Many lodash methods are guarded to work as iteratees for methods like
                 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                 *
                 * The guarded methods are:
                 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
                 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
                 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
                 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the new mapped array.
                 * @example
                 *
                 * function square(n) {
     *   return n * n;
     * }
                 *
                 * _.map([4, 8], square);
                 * // => [16, 64]
                 *
                 * _.map({ 'a': 4, 'b': 8 }, square);
                 * // => [16, 64] (iteration order is not guaranteed)
                 *
                 * var users = [
                 *   { 'user': 'barney' },
                 *   { 'user': 'fred' }
                 * ];
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.map(users, 'user');
                 * // => ['barney', 'fred']
                 */
                function map(collection, iteratee) {
                    var func = isArray(collection) ? arrayMap : baseMap;
                    return func(collection, getIteratee(iteratee, 3));
                }

                /**
                 * This method is like `_.sortBy` except that it allows specifying the sort
                 * orders of the iteratees to sort by. If `orders` is unspecified, all values
                 * are sorted in ascending order. Otherwise, specify an order of "desc" for
                 * descending or "asc" for ascending sort order of corresponding values.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
                 *  The iteratees to sort by.
                 * @param {string[]} [orders] The sort orders of `iteratees`.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
                 * @returns {Array} Returns the new sorted array.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'fred',   'age': 48 },
                 *   { 'user': 'barney', 'age': 34 },
                 *   { 'user': 'fred',   'age': 40 },
                 *   { 'user': 'barney', 'age': 36 }
                 * ];
                 *
                 * // Sort by `user` in ascending order and by `age` in descending order.
                 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
                 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
                 */
                function orderBy(collection, iteratees, orders, guard) {
                    if (collection == null) {
                        return [];
                    }
                    if (!isArray(iteratees)) {
                        iteratees = iteratees == null ? [] : [iteratees];
                    }
                    orders = guard ? undefined : orders;
                    if (!isArray(orders)) {
                        orders = orders == null ? [] : [orders];
                    }
                    return baseOrderBy(collection, iteratees, orders);
                }

                /**
                 * Creates an array of elements split into two groups, the first of which
                 * contains elements `predicate` returns truthy for, the second of which
                 * contains elements `predicate` returns falsey for. The predicate is
                 * invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the array of grouped elements.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney',  'age': 36, 'active': false },
                 *   { 'user': 'fred',    'age': 40, 'active': true },
                 *   { 'user': 'pebbles', 'age': 1,  'active': false }
                 * ];
                 *
                 * _.partition(users, function(o) { return o.active; });
                 * // => objects for [['fred'], ['barney', 'pebbles']]
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.partition(users, { 'age': 1, 'active': false });
                 * // => objects for [['pebbles'], ['barney', 'fred']]
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.partition(users, ['active', false]);
                 * // => objects for [['barney', 'pebbles'], ['fred']]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.partition(users, 'active');
                 * // => objects for [['fred'], ['barney', 'pebbles']]
                 */
                var partition = createAggregator(function(result, value, key) {
                    result[key ? 0 : 1].push(value);
                }, function() { return [[], []]; });

                /**
                 * Reduces `collection` to a value which is the accumulated result of running
                 * each element in `collection` thru `iteratee`, where each successive
                 * invocation is supplied the return value of the previous. If `accumulator`
                 * is not given, the first element of `collection` is used as the initial
                 * value. The iteratee is invoked with four arguments:
                 * (accumulator, value, index|key, collection).
                 *
                 * Many lodash methods are guarded to work as iteratees for methods like
                 * `_.reduce`, `_.reduceRight`, and `_.transform`.
                 *
                 * The guarded methods are:
                 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
                 * and `sortBy`
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @param {*} [accumulator] The initial value.
                 * @returns {*} Returns the accumulated value.
                 * @example
                 *
                 * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
                 * // => 3
                 *
                 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
                 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
                 */
                function reduce(collection, iteratee, accumulator) {
                    var func = isArray(collection) ? arrayReduce : baseReduce,
                        initAccum = arguments.length < 3;

                    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
                }

                /**
                 * This method is like `_.reduce` except that it iterates over elements of
                 * `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @param {*} [accumulator] The initial value.
                 * @returns {*} Returns the accumulated value.
                 * @example
                 *
                 * var array = [[0, 1], [2, 3], [4, 5]];
                 *
                 * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
                 * // => [4, 5, 2, 3, 0, 1]
                 */
                function reduceRight(collection, iteratee, accumulator) {
                    var func = isArray(collection) ? arrayReduceRight : baseReduce,
                        initAccum = arguments.length < 3;

                    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
                }

                /**
                 * The opposite of `_.filter`; this method returns the elements of `collection`
                 * that `predicate` does **not** return truthy for.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Array} Returns the new filtered array.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': false },
                 *   { 'user': 'fred',   'age': 40, 'active': true }
                 * ];
                 *
                 * _.reject(users, function(o) { return !o.active; });
                 * // => objects for ['fred']
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.reject(users, { 'age': 40, 'active': true });
                 * // => objects for ['barney']
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.reject(users, ['active', false]);
                 * // => objects for ['fred']
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.reject(users, 'active');
                 * // => objects for ['barney']
                 */
                function reject(collection, predicate) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    predicate = getIteratee(predicate, 3);
                    return func(collection, function(value, index, collection) {
                        return !predicate(value, index, collection);
                    });
                }

                /**
                 * Gets a random element from `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to sample.
                 * @returns {*} Returns the random element.
                 * @example
                 *
                 * _.sample([1, 2, 3, 4]);
                 * // => 2
                 */
                function sample(collection) {
                    var array = isArrayLike(collection) ? collection : values(collection),
                        length = array.length;

                    return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
                }

                /**
                 * Gets `n` random elements at unique keys from `collection` up to the
                 * size of `collection`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to sample.
                 * @param {number} [n=1] The number of elements to sample.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the random elements.
                 * @example
                 *
                 * _.sampleSize([1, 2, 3], 2);
                 * // => [3, 1]
                 *
                 * _.sampleSize([1, 2, 3], 4);
                 * // => [2, 3, 1]
                 */
                function sampleSize(collection, n, guard) {
                    var index = -1,
                        result = toArray(collection),
                        length = result.length,
                        lastIndex = length - 1;

                    if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
                        n = 1;
                    } else {
                        n = baseClamp(toInteger(n), 0, length);
                    }
                    while (++index < n) {
                        var rand = baseRandom(index, lastIndex),
                            value = result[rand];

                        result[rand] = result[index];
                        result[index] = value;
                    }
                    result.length = n;
                    return result;
                }

                /**
                 * Creates an array of shuffled values, using a version of the
                 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to shuffle.
                 * @returns {Array} Returns the new shuffled array.
                 * @example
                 *
                 * _.shuffle([1, 2, 3, 4]);
                 * // => [4, 1, 3, 2]
                 */
                function shuffle(collection) {
                    return sampleSize(collection, MAX_ARRAY_LENGTH);
                }

                /**
                 * Gets the size of `collection` by returning its length for array-like
                 * values or the number of own enumerable string keyed properties for objects.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to inspect.
                 * @returns {number} Returns the collection size.
                 * @example
                 *
                 * _.size([1, 2, 3]);
                 * // => 3
                 *
                 * _.size({ 'a': 1, 'b': 2 });
                 * // => 2
                 *
                 * _.size('pebbles');
                 * // => 7
                 */
                function size(collection) {
                    if (collection == null) {
                        return 0;
                    }
                    if (isArrayLike(collection)) {
                        var result = collection.length;
                        return (result && isString(collection)) ? stringSize(collection) : result;
                    }
                    if (isObjectLike(collection)) {
                        var tag = getTag(collection);
                        if (tag == mapTag || tag == setTag) {
                            return collection.size;
                        }
                    }
                    return keys(collection).length;
                }

                /**
                 * Checks if `predicate` returns truthy for **any** element of `collection`.
                 * Iteration is stopped once `predicate` returns truthy. The predicate is
                 * invoked with three arguments: (value, index|key, collection).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {boolean} Returns `true` if any element passes the predicate check,
                 *  else `false`.
                 * @example
                 *
                 * _.some([null, 0, 'yes', false], Boolean);
                 * // => true
                 *
                 * var users = [
                 *   { 'user': 'barney', 'active': true },
                 *   { 'user': 'fred',   'active': false }
                 * ];
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.some(users, { 'user': 'barney', 'active': false });
                 * // => false
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.some(users, ['active', false]);
                 * // => true
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.some(users, 'active');
                 * // => true
                 */
                function some(collection, predicate, guard) {
                    var func = isArray(collection) ? arraySome : baseSome;
                    if (guard && isIterateeCall(collection, predicate, guard)) {
                        predicate = undefined;
                    }
                    return func(collection, getIteratee(predicate, 3));
                }

                /**
                 * Creates an array of elements, sorted in ascending order by the results of
                 * running each element in a collection thru each iteratee. This method
                 * performs a stable sort, that is, it preserves the original sort order of
                 * equal elements. The iteratees are invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Collection
                 * @param {Array|Object} collection The collection to iterate over.
                 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
                 *  [iteratees=[_.identity]] The iteratees to sort by.
                 * @returns {Array} Returns the new sorted array.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'fred',   'age': 48 },
                 *   { 'user': 'barney', 'age': 36 },
                 *   { 'user': 'fred',   'age': 40 },
                 *   { 'user': 'barney', 'age': 34 }
                 * ];
                 *
                 * _.sortBy(users, function(o) { return o.user; });
                 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
                 *
                 * _.sortBy(users, ['user', 'age']);
                 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
                 *
                 * _.sortBy(users, 'user', function(o) {
     *   return Math.floor(o.age / 10);
     * });
                 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
                 */
                var sortBy = rest(function(collection, iteratees) {
                    if (collection == null) {
                        return [];
                    }
                    var length = iteratees.length;
                    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                        iteratees = [];
                    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                        iteratees = [iteratees[0]];
                    }
                    iteratees = (iteratees.length == 1 && isArray(iteratees[0]))
                        ? iteratees[0]
                        : baseFlatten(iteratees, 1, isFlattenableIteratee);

                    return baseOrderBy(collection, iteratees, []);
                });

                /*------------------------------------------------------------------------*/

                /**
                 * Gets the timestamp of the number of milliseconds that have elapsed since
                 * the Unix epoch (1 January 1970 00:00:00 UTC).
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @type {Function}
                 * @category Date
                 * @returns {number} Returns the timestamp.
                 * @example
                 *
                 * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
                 * // => Logs the number of milliseconds it took for the deferred function to be invoked.
                 */
                var now = Date.now;

                /*------------------------------------------------------------------------*/

                /**
                 * The opposite of `_.before`; this method creates a function that invokes
                 * `func` once it's called `n` or more times.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {number} n The number of calls before `func` is invoked.
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new restricted function.
                 * @example
                 *
                 * var saves = ['profile', 'settings'];
                 *
                 * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
                 *
                 * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
                 * // => Logs 'done saving!' after the two async saves have completed.
                 */
                function after(n, func) {
                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    n = toInteger(n);
                    return function() {
                        if (--n < 1) {
                            return func.apply(this, arguments);
                        }
                    };
                }

                /**
                 * Creates a function that invokes `func`, with up to `n` arguments,
                 * ignoring any additional arguments.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {Function} func The function to cap arguments for.
                 * @param {number} [n=func.length] The arity cap.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
                 * // => [6, 8, 10]
                 */
                function ary(func, n, guard) {
                    n = guard ? undefined : n;
                    n = (func && n == null) ? func.length : n;
                    return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
                }

                /**
                 * Creates a function that invokes `func`, with the `this` binding and arguments
                 * of the created function, while it's called less than `n` times. Subsequent
                 * calls to the created function return the result of the last `func` invocation.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {number} n The number of calls at which `func` is no longer invoked.
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new restricted function.
                 * @example
                 *
                 * jQuery(element).on('click', _.before(5, addContactToList));
                 * // => allows adding up to 4 contacts to the list
                 */
                function before(n, func) {
                    var result;
                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    n = toInteger(n);
                    return function() {
                        if (--n > 0) {
                            result = func.apply(this, arguments);
                        }
                        if (n <= 1) {
                            func = undefined;
                        }
                        return result;
                    };
                }

                /**
                 * Creates a function that invokes `func` with the `this` binding of `thisArg`
                 * and `partials` prepended to the arguments it receives.
                 *
                 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                 * may be used as a placeholder for partially applied arguments.
                 *
                 * **Note:** Unlike native `Function#bind` this method doesn't set the "length"
                 * property of bound functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to bind.
                 * @param {*} thisArg The `this` binding of `func`.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new bound function.
                 * @example
                 *
                 * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
                 *
                 * var object = { 'user': 'fred' };
                 *
                 * var bound = _.bind(greet, object, 'hi');
                 * bound('!');
                 * // => 'hi fred!'
                 *
                 * // Bound with placeholders.
                 * var bound = _.bind(greet, object, _, '!');
                 * bound('hi');
                 * // => 'hi fred!'
                 */
                var bind = rest(function(func, thisArg, partials) {
                    var bitmask = BIND_FLAG;
                    if (partials.length) {
                        var holders = replaceHolders(partials, getPlaceholder(bind));
                        bitmask |= PARTIAL_FLAG;
                    }
                    return createWrapper(func, bitmask, thisArg, partials, holders);
                });

                /**
                 * Creates a function that invokes the method at `object[key]` with `partials`
                 * prepended to the arguments it receives.
                 *
                 * This method differs from `_.bind` by allowing bound functions to reference
                 * methods that may be redefined or don't yet exist. See
                 * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
                 * for more details.
                 *
                 * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
                 * builds, may be used as a placeholder for partially applied arguments.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.10.0
                 * @category Function
                 * @param {Object} object The object to invoke the method on.
                 * @param {string} key The key of the method.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new bound function.
                 * @example
                 *
                 * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
                 *
                 * var bound = _.bindKey(object, 'greet', 'hi');
                 * bound('!');
                 * // => 'hi fred!'
                 *
                 * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
                 *
                 * bound('!');
                 * // => 'hiya fred!'
                 *
                 * // Bound with placeholders.
                 * var bound = _.bindKey(object, 'greet', _, '!');
                 * bound('hi');
                 * // => 'hiya fred!'
                 */
                var bindKey = rest(function(object, key, partials) {
                    var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                    if (partials.length) {
                        var holders = replaceHolders(partials, getPlaceholder(bindKey));
                        bitmask |= PARTIAL_FLAG;
                    }
                    return createWrapper(key, bitmask, object, partials, holders);
                });

                /**
                 * Creates a function that accepts arguments of `func` and either invokes
                 * `func` returning its result, if at least `arity` number of arguments have
                 * been provided, or returns a function that accepts the remaining `func`
                 * arguments, and so on. The arity of `func` may be specified if `func.length`
                 * is not sufficient.
                 *
                 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
                 * may be used as a placeholder for provided arguments.
                 *
                 * **Note:** This method doesn't set the "length" property of curried functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Function
                 * @param {Function} func The function to curry.
                 * @param {number} [arity=func.length] The arity of `func`.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Function} Returns the new curried function.
                 * @example
                 *
                 * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
                 *
                 * var curried = _.curry(abc);
                 *
                 * curried(1)(2)(3);
                 * // => [1, 2, 3]
                 *
                 * curried(1, 2)(3);
                 * // => [1, 2, 3]
                 *
                 * curried(1, 2, 3);
                 * // => [1, 2, 3]
                 *
                 * // Curried with placeholders.
                 * curried(1)(_, 3)(2);
                 * // => [1, 2, 3]
                 */
                function curry(func, arity, guard) {
                    arity = guard ? undefined : arity;
                    var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                    result.placeholder = curry.placeholder;
                    return result;
                }

                /**
                 * This method is like `_.curry` except that arguments are applied to `func`
                 * in the manner of `_.partialRight` instead of `_.partial`.
                 *
                 * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
                 * builds, may be used as a placeholder for provided arguments.
                 *
                 * **Note:** This method doesn't set the "length" property of curried functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {Function} func The function to curry.
                 * @param {number} [arity=func.length] The arity of `func`.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Function} Returns the new curried function.
                 * @example
                 *
                 * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
                 *
                 * var curried = _.curryRight(abc);
                 *
                 * curried(3)(2)(1);
                 * // => [1, 2, 3]
                 *
                 * curried(2, 3)(1);
                 * // => [1, 2, 3]
                 *
                 * curried(1, 2, 3);
                 * // => [1, 2, 3]
                 *
                 * // Curried with placeholders.
                 * curried(3)(1, _)(2);
                 * // => [1, 2, 3]
                 */
                function curryRight(func, arity, guard) {
                    arity = guard ? undefined : arity;
                    var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                    result.placeholder = curryRight.placeholder;
                    return result;
                }

                /**
                 * Creates a debounced function that delays invoking `func` until after `wait`
                 * milliseconds have elapsed since the last time the debounced function was
                 * invoked. The debounced function comes with a `cancel` method to cancel
                 * delayed `func` invocations and a `flush` method to immediately invoke them.
                 * Provide an options object to indicate whether `func` should be invoked on
                 * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
                 * with the last arguments provided to the debounced function. Subsequent calls
                 * to the debounced function return the result of the last `func` invocation.
                 *
                 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                 * on the trailing edge of the timeout only if the debounced function is
                 * invoked more than once during the `wait` timeout.
                 *
                 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
                 * for details over the differences between `_.debounce` and `_.throttle`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to debounce.
                 * @param {number} [wait=0] The number of milliseconds to delay.
                 * @param {Object} [options={}] The options object.
                 * @param {boolean} [options.leading=false]
                 *  Specify invoking on the leading edge of the timeout.
                 * @param {number} [options.maxWait]
                 *  The maximum time `func` is allowed to be delayed before it's invoked.
                 * @param {boolean} [options.trailing=true]
                 *  Specify invoking on the trailing edge of the timeout.
                 * @returns {Function} Returns the new debounced function.
                 * @example
                 *
                 * // Avoid costly calculations while the window size is in flux.
                 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
                 *
                 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
                 * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
                 *
                 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
                 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
                 * var source = new EventSource('/stream');
                 * jQuery(source).on('message', debounced);
                 *
                 * // Cancel the trailing debounced invocation.
                 * jQuery(window).on('popstate', debounced.cancel);
                 */
                function debounce(func, wait, options) {
                    var lastArgs,
                        lastThis,
                        maxWait,
                        result,
                        timerId,
                        lastCallTime = 0,
                        lastInvokeTime = 0,
                        leading = false,
                        maxing = false,
                        trailing = true;

                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    wait = toNumber(wait) || 0;
                    if (isObject(options)) {
                        leading = !!options.leading;
                        maxing = 'maxWait' in options;
                        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                        trailing = 'trailing' in options ? !!options.trailing : trailing;
                    }

                    function invokeFunc(time) {
                        var args = lastArgs,
                            thisArg = lastThis;

                        lastArgs = lastThis = undefined;
                        lastInvokeTime = time;
                        result = func.apply(thisArg, args);
                        return result;
                    }

                    function leadingEdge(time) {
                        // Reset any `maxWait` timer.
                        lastInvokeTime = time;
                        // Start the timer for the trailing edge.
                        timerId = setTimeout(timerExpired, wait);
                        // Invoke the leading edge.
                        return leading ? invokeFunc(time) : result;
                    }

                    function remainingWait(time) {
                        var timeSinceLastCall = time - lastCallTime,
                            timeSinceLastInvoke = time - lastInvokeTime,
                            result = wait - timeSinceLastCall;

                        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                    }

                    function shouldInvoke(time) {
                        var timeSinceLastCall = time - lastCallTime,
                            timeSinceLastInvoke = time - lastInvokeTime;

                        // Either this is the first call, activity has stopped and we're at the
                        // trailing edge, the system time has gone backwards and we're treating
                        // it as the trailing edge, or we've hit the `maxWait` limit.
                        return (!lastCallTime || (timeSinceLastCall >= wait) ||
                        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
                    }

                    function timerExpired() {
                        var time = now();
                        if (shouldInvoke(time)) {
                            return trailingEdge(time);
                        }
                        // Restart the timer.
                        timerId = setTimeout(timerExpired, remainingWait(time));
                    }

                    function trailingEdge(time) {
                        clearTimeout(timerId);
                        timerId = undefined;

                        // Only invoke if we have `lastArgs` which means `func` has been
                        // debounced at least once.
                        if (trailing && lastArgs) {
                            return invokeFunc(time);
                        }
                        lastArgs = lastThis = undefined;
                        return result;
                    }

                    function cancel() {
                        if (timerId !== undefined) {
                            clearTimeout(timerId);
                        }
                        lastCallTime = lastInvokeTime = 0;
                        lastArgs = lastThis = timerId = undefined;
                    }

                    function flush() {
                        return timerId === undefined ? result : trailingEdge(now());
                    }

                    function debounced() {
                        var time = now(),
                            isInvoking = shouldInvoke(time);

                        lastArgs = arguments;
                        lastThis = this;
                        lastCallTime = time;

                        if (isInvoking) {
                            if (timerId === undefined) {
                                return leadingEdge(lastCallTime);
                            }
                            if (maxing) {
                                // Handle invocations in a tight loop.
                                clearTimeout(timerId);
                                timerId = setTimeout(timerExpired, wait);
                                return invokeFunc(lastCallTime);
                            }
                        }
                        if (timerId === undefined) {
                            timerId = setTimeout(timerExpired, wait);
                        }
                        return result;
                    }
                    debounced.cancel = cancel;
                    debounced.flush = flush;
                    return debounced;
                }

                /**
                 * Defers invoking the `func` until the current call stack has cleared. Any
                 * additional arguments are provided to `func` when it's invoked.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to defer.
                 * @param {...*} [args] The arguments to invoke `func` with.
                 * @returns {number} Returns the timer id.
                 * @example
                 *
                 * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
                 * // => Logs 'deferred' after one or more milliseconds.
                 */
                var defer = rest(function(func, args) {
                    return baseDelay(func, 1, args);
                });

                /**
                 * Invokes `func` after `wait` milliseconds. Any additional arguments are
                 * provided to `func` when it's invoked.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to delay.
                 * @param {number} wait The number of milliseconds to delay invocation.
                 * @param {...*} [args] The arguments to invoke `func` with.
                 * @returns {number} Returns the timer id.
                 * @example
                 *
                 * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
                 * // => Logs 'later' after one second.
                 */
                var delay = rest(function(func, wait, args) {
                    return baseDelay(func, toNumber(wait) || 0, args);
                });

                /**
                 * Creates a function that invokes `func` with arguments reversed.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Function
                 * @param {Function} func The function to flip arguments for.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
                 *
                 * flipped('a', 'b', 'c', 'd');
                 * // => ['d', 'c', 'b', 'a']
                 */
                function flip(func) {
                    return createWrapper(func, FLIP_FLAG);
                }

                /**
                 * Creates a function that memoizes the result of `func`. If `resolver` is
                 * provided, it determines the cache key for storing the result based on the
                 * arguments provided to the memoized function. By default, the first argument
                 * provided to the memoized function is used as the map cache key. The `func`
                 * is invoked with the `this` binding of the memoized function.
                 *
                 * **Note:** The cache is exposed as the `cache` property on the memoized
                 * function. Its creation may be customized by replacing the `_.memoize.Cache`
                 * constructor with one whose instances implement the
                 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
                 * method interface of `delete`, `get`, `has`, and `set`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to have its output memoized.
                 * @param {Function} [resolver] The function to resolve the cache key.
                 * @returns {Function} Returns the new memoizing function.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2 };
                 * var other = { 'c': 3, 'd': 4 };
                 *
                 * var values = _.memoize(_.values);
                 * values(object);
                 * // => [1, 2]
                 *
                 * values(other);
                 * // => [3, 4]
                 *
                 * object.a = 2;
                 * values(object);
                 * // => [1, 2]
                 *
                 * // Modify the result cache.
                 * values.cache.set(object, ['a', 'b']);
                 * values(object);
                 * // => ['a', 'b']
                 *
                 * // Replace `_.memoize.Cache`.
                 * _.memoize.Cache = WeakMap;
                 */
                function memoize(func, resolver) {
                    if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    var memoized = function() {
                        var args = arguments,
                            key = resolver ? resolver.apply(this, args) : args[0],
                            cache = memoized.cache;

                        if (cache.has(key)) {
                            return cache.get(key);
                        }
                        var result = func.apply(this, args);
                        memoized.cache = cache.set(key, result);
                        return result;
                    };
                    memoized.cache = new (memoize.Cache || MapCache);
                    return memoized;
                }

                // Assign cache to `_.memoize`.
                memoize.Cache = MapCache;

                /**
                 * Creates a function that negates the result of the predicate `func`. The
                 * `func` predicate is invoked with the `this` binding and arguments of the
                 * created function.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {Function} predicate The predicate to negate.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * function isEven(n) {
     *   return n % 2 == 0;
     * }
                 *
                 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
                 * // => [1, 3, 5]
                 */
                function negate(predicate) {
                    if (typeof predicate != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    return function() {
                        return !predicate.apply(this, arguments);
                    };
                }

                /**
                 * Creates a function that is restricted to invoking `func` once. Repeat calls
                 * to the function return the value of the first invocation. The `func` is
                 * invoked with the `this` binding and arguments of the created function.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new restricted function.
                 * @example
                 *
                 * var initialize = _.once(createApplication);
                 * initialize();
                 * initialize();
                 * // `initialize` invokes `createApplication` once
                 */
                function once(func) {
                    return before(2, func);
                }

                /**
                 * Creates a function that invokes `func` with arguments transformed by
                 * corresponding `transforms`.
                 *
                 * @static
                 * @since 4.0.0
                 * @memberOf _
                 * @category Function
                 * @param {Function} func The function to wrap.
                 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
                 *  [transforms[_.identity]] The functions to transform.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * function doubled(n) {
     *   return n * 2;
     * }
                 *
                 * function square(n) {
     *   return n * n;
     * }
                 *
                 * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
                 *
                 * func(9, 3);
                 * // => [81, 6]
                 *
                 * func(10, 5);
                 * // => [100, 10]
                 */
                var overArgs = rest(function(func, transforms) {
                    transforms = (transforms.length == 1 && isArray(transforms[0]))
                        ? arrayMap(transforms[0], baseUnary(getIteratee()))
                        : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee), baseUnary(getIteratee()));

                    var funcsLength = transforms.length;
                    return rest(function(args) {
                        var index = -1,
                            length = nativeMin(args.length, funcsLength);

                        while (++index < length) {
                            args[index] = transforms[index].call(this, args[index]);
                        }
                        return apply(func, this, args);
                    });
                });

                /**
                 * Creates a function that invokes `func` with `partials` prepended to the
                 * arguments it receives. This method is like `_.bind` except it does **not**
                 * alter the `this` binding.
                 *
                 * The `_.partial.placeholder` value, which defaults to `_` in monolithic
                 * builds, may be used as a placeholder for partially applied arguments.
                 *
                 * **Note:** This method doesn't set the "length" property of partially
                 * applied functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.2.0
                 * @category Function
                 * @param {Function} func The function to partially apply arguments to.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new partially applied function.
                 * @example
                 *
                 * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
                 *
                 * var sayHelloTo = _.partial(greet, 'hello');
                 * sayHelloTo('fred');
                 * // => 'hello fred'
                 *
                 * // Partially applied with placeholders.
                 * var greetFred = _.partial(greet, _, 'fred');
                 * greetFred('hi');
                 * // => 'hi fred'
                 */
                var partial = rest(function(func, partials) {
                    var holders = replaceHolders(partials, getPlaceholder(partial));
                    return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);
                });

                /**
                 * This method is like `_.partial` except that partially applied arguments
                 * are appended to the arguments it receives.
                 *
                 * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
                 * builds, may be used as a placeholder for partially applied arguments.
                 *
                 * **Note:** This method doesn't set the "length" property of partially
                 * applied functions.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.0.0
                 * @category Function
                 * @param {Function} func The function to partially apply arguments to.
                 * @param {...*} [partials] The arguments to be partially applied.
                 * @returns {Function} Returns the new partially applied function.
                 * @example
                 *
                 * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
                 *
                 * var greetFred = _.partialRight(greet, 'fred');
                 * greetFred('hi');
                 * // => 'hi fred'
                 *
                 * // Partially applied with placeholders.
                 * var sayHelloTo = _.partialRight(greet, 'hello', _);
                 * sayHelloTo('fred');
                 * // => 'hello fred'
                 */
                var partialRight = rest(function(func, partials) {
                    var holders = replaceHolders(partials, getPlaceholder(partialRight));
                    return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
                });

                /**
                 * Creates a function that invokes `func` with arguments arranged according
                 * to the specified `indexes` where the argument value at the first index is
                 * provided as the first argument, the argument value at the second index is
                 * provided as the second argument, and so on.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Function
                 * @param {Function} func The function to rearrange arguments for.
                 * @param {...(number|number[])} indexes The arranged argument indexes.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
                 *
                 * rearged('b', 'c', 'a')
                 * // => ['a', 'b', 'c']
                 */
                var rearg = rest(function(func, indexes) {
                    return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
                });

                /**
                 * Creates a function that invokes `func` with the `this` binding of the
                 * created function and arguments from `start` and beyond provided as
                 * an array.
                 *
                 * **Note:** This method is based on the
                 * [rest parameter](https://mdn.io/rest_parameters).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Function
                 * @param {Function} func The function to apply a rest parameter to.
                 * @param {number} [start=func.length-1] The start position of the rest parameter.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
                 *
                 * say('hello', 'fred', 'barney', 'pebbles');
                 * // => 'hello fred, barney, & pebbles'
                 */
                function rest(func, start) {
                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
                    return function() {
                        var args = arguments,
                            index = -1,
                            length = nativeMax(args.length - start, 0),
                            array = Array(length);

                        while (++index < length) {
                            array[index] = args[start + index];
                        }
                        switch (start) {
                            case 0: return func.call(this, array);
                            case 1: return func.call(this, args[0], array);
                            case 2: return func.call(this, args[0], args[1], array);
                        }
                        var otherArgs = Array(start + 1);
                        index = -1;
                        while (++index < start) {
                            otherArgs[index] = args[index];
                        }
                        otherArgs[start] = array;
                        return apply(func, this, otherArgs);
                    };
                }

                /**
                 * Creates a function that invokes `func` with the `this` binding of the
                 * create function and an array of arguments much like
                 * [`Function#apply`](http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.apply).
                 *
                 * **Note:** This method is based on the
                 * [spread operator](https://mdn.io/spread_operator).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.2.0
                 * @category Function
                 * @param {Function} func The function to spread arguments over.
                 * @param {number} [start=0] The start position of the spread.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
                 *
                 * say(['fred', 'hello']);
                 * // => 'fred says hello'
                 *
                 * var numbers = Promise.all([
                 *   Promise.resolve(40),
                 *   Promise.resolve(36)
                 * ]);
                 *
                 * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
                 * // => a Promise of 76
                 */
                function spread(func, start) {
                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
                    return rest(function(args) {
                        var array = args[start],
                            otherArgs = castSlice(args, 0, start);

                        if (array) {
                            arrayPush(otherArgs, array);
                        }
                        return apply(func, this, otherArgs);
                    });
                }

                /**
                 * Creates a throttled function that only invokes `func` at most once per
                 * every `wait` milliseconds. The throttled function comes with a `cancel`
                 * method to cancel delayed `func` invocations and a `flush` method to
                 * immediately invoke them. Provide an options object to indicate whether
                 * `func` should be invoked on the leading and/or trailing edge of the `wait`
                 * timeout. The `func` is invoked with the last arguments provided to the
                 * throttled function. Subsequent calls to the throttled function return the
                 * result of the last `func` invocation.
                 *
                 * **Note:** If `leading` and `trailing` options are `true`, `func` is
                 * invoked on the trailing edge of the timeout only if the throttled function
                 * is invoked more than once during the `wait` timeout.
                 *
                 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
                 * for details over the differences between `_.throttle` and `_.debounce`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {Function} func The function to throttle.
                 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
                 * @param {Object} [options={}] The options object.
                 * @param {boolean} [options.leading=true]
                 *  Specify invoking on the leading edge of the timeout.
                 * @param {boolean} [options.trailing=true]
                 *  Specify invoking on the trailing edge of the timeout.
                 * @returns {Function} Returns the new throttled function.
                 * @example
                 *
                 * // Avoid excessively updating the position while scrolling.
                 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
                 *
                 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
                 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
                 * jQuery(element).on('click', throttled);
                 *
                 * // Cancel the trailing throttled invocation.
                 * jQuery(window).on('popstate', throttled.cancel);
                 */
                function throttle(func, wait, options) {
                    var leading = true,
                        trailing = true;

                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    if (isObject(options)) {
                        leading = 'leading' in options ? !!options.leading : leading;
                        trailing = 'trailing' in options ? !!options.trailing : trailing;
                    }
                    return debounce(func, wait, {
                        'leading': leading,
                        'maxWait': wait,
                        'trailing': trailing
                    });
                }

                /**
                 * Creates a function that accepts up to one argument, ignoring any
                 * additional arguments.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Function
                 * @param {Function} func The function to cap arguments for.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * _.map(['6', '8', '10'], _.unary(parseInt));
                 * // => [6, 8, 10]
                 */
                function unary(func) {
                    return ary(func, 1);
                }

                /**
                 * Creates a function that provides `value` to the wrapper function as its
                 * first argument. Any additional arguments provided to the function are
                 * appended to those provided to the wrapper function. The wrapper is invoked
                 * with the `this` binding of the created function.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Function
                 * @param {*} value The value to wrap.
                 * @param {Function} [wrapper=identity] The wrapper function.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
                 *
                 * p('fred, barney, & pebbles');
                 * // => '<p>fred, barney, &amp; pebbles</p>'
                 */
                function wrap(value, wrapper) {
                    wrapper = wrapper == null ? identity : wrapper;
                    return partial(wrapper, value);
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Casts `value` as an array if it's not one.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.4.0
                 * @category Lang
                 * @param {*} value The value to inspect.
                 * @returns {Array} Returns the cast array.
                 * @example
                 *
                 * _.castArray(1);
                 * // => [1]
                 *
                 * _.castArray({ 'a': 1 });
                 * // => [{ 'a': 1 }]
                 *
                 * _.castArray('abc');
                 * // => ['abc']
                 *
                 * _.castArray(null);
                 * // => [null]
                 *
                 * _.castArray(undefined);
                 * // => [undefined]
                 *
                 * _.castArray();
                 * // => []
                 *
                 * var array = [1, 2, 3];
                 * console.log(_.castArray(array) === array);
                 * // => true
                 */
                function castArray() {
                    if (!arguments.length) {
                        return [];
                    }
                    var value = arguments[0];
                    return isArray(value) ? value : [value];
                }

                /**
                 * Creates a shallow clone of `value`.
                 *
                 * **Note:** This method is loosely based on the
                 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
                 * and supports cloning arrays, array buffers, booleans, date objects, maps,
                 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
                 * arrays. The own enumerable properties of `arguments` objects are cloned
                 * as plain objects. An empty object is returned for uncloneable values such
                 * as error objects, functions, DOM nodes, and WeakMaps.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to clone.
                 * @returns {*} Returns the cloned value.
                 * @example
                 *
                 * var objects = [{ 'a': 1 }, { 'b': 2 }];
                 *
                 * var shallow = _.clone(objects);
                 * console.log(shallow[0] === objects[0]);
                 * // => true
                 */
                function clone(value) {
                    return baseClone(value, false, true);
                }

                /**
                 * This method is like `_.clone` except that it accepts `customizer` which
                 * is invoked to produce the cloned value. If `customizer` returns `undefined`,
                 * cloning is handled by the method instead. The `customizer` is invoked with
                 * up to four arguments; (value [, index|key, object, stack]).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to clone.
                 * @param {Function} [customizer] The function to customize cloning.
                 * @returns {*} Returns the cloned value.
                 * @example
                 *
                 * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
                 *
                 * var el = _.cloneWith(document.body, customizer);
                 *
                 * console.log(el === document.body);
                 * // => false
                 * console.log(el.nodeName);
                 * // => 'BODY'
                 * console.log(el.childNodes.length);
                 * // => 0
                 */
                function cloneWith(value, customizer) {
                    return baseClone(value, false, true, customizer);
                }

                /**
                 * This method is like `_.clone` except that it recursively clones `value`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.0.0
                 * @category Lang
                 * @param {*} value The value to recursively clone.
                 * @returns {*} Returns the deep cloned value.
                 * @example
                 *
                 * var objects = [{ 'a': 1 }, { 'b': 2 }];
                 *
                 * var deep = _.cloneDeep(objects);
                 * console.log(deep[0] === objects[0]);
                 * // => false
                 */
                function cloneDeep(value) {
                    return baseClone(value, true, true);
                }

                /**
                 * This method is like `_.cloneWith` except that it recursively clones `value`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to recursively clone.
                 * @param {Function} [customizer] The function to customize cloning.
                 * @returns {*} Returns the deep cloned value.
                 * @example
                 *
                 * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
                 *
                 * var el = _.cloneDeepWith(document.body, customizer);
                 *
                 * console.log(el === document.body);
                 * // => false
                 * console.log(el.nodeName);
                 * // => 'BODY'
                 * console.log(el.childNodes.length);
                 * // => 20
                 */
                function cloneDeepWith(value, customizer) {
                    return baseClone(value, true, true, customizer);
                }

                /**
                 * Performs a
                 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                 * comparison between two values to determine if they are equivalent.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 * @example
                 *
                 * var object = { 'user': 'fred' };
                 * var other = { 'user': 'fred' };
                 *
                 * _.eq(object, object);
                 * // => true
                 *
                 * _.eq(object, other);
                 * // => false
                 *
                 * _.eq('a', 'a');
                 * // => true
                 *
                 * _.eq('a', Object('a'));
                 * // => false
                 *
                 * _.eq(NaN, NaN);
                 * // => true
                 */
                function eq(value, other) {
                    return value === other || (value !== value && other !== other);
                }

                /**
                 * Checks if `value` is greater than `other`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.9.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is greater than `other`,
                 *  else `false`.
                 * @example
                 *
                 * _.gt(3, 1);
                 * // => true
                 *
                 * _.gt(3, 3);
                 * // => false
                 *
                 * _.gt(1, 3);
                 * // => false
                 */
                function gt(value, other) {
                    return value > other;
                }

                /**
                 * Checks if `value` is greater than or equal to `other`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.9.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is greater than or equal to
                 *  `other`, else `false`.
                 * @example
                 *
                 * _.gte(3, 1);
                 * // => true
                 *
                 * _.gte(3, 3);
                 * // => true
                 *
                 * _.gte(1, 3);
                 * // => false
                 */
                function gte(value, other) {
                    return value >= other;
                }

                /**
                 * Checks if `value` is likely an `arguments` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isArguments(function() { return arguments; }());
                 * // => true
                 *
                 * _.isArguments([1, 2, 3]);
                 * // => false
                 */
                function isArguments(value) {
                    // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
                    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
                        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
                }

                /**
                 * Checks if `value` is classified as an `Array` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @type {Function}
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isArray([1, 2, 3]);
                 * // => true
                 *
                 * _.isArray(document.body.children);
                 * // => false
                 *
                 * _.isArray('abc');
                 * // => false
                 *
                 * _.isArray(_.noop);
                 * // => false
                 */
                var isArray = Array.isArray;

                /**
                 * Checks if `value` is classified as an `ArrayBuffer` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isArrayBuffer(new ArrayBuffer(2));
                 * // => true
                 *
                 * _.isArrayBuffer(new Array(2));
                 * // => false
                 */
                function isArrayBuffer(value) {
                    return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
                }

                /**
                 * Checks if `value` is array-like. A value is considered array-like if it's
                 * not a function and has a `value.length` that's an integer greater than or
                 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                 * @example
                 *
                 * _.isArrayLike([1, 2, 3]);
                 * // => true
                 *
                 * _.isArrayLike(document.body.children);
                 * // => true
                 *
                 * _.isArrayLike('abc');
                 * // => true
                 *
                 * _.isArrayLike(_.noop);
                 * // => false
                 */
                function isArrayLike(value) {
                    return value != null && isLength(getLength(value)) && !isFunction(value);
                }

                /**
                 * This method is like `_.isArrayLike` except that it also checks if `value`
                 * is an object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an array-like object,
                 *  else `false`.
                 * @example
                 *
                 * _.isArrayLikeObject([1, 2, 3]);
                 * // => true
                 *
                 * _.isArrayLikeObject(document.body.children);
                 * // => true
                 *
                 * _.isArrayLikeObject('abc');
                 * // => false
                 *
                 * _.isArrayLikeObject(_.noop);
                 * // => false
                 */
                function isArrayLikeObject(value) {
                    return isObjectLike(value) && isArrayLike(value);
                }

                /**
                 * Checks if `value` is classified as a boolean primitive or object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isBoolean(false);
                 * // => true
                 *
                 * _.isBoolean(null);
                 * // => false
                 */
                function isBoolean(value) {
                    return value === true || value === false ||
                        (isObjectLike(value) && objectToString.call(value) == boolTag);
                }

                /**
                 * Checks if `value` is a buffer.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                 * @example
                 *
                 * _.isBuffer(new Buffer(2));
                 * // => true
                 *
                 * _.isBuffer(new Uint8Array(2));
                 * // => false
                 */
                var isBuffer = !Buffer ? constant(false) : function(value) {
                    return value instanceof Buffer;
                };

                /**
                 * Checks if `value` is classified as a `Date` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isDate(new Date);
                 * // => true
                 *
                 * _.isDate('Mon April 23 2012');
                 * // => false
                 */
                function isDate(value) {
                    return isObjectLike(value) && objectToString.call(value) == dateTag;
                }

                /**
                 * Checks if `value` is likely a DOM element.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a DOM element,
                 *  else `false`.
                 * @example
                 *
                 * _.isElement(document.body);
                 * // => true
                 *
                 * _.isElement('<body>');
                 * // => false
                 */
                function isElement(value) {
                    return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
                }

                /**
                 * Checks if `value` is an empty object, collection, map, or set.
                 *
                 * Objects are considered empty if they have no own enumerable string keyed
                 * properties.
                 *
                 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
                 * jQuery-like collections are considered empty if they have a `length` of `0`.
                 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                 * @example
                 *
                 * _.isEmpty(null);
                 * // => true
                 *
                 * _.isEmpty(true);
                 * // => true
                 *
                 * _.isEmpty(1);
                 * // => true
                 *
                 * _.isEmpty([1, 2, 3]);
                 * // => false
                 *
                 * _.isEmpty({ 'a': 1 });
                 * // => false
                 */
                function isEmpty(value) {
                    if (isArrayLike(value) &&
                        (isArray(value) || isString(value) || isFunction(value.splice) ||
                        isArguments(value) || isBuffer(value))) {
                        return !value.length;
                    }
                    if (isObjectLike(value)) {
                        var tag = getTag(value);
                        if (tag == mapTag || tag == setTag) {
                            return !value.size;
                        }
                    }
                    for (var key in value) {
                        if (hasOwnProperty.call(value, key)) {
                            return false;
                        }
                    }
                    return !(nonEnumShadows && keys(value).length);
                }

                /**
                 * Performs a deep comparison between two values to determine if they are
                 * equivalent.
                 *
                 * **Note:** This method supports comparing arrays, array buffers, booleans,
                 * date objects, error objects, maps, numbers, `Object` objects, regexes,
                 * sets, strings, symbols, and typed arrays. `Object` objects are compared
                 * by their own, not inherited, enumerable properties. Functions and DOM
                 * nodes are **not** supported.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if the values are equivalent,
                 *  else `false`.
                 * @example
                 *
                 * var object = { 'user': 'fred' };
                 * var other = { 'user': 'fred' };
                 *
                 * _.isEqual(object, other);
                 * // => true
                 *
                 * object === other;
                 * // => false
                 */
                function isEqual(value, other) {
                    return baseIsEqual(value, other);
                }

                /**
                 * This method is like `_.isEqual` except that it accepts `customizer` which
                 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
                 * are handled by the method instead. The `customizer` is invoked with up to
                 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @returns {boolean} Returns `true` if the values are equivalent,
                 *  else `false`.
                 * @example
                 *
                 * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
                 *
                 * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
                 *
                 * var array = ['hello', 'goodbye'];
                 * var other = ['hi', 'goodbye'];
                 *
                 * _.isEqualWith(array, other, customizer);
                 * // => true
                 */
                function isEqualWith(value, other, customizer) {
                    customizer = typeof customizer == 'function' ? customizer : undefined;
                    var result = customizer ? customizer(value, other) : undefined;
                    return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
                }

                /**
                 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
                 * `SyntaxError`, `TypeError`, or `URIError` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an error object,
                 *  else `false`.
                 * @example
                 *
                 * _.isError(new Error);
                 * // => true
                 *
                 * _.isError(Error);
                 * // => false
                 */
                function isError(value) {
                    if (!isObjectLike(value)) {
                        return false;
                    }
                    return (objectToString.call(value) == errorTag) ||
                        (typeof value.message == 'string' && typeof value.name == 'string');
                }

                /**
                 * Checks if `value` is a finite primitive number.
                 *
                 * **Note:** This method is based on
                 * [`Number.isFinite`](https://mdn.io/Number/isFinite).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a finite number,
                 *  else `false`.
                 * @example
                 *
                 * _.isFinite(3);
                 * // => true
                 *
                 * _.isFinite(Number.MAX_VALUE);
                 * // => true
                 *
                 * _.isFinite(3.14);
                 * // => true
                 *
                 * _.isFinite(Infinity);
                 * // => false
                 */
                function isFinite(value) {
                    return typeof value == 'number' && nativeIsFinite(value);
                }

                /**
                 * Checks if `value` is classified as a `Function` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isFunction(_);
                 * // => true
                 *
                 * _.isFunction(/abc/);
                 * // => false
                 */
                function isFunction(value) {
                    // The use of `Object#toString` avoids issues with the `typeof` operator
                    // in Safari 8 which returns 'object' for typed array and weak map constructors,
                    // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
                    var tag = isObject(value) ? objectToString.call(value) : '';
                    return tag == funcTag || tag == genTag;
                }

                /**
                 * Checks if `value` is an integer.
                 *
                 * **Note:** This method is based on
                 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
                 * @example
                 *
                 * _.isInteger(3);
                 * // => true
                 *
                 * _.isInteger(Number.MIN_VALUE);
                 * // => false
                 *
                 * _.isInteger(Infinity);
                 * // => false
                 *
                 * _.isInteger('3');
                 * // => false
                 */
                function isInteger(value) {
                    return typeof value == 'number' && value == toInteger(value);
                }

                /**
                 * Checks if `value` is a valid array-like length.
                 *
                 * **Note:** This function is loosely based on
                 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a valid length,
                 *  else `false`.
                 * @example
                 *
                 * _.isLength(3);
                 * // => true
                 *
                 * _.isLength(Number.MIN_VALUE);
                 * // => false
                 *
                 * _.isLength(Infinity);
                 * // => false
                 *
                 * _.isLength('3');
                 * // => false
                 */
                function isLength(value) {
                    return typeof value == 'number' &&
                        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }

                /**
                 * Checks if `value` is the
                 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
                 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                 * @example
                 *
                 * _.isObject({});
                 * // => true
                 *
                 * _.isObject([1, 2, 3]);
                 * // => true
                 *
                 * _.isObject(_.noop);
                 * // => true
                 *
                 * _.isObject(null);
                 * // => false
                 */
                function isObject(value) {
                    var type = typeof value;
                    return !!value && (type == 'object' || type == 'function');
                }

                /**
                 * Checks if `value` is object-like. A value is object-like if it's not `null`
                 * and has a `typeof` result of "object".
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                 * @example
                 *
                 * _.isObjectLike({});
                 * // => true
                 *
                 * _.isObjectLike([1, 2, 3]);
                 * // => true
                 *
                 * _.isObjectLike(_.noop);
                 * // => false
                 *
                 * _.isObjectLike(null);
                 * // => false
                 */
                function isObjectLike(value) {
                    return !!value && typeof value == 'object';
                }

                /**
                 * Checks if `value` is classified as a `Map` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isMap(new Map);
                 * // => true
                 *
                 * _.isMap(new WeakMap);
                 * // => false
                 */
                function isMap(value) {
                    return isObjectLike(value) && getTag(value) == mapTag;
                }

                /**
                 * Performs a partial deep comparison between `object` and `source` to
                 * determine if `object` contains equivalent property values. This method is
                 * equivalent to a `_.matches` function when `source` is partially applied.
                 *
                 * **Note:** This method supports comparing the same values as `_.isEqual`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property values to match.
                 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                 * @example
                 *
                 * var object = { 'user': 'fred', 'age': 40 };
                 *
                 * _.isMatch(object, { 'age': 40 });
                 * // => true
                 *
                 * _.isMatch(object, { 'age': 36 });
                 * // => false
                 */
                function isMatch(object, source) {
                    return object === source || baseIsMatch(object, source, getMatchData(source));
                }

                /**
                 * This method is like `_.isMatch` except that it accepts `customizer` which
                 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
                 * are handled by the method instead. The `customizer` is invoked with five
                 * arguments: (objValue, srcValue, index|key, object, source).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {Object} object The object to inspect.
                 * @param {Object} source The object of property values to match.
                 * @param {Function} [customizer] The function to customize comparisons.
                 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                 * @example
                 *
                 * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
                 *
                 * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
                 *
                 * var object = { 'greeting': 'hello' };
                 * var source = { 'greeting': 'hi' };
                 *
                 * _.isMatchWith(object, source, customizer);
                 * // => true
                 */
                function isMatchWith(object, source, customizer) {
                    customizer = typeof customizer == 'function' ? customizer : undefined;
                    return baseIsMatch(object, source, getMatchData(source), customizer);
                }

                /**
                 * Checks if `value` is `NaN`.
                 *
                 * **Note:** This method is based on
                 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
                 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
                 * `undefined` and other non-number values.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                 * @example
                 *
                 * _.isNaN(NaN);
                 * // => true
                 *
                 * _.isNaN(new Number(NaN));
                 * // => true
                 *
                 * isNaN(undefined);
                 * // => true
                 *
                 * _.isNaN(undefined);
                 * // => false
                 */
                function isNaN(value) {
                    // An `NaN` primitive is the only value that is not equal to itself.
                    // Perform the `toStringTag` check first to avoid errors with some
                    // ActiveX objects in IE.
                    return isNumber(value) && value != +value;
                }

                /**
                 * Checks if `value` is a native function.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a native function,
                 *  else `false`.
                 * @example
                 *
                 * _.isNative(Array.prototype.push);
                 * // => true
                 *
                 * _.isNative(_);
                 * // => false
                 */
                function isNative(value) {
                    if (!isObject(value)) {
                        return false;
                    }
                    var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
                    return pattern.test(toSource(value));
                }

                /**
                 * Checks if `value` is `null`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
                 * @example
                 *
                 * _.isNull(null);
                 * // => true
                 *
                 * _.isNull(void 0);
                 * // => false
                 */
                function isNull(value) {
                    return value === null;
                }

                /**
                 * Checks if `value` is `null` or `undefined`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
                 * @example
                 *
                 * _.isNil(null);
                 * // => true
                 *
                 * _.isNil(void 0);
                 * // => true
                 *
                 * _.isNil(NaN);
                 * // => false
                 */
                function isNil(value) {
                    return value == null;
                }

                /**
                 * Checks if `value` is classified as a `Number` primitive or object.
                 *
                 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
                 * classified as numbers, use the `_.isFinite` method.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isNumber(3);
                 * // => true
                 *
                 * _.isNumber(Number.MIN_VALUE);
                 * // => true
                 *
                 * _.isNumber(Infinity);
                 * // => true
                 *
                 * _.isNumber('3');
                 * // => false
                 */
                function isNumber(value) {
                    return typeof value == 'number' ||
                        (isObjectLike(value) && objectToString.call(value) == numberTag);
                }

                /**
                 * Checks if `value` is a plain object, that is, an object created by the
                 * `Object` constructor or one with a `[[Prototype]]` of `null`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.8.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a plain object,
                 *  else `false`.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     * }
                 *
                 * _.isPlainObject(new Foo);
                 * // => false
                 *
                 * _.isPlainObject([1, 2, 3]);
                 * // => false
                 *
                 * _.isPlainObject({ 'x': 0, 'y': 0 });
                 * // => true
                 *
                 * _.isPlainObject(Object.create(null));
                 * // => true
                 */
                function isPlainObject(value) {
                    if (!isObjectLike(value) ||
                        objectToString.call(value) != objectTag || isHostObject(value)) {
                        return false;
                    }
                    var proto = getPrototype(value);
                    if (proto === null) {
                        return true;
                    }
                    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                    return (typeof Ctor == 'function' &&
                    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
                }

                /**
                 * Checks if `value` is classified as a `RegExp` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.1.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isRegExp(/abc/);
                 * // => true
                 *
                 * _.isRegExp('/abc/');
                 * // => false
                 */
                function isRegExp(value) {
                    return isObject(value) && objectToString.call(value) == regexpTag;
                }

                /**
                 * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
                 * double precision number which isn't the result of a rounded unsafe integer.
                 *
                 * **Note:** This method is based on
                 * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a safe integer,
                 *  else `false`.
                 * @example
                 *
                 * _.isSafeInteger(3);
                 * // => true
                 *
                 * _.isSafeInteger(Number.MIN_VALUE);
                 * // => false
                 *
                 * _.isSafeInteger(Infinity);
                 * // => false
                 *
                 * _.isSafeInteger('3');
                 * // => false
                 */
                function isSafeInteger(value) {
                    return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                }

                /**
                 * Checks if `value` is classified as a `Set` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isSet(new Set);
                 * // => true
                 *
                 * _.isSet(new WeakSet);
                 * // => false
                 */
                function isSet(value) {
                    return isObjectLike(value) && getTag(value) == setTag;
                }

                /**
                 * Checks if `value` is classified as a `String` primitive or object.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isString('abc');
                 * // => true
                 *
                 * _.isString(1);
                 * // => false
                 */
                function isString(value) {
                    return typeof value == 'string' ||
                        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
                }

                /**
                 * Checks if `value` is classified as a `Symbol` primitive or object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isSymbol(Symbol.iterator);
                 * // => true
                 *
                 * _.isSymbol('abc');
                 * // => false
                 */
                function isSymbol(value) {
                    return typeof value == 'symbol' ||
                        (isObjectLike(value) && objectToString.call(value) == symbolTag);
                }

                /**
                 * Checks if `value` is classified as a typed array.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isTypedArray(new Uint8Array);
                 * // => true
                 *
                 * _.isTypedArray([]);
                 * // => false
                 */
                function isTypedArray(value) {
                    return isObjectLike(value) &&
                        isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
                }

                /**
                 * Checks if `value` is `undefined`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                 * @example
                 *
                 * _.isUndefined(void 0);
                 * // => true
                 *
                 * _.isUndefined(null);
                 * // => false
                 */
                function isUndefined(value) {
                    return value === undefined;
                }

                /**
                 * Checks if `value` is classified as a `WeakMap` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isWeakMap(new WeakMap);
                 * // => true
                 *
                 * _.isWeakMap(new Map);
                 * // => false
                 */
                function isWeakMap(value) {
                    return isObjectLike(value) && getTag(value) == weakMapTag;
                }

                /**
                 * Checks if `value` is classified as a `WeakSet` object.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified,
                 *  else `false`.
                 * @example
                 *
                 * _.isWeakSet(new WeakSet);
                 * // => true
                 *
                 * _.isWeakSet(new Set);
                 * // => false
                 */
                function isWeakSet(value) {
                    return isObjectLike(value) && objectToString.call(value) == weakSetTag;
                }

                /**
                 * Checks if `value` is less than `other`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.9.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is less than `other`,
                 *  else `false`.
                 * @example
                 *
                 * _.lt(1, 3);
                 * // => true
                 *
                 * _.lt(3, 3);
                 * // => false
                 *
                 * _.lt(3, 1);
                 * // => false
                 */
                function lt(value, other) {
                    return value < other;
                }

                /**
                 * Checks if `value` is less than or equal to `other`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.9.0
                 * @category Lang
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {boolean} Returns `true` if `value` is less than or equal to
                 *  `other`, else `false`.
                 * @example
                 *
                 * _.lte(1, 3);
                 * // => true
                 *
                 * _.lte(3, 3);
                 * // => true
                 *
                 * _.lte(3, 1);
                 * // => false
                 */
                function lte(value, other) {
                    return value <= other;
                }

                /**
                 * Converts `value` to an array.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {Array} Returns the converted array.
                 * @example
                 *
                 * _.toArray({ 'a': 1, 'b': 2 });
                 * // => [1, 2]
                 *
                 * _.toArray('abc');
                 * // => ['a', 'b', 'c']
                 *
                 * _.toArray(1);
                 * // => []
                 *
                 * _.toArray(null);
                 * // => []
                 */
                function toArray(value) {
                    if (!value) {
                        return [];
                    }
                    if (isArrayLike(value)) {
                        return isString(value) ? stringToArray(value) : copyArray(value);
                    }
                    if (iteratorSymbol && value[iteratorSymbol]) {
                        return iteratorToArray(value[iteratorSymbol]());
                    }
                    var tag = getTag(value),
                        func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

                    return func(value);
                }

                /**
                 * Converts `value` to an integer.
                 *
                 * **Note:** This function is loosely based on
                 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {number} Returns the converted integer.
                 * @example
                 *
                 * _.toInteger(3);
                 * // => 3
                 *
                 * _.toInteger(Number.MIN_VALUE);
                 * // => 0
                 *
                 * _.toInteger(Infinity);
                 * // => 1.7976931348623157e+308
                 *
                 * _.toInteger('3');
                 * // => 3
                 */
                function toInteger(value) {
                    if (!value) {
                        return value === 0 ? value : 0;
                    }
                    value = toNumber(value);
                    if (value === INFINITY || value === -INFINITY) {
                        var sign = (value < 0 ? -1 : 1);
                        return sign * MAX_INTEGER;
                    }
                    var remainder = value % 1;
                    return value === value ? (remainder ? value - remainder : value) : 0;
                }

                /**
                 * Converts `value` to an integer suitable for use as the length of an
                 * array-like object.
                 *
                 * **Note:** This method is based on
                 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {number} Returns the converted integer.
                 * @example
                 *
                 * _.toLength(3);
                 * // => 3
                 *
                 * _.toLength(Number.MIN_VALUE);
                 * // => 0
                 *
                 * _.toLength(Infinity);
                 * // => 4294967295
                 *
                 * _.toLength('3');
                 * // => 3
                 */
                function toLength(value) {
                    return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                }

                /**
                 * Converts `value` to a number.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to process.
                 * @returns {number} Returns the number.
                 * @example
                 *
                 * _.toNumber(3);
                 * // => 3
                 *
                 * _.toNumber(Number.MIN_VALUE);
                 * // => 5e-324
                 *
                 * _.toNumber(Infinity);
                 * // => Infinity
                 *
                 * _.toNumber('3');
                 * // => 3
                 */
                function toNumber(value) {
                    if (typeof value == 'number') {
                        return value;
                    }
                    if (isSymbol(value)) {
                        return NAN;
                    }
                    if (isObject(value)) {
                        var other = isFunction(value.valueOf) ? value.valueOf() : value;
                        value = isObject(other) ? (other + '') : other;
                    }
                    if (typeof value != 'string') {
                        return value === 0 ? value : +value;
                    }
                    value = value.replace(reTrim, '');
                    var isBinary = reIsBinary.test(value);
                    return (isBinary || reIsOctal.test(value))
                        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
                        : (reIsBadHex.test(value) ? NAN : +value);
                }

                /**
                 * Converts `value` to a plain object flattening inherited enumerable string
                 * keyed properties of `value` to own properties of the plain object.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {Object} Returns the converted plain object.
                 * @example
                 *
                 * function Foo() {
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.assign({ 'a': 1 }, new Foo);
                 * // => { 'a': 1, 'b': 2 }
                 *
                 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                 * // => { 'a': 1, 'b': 2, 'c': 3 }
                 */
                function toPlainObject(value) {
                    return copyObject(value, keysIn(value));
                }

                /**
                 * Converts `value` to a safe integer. A safe integer can be compared and
                 * represented correctly.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to convert.
                 * @returns {number} Returns the converted integer.
                 * @example
                 *
                 * _.toSafeInteger(3);
                 * // => 3
                 *
                 * _.toSafeInteger(Number.MIN_VALUE);
                 * // => 0
                 *
                 * _.toSafeInteger(Infinity);
                 * // => 9007199254740991
                 *
                 * _.toSafeInteger('3');
                 * // => 3
                 */
                function toSafeInteger(value) {
                    return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
                }

                /**
                 * Converts `value` to a string. An empty string is returned for `null`
                 * and `undefined` values. The sign of `-0` is preserved.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Lang
                 * @param {*} value The value to process.
                 * @returns {string} Returns the string.
                 * @example
                 *
                 * _.toString(null);
                 * // => ''
                 *
                 * _.toString(-0);
                 * // => '-0'
                 *
                 * _.toString([1, 2, 3]);
                 * // => '1,2,3'
                 */
                function toString(value) {
                    // Exit early for strings to avoid a performance hit in some environments.
                    if (typeof value == 'string') {
                        return value;
                    }
                    if (value == null) {
                        return '';
                    }
                    if (isSymbol(value)) {
                        return symbolToString ? symbolToString.call(value) : '';
                    }
                    var result = (value + '');
                    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Assigns own enumerable string keyed properties of source objects to the
                 * destination object. Source objects are applied from left to right.
                 * Subsequent sources overwrite property assignments of previous sources.
                 *
                 * **Note:** This method mutates `object` and is loosely based on
                 * [`Object.assign`](https://mdn.io/Object/assign).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.10.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function Foo() {
     *   this.c = 3;
     * }
                 *
                 * function Bar() {
     *   this.e = 5;
     * }
                 *
                 * Foo.prototype.d = 4;
                 * Bar.prototype.f = 6;
                 *
                 * _.assign({ 'a': 1 }, new Foo, new Bar);
                 * // => { 'a': 1, 'c': 3, 'e': 5 }
                 */
                var assign = createAssigner(function(object, source) {
                    if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
                        copyObject(source, keys(source), object);
                        return;
                    }
                    for (var key in source) {
                        if (hasOwnProperty.call(source, key)) {
                            assignValue(object, key, source[key]);
                        }
                    }
                });

                /**
                 * This method is like `_.assign` except that it iterates over own and
                 * inherited source properties.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @alias extend
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function Foo() {
     *   this.b = 2;
     * }
                 *
                 * function Bar() {
     *   this.d = 4;
     * }
                 *
                 * Foo.prototype.c = 3;
                 * Bar.prototype.e = 5;
                 *
                 * _.assignIn({ 'a': 1 }, new Foo, new Bar);
                 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
                 */
                var assignIn = createAssigner(function(object, source) {
                    if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
                        copyObject(source, keysIn(source), object);
                        return;
                    }
                    for (var key in source) {
                        assignValue(object, key, source[key]);
                    }
                });

                /**
                 * This method is like `_.assignIn` except that it accepts `customizer`
                 * which is invoked to produce the assigned values. If `customizer` returns
                 * `undefined`, assignment is handled by the method instead. The `customizer`
                 * is invoked with five arguments: (objValue, srcValue, key, object, source).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @alias extendWith
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} sources The source objects.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
                 *
                 * var defaults = _.partialRight(_.assignInWith, customizer);
                 *
                 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                 * // => { 'a': 1, 'b': 2 }
                 */
                var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                    copyObject(source, keysIn(source), object, customizer);
                });

                /**
                 * This method is like `_.assign` except that it accepts `customizer`
                 * which is invoked to produce the assigned values. If `customizer` returns
                 * `undefined`, assignment is handled by the method instead. The `customizer`
                 * is invoked with five arguments: (objValue, srcValue, key, object, source).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} sources The source objects.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
                 *
                 * var defaults = _.partialRight(_.assignWith, customizer);
                 *
                 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                 * // => { 'a': 1, 'b': 2 }
                 */
                var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                    copyObject(source, keys(source), object, customizer);
                });

                /**
                 * Creates an array of values corresponding to `paths` of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.0.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {...(string|string[])} [paths] The property paths of elements to pick.
                 * @returns {Array} Returns the new array of picked elements.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
                 *
                 * _.at(object, ['a[0].b.c', 'a[1]']);
                 * // => [3, 4]
                 *
                 * _.at(['a', 'b', 'c'], 0, 2);
                 * // => ['a', 'c']
                 */
                var at = rest(function(object, paths) {
                    return baseAt(object, baseFlatten(paths, 1));
                });

                /**
                 * Creates an object that inherits from the `prototype` object. If a
                 * `properties` object is given, its own enumerable string keyed properties
                 * are assigned to the created object.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.3.0
                 * @category Object
                 * @param {Object} prototype The object to inherit from.
                 * @param {Object} [properties] The properties to assign to the object.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
                 *
                 * function Circle() {
     *   Shape.call(this);
     * }
                 *
                 * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
                 *
                 * var circle = new Circle;
                 * circle instanceof Circle;
                 * // => true
                 *
                 * circle instanceof Shape;
                 * // => true
                 */
                function create(prototype, properties) {
                    var result = baseCreate(prototype);
                    return properties ? baseAssign(result, properties) : result;
                }

                /**
                 * Assigns own and inherited enumerable string keyed properties of source
                 * objects to the destination object for all destination properties that
                 * resolve to `undefined`. Source objects are applied from left to right.
                 * Once a property is set, additional values of the same property are ignored.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                 * // => { 'user': 'barney', 'age': 36 }
                 */
                var defaults = rest(function(args) {
                    args.push(undefined, assignInDefaults);
                    return apply(assignInWith, undefined, args);
                });

                /**
                 * This method is like `_.defaults` except that it recursively assigns
                 * default properties.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.10.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
                 * // => { 'user': { 'name': 'barney', 'age': 36 } }
                 *
                 */
                var defaultsDeep = rest(function(args) {
                    args.push(undefined, mergeDefaults);
                    return apply(mergeWith, undefined, args);
                });

                /**
                 * This method is like `_.find` except that it returns the key of the first
                 * element `predicate` returns truthy for instead of the element itself.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.1.0
                 * @category Object
                 * @param {Object} object The object to search.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {string|undefined} Returns the key of the matched element,
                 *  else `undefined`.
                 * @example
                 *
                 * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
                 *
                 * _.findKey(users, function(o) { return o.age < 40; });
                 * // => 'barney' (iteration order is not guaranteed)
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.findKey(users, { 'age': 1, 'active': true });
                 * // => 'pebbles'
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.findKey(users, ['active', false]);
                 * // => 'fred'
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.findKey(users, 'active');
                 * // => 'barney'
                 */
                function findKey(object, predicate) {
                    return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);
                }

                /**
                 * This method is like `_.findKey` except that it iterates over elements of
                 * a collection in the opposite order.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Object
                 * @param {Object} object The object to search.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per iteration.
                 * @returns {string|undefined} Returns the key of the matched element,
                 *  else `undefined`.
                 * @example
                 *
                 * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
                 *
                 * _.findLastKey(users, function(o) { return o.age < 40; });
                 * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.findLastKey(users, { 'age': 36, 'active': true });
                 * // => 'barney'
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.findLastKey(users, ['active', false]);
                 * // => 'fred'
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.findLastKey(users, 'active');
                 * // => 'pebbles'
                 */
                function findLastKey(object, predicate) {
                    return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);
                }

                /**
                 * Iterates over own and inherited enumerable string keyed properties of an
                 * object and invokes `iteratee` for each property. The iteratee is invoked
                 * with three arguments: (value, key, object). Iteratee functions may exit
                 * iteration early by explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.3.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
                 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
                 */
                function forIn(object, iteratee) {
                    return object == null
                        ? object
                        : baseFor(object, getIteratee(iteratee), keysIn);
                }

                /**
                 * This method is like `_.forIn` except that it iterates over properties of
                 * `object` in the opposite order.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
                 * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
                 */
                function forInRight(object, iteratee) {
                    return object == null
                        ? object
                        : baseForRight(object, getIteratee(iteratee), keysIn);
                }

                /**
                 * Iterates over own enumerable string keyed properties of an object and
                 * invokes `iteratee` for each property. The iteratee is invoked with three
                 * arguments: (value, key, object). Iteratee functions may exit iteration
                 * early by explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.3.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
                 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                 */
                function forOwn(object, iteratee) {
                    return object && baseForOwn(object, getIteratee(iteratee));
                }

                /**
                 * This method is like `_.forOwn` except that it iterates over properties of
                 * `object` in the opposite order.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.0.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
                 * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
                 */
                function forOwnRight(object, iteratee) {
                    return object && baseForOwnRight(object, getIteratee(iteratee));
                }

                /**
                 * Creates an array of function property names from own enumerable properties
                 * of `object`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to inspect.
                 * @returns {Array} Returns the new array of property names.
                 * @example
                 *
                 * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
                 *
                 * Foo.prototype.c = _.constant('c');
                 *
                 * _.functions(new Foo);
                 * // => ['a', 'b']
                 */
                function functions(object) {
                    return object == null ? [] : baseFunctions(object, keys(object));
                }

                /**
                 * Creates an array of function property names from own and inherited
                 * enumerable properties of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to inspect.
                 * @returns {Array} Returns the new array of property names.
                 * @example
                 *
                 * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
                 *
                 * Foo.prototype.c = _.constant('c');
                 *
                 * _.functionsIn(new Foo);
                 * // => ['a', 'b', 'c']
                 */
                function functionsIn(object) {
                    return object == null ? [] : baseFunctions(object, keysIn(object));
                }

                /**
                 * Gets the value at `path` of `object`. If the resolved value is
                 * `undefined`, the `defaultValue` is used in its place.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to get.
                 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                 * @returns {*} Returns the resolved value.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                 *
                 * _.get(object, 'a[0].b.c');
                 * // => 3
                 *
                 * _.get(object, ['a', '0', 'b', 'c']);
                 * // => 3
                 *
                 * _.get(object, 'a.b.c', 'default');
                 * // => 'default'
                 */
                function get(object, path, defaultValue) {
                    var result = object == null ? undefined : baseGet(object, path);
                    return result === undefined ? defaultValue : result;
                }

                /**
                 * Checks if `path` is a direct property of `object`.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path to check.
                 * @returns {boolean} Returns `true` if `path` exists, else `false`.
                 * @example
                 *
                 * var object = { 'a': { 'b': 2 } };
                 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
                 *
                 * _.has(object, 'a');
                 * // => true
                 *
                 * _.has(object, 'a.b');
                 * // => true
                 *
                 * _.has(object, ['a', 'b']);
                 * // => true
                 *
                 * _.has(other, 'a');
                 * // => false
                 */
                function has(object, path) {
                    return object != null && hasPath(object, path, baseHas);
                }

                /**
                 * Checks if `path` is a direct or inherited property of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path to check.
                 * @returns {boolean} Returns `true` if `path` exists, else `false`.
                 * @example
                 *
                 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
                 *
                 * _.hasIn(object, 'a');
                 * // => true
                 *
                 * _.hasIn(object, 'a.b');
                 * // => true
                 *
                 * _.hasIn(object, ['a', 'b']);
                 * // => true
                 *
                 * _.hasIn(object, 'b');
                 * // => false
                 */
                function hasIn(object, path) {
                    return object != null && hasPath(object, path, baseHasIn);
                }

                /**
                 * Creates an object composed of the inverted keys and values of `object`.
                 * If `object` contains duplicate values, subsequent values overwrite
                 * property assignments of previous values.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.7.0
                 * @category Object
                 * @param {Object} object The object to invert.
                 * @returns {Object} Returns the new inverted object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2, 'c': 1 };
                 *
                 * _.invert(object);
                 * // => { '1': 'c', '2': 'b' }
                 */
                var invert = createInverter(function(result, value, key) {
                    result[value] = key;
                }, constant(identity));

                /**
                 * This method is like `_.invert` except that the inverted object is generated
                 * from the results of running each element of `object` thru `iteratee`. The
                 * corresponding inverted value of each inverted key is an array of keys
                 * responsible for generating the inverted value. The iteratee is invoked
                 * with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.1.0
                 * @category Object
                 * @param {Object} object The object to invert.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {Object} Returns the new inverted object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': 2, 'c': 1 };
                 *
                 * _.invertBy(object);
                 * // => { '1': ['a', 'c'], '2': ['b'] }
                 *
                 * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
                 * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
                 */
                var invertBy = createInverter(function(result, value, key) {
                    if (hasOwnProperty.call(result, value)) {
                        result[value].push(key);
                    } else {
                        result[value] = [key];
                    }
                }, getIteratee);

                /**
                 * Invokes the method at `path` of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the method to invoke.
                 * @param {...*} [args] The arguments to invoke the method with.
                 * @returns {*} Returns the result of the invoked method.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
                 *
                 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
                 * // => [2, 3]
                 */
                var invoke = rest(baseInvoke);

                /**
                 * Creates an array of the own enumerable property names of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects. See the
                 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
                 * for more details.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.keys(new Foo);
                 * // => ['a', 'b'] (iteration order is not guaranteed)
                 *
                 * _.keys('hi');
                 * // => ['0', '1']
                 */
                function keys(object) {
                    var isProto = isPrototype(object);
                    if (!(isProto || isArrayLike(object))) {
                        return baseKeys(object);
                    }
                    var indexes = indexKeys(object),
                        skipIndexes = !!indexes,
                        result = indexes || [],
                        length = result.length;

                    for (var key in object) {
                        if (baseHas(object, key) &&
                            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
                            !(isProto && key == 'constructor')) {
                            result.push(key);
                        }
                    }
                    return result;
                }

                /**
                 * Creates an array of the own and inherited enumerable property names of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property names.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.keysIn(new Foo);
                 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                 */
                function keysIn(object) {
                    var index = -1,
                        isProto = isPrototype(object),
                        props = baseKeysIn(object),
                        propsLength = props.length,
                        indexes = indexKeys(object),
                        skipIndexes = !!indexes,
                        result = indexes || [],
                        length = result.length;

                    while (++index < propsLength) {
                        var key = props[index];
                        if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
                            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                            result.push(key);
                        }
                    }
                    return result;
                }

                /**
                 * The opposite of `_.mapValues`; this method creates an object with the
                 * same values as `object` and keys generated by running each own enumerable
                 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
                 * with three arguments: (value, key, object).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.8.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Object} Returns the new mapped object.
                 * @example
                 *
                 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
                 * // => { 'a1': 1, 'b2': 2 }
                 */
                function mapKeys(object, iteratee) {
                    var result = {};
                    iteratee = getIteratee(iteratee, 3);

                    baseForOwn(object, function(value, key, object) {
                        result[iteratee(value, key, object)] = value;
                    });
                    return result;
                }

                /**
                 * Creates an object with the same keys as `object` and values generated
                 * by running each own enumerable string keyed property of `object` thru
                 * `iteratee`. The iteratee is invoked with three arguments:
                 * (value, key, object).
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Object
                 * @param {Object} object The object to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The function invoked per iteration.
                 * @returns {Object} Returns the new mapped object.
                 * @example
                 *
                 * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
                 *
                 * _.mapValues(users, function(o) { return o.age; });
                 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.mapValues(users, 'age');
                 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                 */
                function mapValues(object, iteratee) {
                    var result = {};
                    iteratee = getIteratee(iteratee, 3);

                    baseForOwn(object, function(value, key, object) {
                        result[key] = iteratee(value, key, object);
                    });
                    return result;
                }

                /**
                 * This method is like `_.assign` except that it recursively merges own and
                 * inherited enumerable string keyed properties of source objects into the
                 * destination object. Source properties that resolve to `undefined` are
                 * skipped if a destination value exists. Array and plain object properties
                 * are merged recursively.Other objects and value types are overridden by
                 * assignment. Source objects are applied from left to right. Subsequent
                 * sources overwrite property assignments of previous sources.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.5.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} [sources] The source objects.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
                 *
                 * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
                 *
                 * _.merge(users, ages);
                 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
                 */
                var merge = createAssigner(function(object, source, srcIndex) {
                    baseMerge(object, source, srcIndex);
                });

                /**
                 * This method is like `_.merge` except that it accepts `customizer` which
                 * is invoked to produce the merged values of the destination and source
                 * properties. If `customizer` returns `undefined`, merging is handled by the
                 * method instead. The `customizer` is invoked with seven arguments:
                 * (objValue, srcValue, key, object, source, stack).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The destination object.
                 * @param {...Object} sources The source objects.
                 * @param {Function} customizer The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
                 *
                 * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
                 *
                 * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
                 *
                 * _.mergeWith(object, other, customizer);
                 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
                 */
                var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                    baseMerge(object, source, srcIndex, customizer);
                });

                /**
                 * The opposite of `_.pick`; this method creates an object composed of the
                 * own and inherited enumerable string keyed properties of `object` that are
                 * not omitted.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The source object.
                 * @param {...(string|string[])} [props] The property identifiers to omit.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': '2', 'c': 3 };
                 *
                 * _.omit(object, ['a', 'c']);
                 * // => { 'b': '2' }
                 */
                var omit = rest(function(object, props) {
                    if (object == null) {
                        return {};
                    }
                    props = arrayMap(baseFlatten(props, 1), toKey);
                    return basePick(object, baseDifference(getAllKeysIn(object), props));
                });

                /**
                 * The opposite of `_.pickBy`; this method creates an object composed of
                 * the own and inherited enumerable string keyed properties of `object` that
                 * `predicate` doesn't return truthy for. The predicate is invoked with two
                 * arguments: (value, key).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The source object.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per property.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': '2', 'c': 3 };
                 *
                 * _.omitBy(object, _.isNumber);
                 * // => { 'b': '2' }
                 */
                function omitBy(object, predicate) {
                    predicate = getIteratee(predicate);
                    return basePickBy(object, function(value, key) {
                        return !predicate(value, key);
                    });
                }

                /**
                 * Creates an object composed of the picked `object` properties.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The source object.
                 * @param {...(string|string[])} [props] The property identifiers to pick.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': '2', 'c': 3 };
                 *
                 * _.pick(object, ['a', 'c']);
                 * // => { 'a': 1, 'c': 3 }
                 */
                var pick = rest(function(object, props) {
                    return object == null ? {} : basePick(object, baseFlatten(props, 1));
                });

                /**
                 * Creates an object composed of the `object` properties `predicate` returns
                 * truthy for. The predicate is invoked with two arguments: (value, key).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The source object.
                 * @param {Array|Function|Object|string} [predicate=_.identity]
                 *  The function invoked per property.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * var object = { 'a': 1, 'b': '2', 'c': 3 };
                 *
                 * _.pickBy(object, _.isNumber);
                 * // => { 'a': 1, 'c': 3 }
                 */
                function pickBy(object, predicate) {
                    return object == null ? {} : basePickBy(object, getIteratee(predicate));
                }

                /**
                 * This method is like `_.get` except that if the resolved value is a
                 * function it's invoked with the `this` binding of its parent object and
                 * its result is returned.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @param {Array|string} path The path of the property to resolve.
                 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                 * @returns {*} Returns the resolved value.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
                 *
                 * _.result(object, 'a[0].b.c1');
                 * // => 3
                 *
                 * _.result(object, 'a[0].b.c2');
                 * // => 4
                 *
                 * _.result(object, 'a[0].b.c3', 'default');
                 * // => 'default'
                 *
                 * _.result(object, 'a[0].b.c3', _.constant('default'));
                 * // => 'default'
                 */
                function result(object, path, defaultValue) {
                    path = isKey(path, object) ? [path] : castPath(path);

                    var index = -1,
                        length = path.length;

                    // Ensure the loop is entered when path is empty.
                    if (!length) {
                        object = undefined;
                        length = 1;
                    }
                    while (++index < length) {
                        var value = object == null ? undefined : object[path[index]];
                        if (value === undefined) {
                            index = length;
                            value = defaultValue;
                        }
                        object = isFunction(value) ? value.call(object) : value;
                    }
                    return object;
                }

                /**
                 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
                 * it's created. Arrays are created for missing index properties while objects
                 * are created for all other missing properties. Use `_.setWith` to customize
                 * `path` creation.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {*} value The value to set.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                 *
                 * _.set(object, 'a[0].b.c', 4);
                 * console.log(object.a[0].b.c);
                 * // => 4
                 *
                 * _.set(object, ['x', '0', 'y', 'z'], 5);
                 * console.log(object.x[0].y.z);
                 * // => 5
                 */
                function set(object, path, value) {
                    return object == null ? object : baseSet(object, path, value);
                }

                /**
                 * This method is like `_.set` except that it accepts `customizer` which is
                 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
                 * path creation is handled by the method instead. The `customizer` is invoked
                 * with three arguments: (nsValue, key, nsObject).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {*} value The value to set.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = {};
                 *
                 * _.setWith(object, '[0][1]', 'a', Object);
                 * // => { '0': { '1': 'a' } }
                 */
                function setWith(object, path, value, customizer) {
                    customizer = typeof customizer == 'function' ? customizer : undefined;
                    return object == null ? object : baseSet(object, path, value, customizer);
                }

                /**
                 * Creates an array of own enumerable string keyed-value pairs for `object`
                 * which can be consumed by `_.fromPairs`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @alias entries
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the new array of key-value pairs.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.toPairs(new Foo);
                 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
                 */
                function toPairs(object) {
                    return baseToPairs(object, keys(object));
                }

                /**
                 * Creates an array of own and inherited enumerable string keyed-value pairs
                 * for `object` which can be consumed by `_.fromPairs`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @alias entriesIn
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the new array of key-value pairs.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.toPairsIn(new Foo);
                 * // => [['a', 1], ['b', 2], ['c', 1]] (iteration order is not guaranteed)
                 */
                function toPairsIn(object) {
                    return baseToPairs(object, keysIn(object));
                }

                /**
                 * An alternative to `_.reduce`; this method transforms `object` to a new
                 * `accumulator` object which is the result of running each of its own
                 * enumerable string keyed properties thru `iteratee`, with each invocation
                 * potentially mutating the `accumulator` object. The iteratee is invoked
                 * with four arguments: (accumulator, value, key, object). Iteratee functions
                 * may exit iteration early by explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.3.0
                 * @category Object
                 * @param {Array|Object} object The object to iterate over.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @param {*} [accumulator] The custom accumulator value.
                 * @returns {*} Returns the accumulated value.
                 * @example
                 *
                 * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
                 * // => [4, 9]
                 *
                 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
                 * // => { '1': ['a', 'c'], '2': ['b'] }
                 */
                function transform(object, iteratee, accumulator) {
                    var isArr = isArray(object) || isTypedArray(object);
                    iteratee = getIteratee(iteratee, 4);

                    if (accumulator == null) {
                        if (isArr || isObject(object)) {
                            var Ctor = object.constructor;
                            if (isArr) {
                                accumulator = isArray(object) ? new Ctor : [];
                            } else {
                                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                            }
                        } else {
                            accumulator = {};
                        }
                    }
                    (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
                        return iteratee(accumulator, value, index, object);
                    });
                    return accumulator;
                }

                /**
                 * Removes the property at `path` of `object`.
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to unset.
                 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
                 * _.unset(object, 'a[0].b.c');
                 * // => true
                 *
                 * console.log(object);
                 * // => { 'a': [{ 'b': {} }] };
                 *
                 * _.unset(object, ['a', '0', 'b', 'c']);
                 * // => true
                 *
                 * console.log(object);
                 * // => { 'a': [{ 'b': {} }] };
                 */
                function unset(object, path) {
                    return object == null ? true : baseUnset(object, path);
                }

                /**
                 * This method is like `_.set` except that accepts `updater` to produce the
                 * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
                 * is invoked with one argument: (value).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.6.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {Function} updater The function to produce the updated value.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                 *
                 * _.update(object, 'a[0].b.c', function(n) { return n * n; });
                 * console.log(object.a[0].b.c);
                 * // => 9
                 *
                 * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
                 * console.log(object.x[0].y.z);
                 * // => 0
                 */
                function update(object, path, updater) {
                    return object == null ? object : baseUpdate(object, path, castFunction(updater));
                }

                /**
                 * This method is like `_.update` except that it accepts `customizer` which is
                 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
                 * path creation is handled by the method instead. The `customizer` is invoked
                 * with three arguments: (nsValue, key, nsObject).
                 *
                 * **Note:** This method mutates `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.6.0
                 * @category Object
                 * @param {Object} object The object to modify.
                 * @param {Array|string} path The path of the property to set.
                 * @param {Function} updater The function to produce the updated value.
                 * @param {Function} [customizer] The function to customize assigned values.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var object = {};
                 *
                 * _.updateWith(object, '[0][1]', _.constant('a'), Object);
                 * // => { '0': { '1': 'a' } }
                 */
                function updateWith(object, path, updater, customizer) {
                    customizer = typeof customizer == 'function' ? customizer : undefined;
                    return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                }

                /**
                 * Creates an array of the own enumerable string keyed property values of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property values.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.values(new Foo);
                 * // => [1, 2] (iteration order is not guaranteed)
                 *
                 * _.values('hi');
                 * // => ['h', 'i']
                 */
                function values(object) {
                    return object ? baseValues(object, keys(object)) : [];
                }

                /**
                 * Creates an array of the own and inherited enumerable string keyed property
                 * values of `object`.
                 *
                 * **Note:** Non-object values are coerced to objects.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Object
                 * @param {Object} object The object to query.
                 * @returns {Array} Returns the array of property values.
                 * @example
                 *
                 * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                 *
                 * Foo.prototype.c = 3;
                 *
                 * _.valuesIn(new Foo);
                 * // => [1, 2, 3] (iteration order is not guaranteed)
                 */
                function valuesIn(object) {
                    return object == null ? [] : baseValues(object, keysIn(object));
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Clamps `number` within the inclusive `lower` and `upper` bounds.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Number
                 * @param {number} number The number to clamp.
                 * @param {number} [lower] The lower bound.
                 * @param {number} upper The upper bound.
                 * @returns {number} Returns the clamped number.
                 * @example
                 *
                 * _.clamp(-10, -5, 5);
                 * // => -5
                 *
                 * _.clamp(10, -5, 5);
                 * // => 5
                 */
                function clamp(number, lower, upper) {
                    if (upper === undefined) {
                        upper = lower;
                        lower = undefined;
                    }
                    if (upper !== undefined) {
                        upper = toNumber(upper);
                        upper = upper === upper ? upper : 0;
                    }
                    if (lower !== undefined) {
                        lower = toNumber(lower);
                        lower = lower === lower ? lower : 0;
                    }
                    return baseClamp(toNumber(number), lower, upper);
                }

                /**
                 * Checks if `n` is between `start` and up to but not including, `end`. If
                 * `end` is not specified, it's set to `start` with `start` then set to `0`.
                 * If `start` is greater than `end` the params are swapped to support
                 * negative ranges.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.3.0
                 * @category Number
                 * @param {number} number The number to check.
                 * @param {number} [start=0] The start of the range.
                 * @param {number} end The end of the range.
                 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
                 * @example
                 *
                 * _.inRange(3, 2, 4);
                 * // => true
                 *
                 * _.inRange(4, 8);
                 * // => true
                 *
                 * _.inRange(4, 2);
                 * // => false
                 *
                 * _.inRange(2, 2);
                 * // => false
                 *
                 * _.inRange(1.2, 2);
                 * // => true
                 *
                 * _.inRange(5.2, 4);
                 * // => false
                 *
                 * _.inRange(-3, -2, -6);
                 * // => true
                 */
                function inRange(number, start, end) {
                    start = toNumber(start) || 0;
                    if (end === undefined) {
                        end = start;
                        start = 0;
                    } else {
                        end = toNumber(end) || 0;
                    }
                    number = toNumber(number);
                    return baseInRange(number, start, end);
                }

                /**
                 * Produces a random number between the inclusive `lower` and `upper` bounds.
                 * If only one argument is provided a number between `0` and the given number
                 * is returned. If `floating` is `true`, or either `lower` or `upper` are
                 * floats, a floating-point number is returned instead of an integer.
                 *
                 * **Note:** JavaScript follows the IEEE-754 standard for resolving
                 * floating-point values which can produce unexpected results.
                 *
                 * @static
                 * @memberOf _
                 * @since 0.7.0
                 * @category Number
                 * @param {number} [lower=0] The lower bound.
                 * @param {number} [upper=1] The upper bound.
                 * @param {boolean} [floating] Specify returning a floating-point number.
                 * @returns {number} Returns the random number.
                 * @example
                 *
                 * _.random(0, 5);
                 * // => an integer between 0 and 5
                 *
                 * _.random(5);
                 * // => also an integer between 0 and 5
                 *
                 * _.random(5, true);
                 * // => a floating-point number between 0 and 5
                 *
                 * _.random(1.2, 5.2);
                 * // => a floating-point number between 1.2 and 5.2
                 */
                function random(lower, upper, floating) {
                    if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                        upper = floating = undefined;
                    }
                    if (floating === undefined) {
                        if (typeof upper == 'boolean') {
                            floating = upper;
                            upper = undefined;
                        }
                        else if (typeof lower == 'boolean') {
                            floating = lower;
                            lower = undefined;
                        }
                    }
                    if (lower === undefined && upper === undefined) {
                        lower = 0;
                        upper = 1;
                    }
                    else {
                        lower = toNumber(lower) || 0;
                        if (upper === undefined) {
                            upper = lower;
                            lower = 0;
                        } else {
                            upper = toNumber(upper) || 0;
                        }
                    }
                    if (lower > upper) {
                        var temp = lower;
                        lower = upper;
                        upper = temp;
                    }
                    if (floating || lower % 1 || upper % 1) {
                        var rand = nativeRandom();
                        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
                    }
                    return baseRandom(lower, upper);
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the camel cased string.
                 * @example
                 *
                 * _.camelCase('Foo Bar');
                 * // => 'fooBar'
                 *
                 * _.camelCase('--foo-bar--');
                 * // => 'fooBar'
                 *
                 * _.camelCase('__FOO_BAR__');
                 * // => 'fooBar'
                 */
                var camelCase = createCompounder(function(result, word, index) {
                    word = word.toLowerCase();
                    return result + (index ? capitalize(word) : word);
                });

                /**
                 * Converts the first character of `string` to upper case and the remaining
                 * to lower case.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to capitalize.
                 * @returns {string} Returns the capitalized string.
                 * @example
                 *
                 * _.capitalize('FRED');
                 * // => 'Fred'
                 */
                function capitalize(string) {
                    return upperFirst(toString(string).toLowerCase());
                }

                /**
                 * Deburrs `string` by converting
                 * [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
                 * to basic latin letters and removing
                 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to deburr.
                 * @returns {string} Returns the deburred string.
                 * @example
                 *
                 * _.deburr('dj vu');
                 * // => 'deja vu'
                 */
                function deburr(string) {
                    string = toString(string);
                    return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
                }

                /**
                 * Checks if `string` ends with the given target string.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to search.
                 * @param {string} [target] The string to search for.
                 * @param {number} [position=string.length] The position to search from.
                 * @returns {boolean} Returns `true` if `string` ends with `target`,
                 *  else `false`.
                 * @example
                 *
                 * _.endsWith('abc', 'c');
                 * // => true
                 *
                 * _.endsWith('abc', 'b');
                 * // => false
                 *
                 * _.endsWith('abc', 'b', 2);
                 * // => true
                 */
                function endsWith(string, target, position) {
                    string = toString(string);
                    target = typeof target == 'string' ? target : (target + '');

                    var length = string.length;
                    position = position === undefined
                        ? length
                        : baseClamp(toInteger(position), 0, length);

                    position -= target.length;
                    return position >= 0 && string.indexOf(target, position) == position;
                }

                /**
                 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
                 * their corresponding HTML entities.
                 *
                 * **Note:** No other characters are escaped. To escape additional
                 * characters use a third-party library like [_he_](https://mths.be/he).
                 *
                 * Though the ">" character is escaped for symmetry, characters like
                 * ">" and "/" don't need escaping in HTML and have no special meaning
                 * unless they're part of a tag or unquoted attribute value. See
                 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
                 * (under "semi-related fun fact") for more details.
                 *
                 * Backticks are escaped because in IE < 9, they can break out of
                 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
                 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
                 * [#133](https://html5sec.org/#133) of the
                 * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
                 *
                 * When working with HTML you should always
                 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
                 * XSS vectors.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category String
                 * @param {string} [string=''] The string to escape.
                 * @returns {string} Returns the escaped string.
                 * @example
                 *
                 * _.escape('fred, barney, & pebbles');
                 * // => 'fred, barney, &amp; pebbles'
                 */
                function escape(string) {
                    string = toString(string);
                    return (string && reHasUnescapedHtml.test(string))
                        ? string.replace(reUnescapedHtml, escapeHtmlChar)
                        : string;
                }

                /**
                 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
                 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to escape.
                 * @returns {string} Returns the escaped string.
                 * @example
                 *
                 * _.escapeRegExp('[lodash](https://lodash.com/)');
                 * // => '\[lodash\]\(https://lodash\.com/\)'
                 */
                function escapeRegExp(string) {
                    string = toString(string);
                    return (string && reHasRegExpChar.test(string))
                        ? string.replace(reRegExpChar, '\\$&')
                        : string;
                }

                /**
                 * Converts `string` to
                 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the kebab cased string.
                 * @example
                 *
                 * _.kebabCase('Foo Bar');
                 * // => 'foo-bar'
                 *
                 * _.kebabCase('fooBar');
                 * // => 'foo-bar'
                 *
                 * _.kebabCase('__FOO_BAR__');
                 * // => 'foo-bar'
                 */
                var kebabCase = createCompounder(function(result, word, index) {
                    return result + (index ? '-' : '') + word.toLowerCase();
                });

                /**
                 * Converts `string`, as space separated words, to lower case.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the lower cased string.
                 * @example
                 *
                 * _.lowerCase('--Foo-Bar--');
                 * // => 'foo bar'
                 *
                 * _.lowerCase('fooBar');
                 * // => 'foo bar'
                 *
                 * _.lowerCase('__FOO_BAR__');
                 * // => 'foo bar'
                 */
                var lowerCase = createCompounder(function(result, word, index) {
                    return result + (index ? ' ' : '') + word.toLowerCase();
                });

                /**
                 * Converts the first character of `string` to lower case.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the converted string.
                 * @example
                 *
                 * _.lowerFirst('Fred');
                 * // => 'fred'
                 *
                 * _.lowerFirst('FRED');
                 * // => 'fRED'
                 */
                var lowerFirst = createCaseFirst('toLowerCase');

                /**
                 * Pads `string` on the left and right sides if it's shorter than `length`.
                 * Padding characters are truncated if they can't be evenly divided by `length`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to pad.
                 * @param {number} [length=0] The padding length.
                 * @param {string} [chars=' '] The string used as padding.
                 * @returns {string} Returns the padded string.
                 * @example
                 *
                 * _.pad('abc', 8);
                 * // => '  abc   '
                 *
                 * _.pad('abc', 8, '_-');
                 * // => '_-abc_-_'
                 *
                 * _.pad('abc', 3);
                 * // => 'abc'
                 */
                function pad(string, length, chars) {
                    string = toString(string);
                    length = toInteger(length);

                    var strLength = length ? stringSize(string) : 0;
                    if (!length || strLength >= length) {
                        return string;
                    }
                    var mid = (length - strLength) / 2;
                    return (
                        createPadding(nativeFloor(mid), chars) +
                        string +
                        createPadding(nativeCeil(mid), chars)
                    );
                }

                /**
                 * Pads `string` on the right side if it's shorter than `length`. Padding
                 * characters are truncated if they exceed `length`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to pad.
                 * @param {number} [length=0] The padding length.
                 * @param {string} [chars=' '] The string used as padding.
                 * @returns {string} Returns the padded string.
                 * @example
                 *
                 * _.padEnd('abc', 6);
                 * // => 'abc   '
                 *
                 * _.padEnd('abc', 6, '_-');
                 * // => 'abc_-_'
                 *
                 * _.padEnd('abc', 3);
                 * // => 'abc'
                 */
                function padEnd(string, length, chars) {
                    string = toString(string);
                    length = toInteger(length);

                    var strLength = length ? stringSize(string) : 0;
                    return (length && strLength < length)
                        ? (string + createPadding(length - strLength, chars))
                        : string;
                }

                /**
                 * Pads `string` on the left side if it's shorter than `length`. Padding
                 * characters are truncated if they exceed `length`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to pad.
                 * @param {number} [length=0] The padding length.
                 * @param {string} [chars=' '] The string used as padding.
                 * @returns {string} Returns the padded string.
                 * @example
                 *
                 * _.padStart('abc', 6);
                 * // => '   abc'
                 *
                 * _.padStart('abc', 6, '_-');
                 * // => '_-_abc'
                 *
                 * _.padStart('abc', 3);
                 * // => 'abc'
                 */
                function padStart(string, length, chars) {
                    string = toString(string);
                    length = toInteger(length);

                    var strLength = length ? stringSize(string) : 0;
                    return (length && strLength < length)
                        ? (createPadding(length - strLength, chars) + string)
                        : string;
                }

                /**
                 * Converts `string` to an integer of the specified radix. If `radix` is
                 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
                 * hexadecimal, in which case a `radix` of `16` is used.
                 *
                 * **Note:** This method aligns with the
                 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
                 *
                 * @static
                 * @memberOf _
                 * @since 1.1.0
                 * @category String
                 * @param {string} string The string to convert.
                 * @param {number} [radix=10] The radix to interpret `value` by.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {number} Returns the converted integer.
                 * @example
                 *
                 * _.parseInt('08');
                 * // => 8
                 *
                 * _.map(['6', '08', '10'], _.parseInt);
                 * // => [6, 8, 10]
                 */
                function parseInt(string, radix, guard) {
                    // Chrome fails to trim leading <BOM> whitespace characters.
                    // See https://bugs.chromium.org/p/v8/issues/detail?id=3109 for more details.
                    if (guard || radix == null) {
                        radix = 0;
                    } else if (radix) {
                        radix = +radix;
                    }
                    string = toString(string).replace(reTrim, '');
                    return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
                }

                /**
                 * Repeats the given string `n` times.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to repeat.
                 * @param {number} [n=1] The number of times to repeat the string.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {string} Returns the repeated string.
                 * @example
                 *
                 * _.repeat('*', 3);
                 * // => '***'
                 *
                 * _.repeat('abc', 2);
                 * // => 'abcabc'
                 *
                 * _.repeat('abc', 0);
                 * // => ''
                 */
                function repeat(string, n, guard) {
                    if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
                        n = 1;
                    } else {
                        n = toInteger(n);
                    }
                    return baseRepeat(toString(string), n);
                }

                /**
                 * Replaces matches for `pattern` in `string` with `replacement`.
                 *
                 * **Note:** This method is based on
                 * [`String#replace`](https://mdn.io/String/replace).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to modify.
                 * @param {RegExp|string} pattern The pattern to replace.
                 * @param {Function|string} replacement The match replacement.
                 * @returns {string} Returns the modified string.
                 * @example
                 *
                 * _.replace('Hi Fred', 'Fred', 'Barney');
                 * // => 'Hi Barney'
                 */
                function replace() {
                    var args = arguments,
                        string = toString(args[0]);

                    return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2]);
                }

                /**
                 * Converts `string` to
                 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the snake cased string.
                 * @example
                 *
                 * _.snakeCase('Foo Bar');
                 * // => 'foo_bar'
                 *
                 * _.snakeCase('fooBar');
                 * // => 'foo_bar'
                 *
                 * _.snakeCase('--FOO-BAR--');
                 * // => 'foo_bar'
                 */
                var snakeCase = createCompounder(function(result, word, index) {
                    return result + (index ? '_' : '') + word.toLowerCase();
                });

                /**
                 * Splits `string` by `separator`.
                 *
                 * **Note:** This method is based on
                 * [`String#split`](https://mdn.io/String/split).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to split.
                 * @param {RegExp|string} separator The separator pattern to split by.
                 * @param {number} [limit] The length to truncate results to.
                 * @returns {Array} Returns the new array of string segments.
                 * @example
                 *
                 * _.split('a-b-c', '-', 2);
                 * // => ['a', 'b']
                 */
                function split(string, separator, limit) {
                    if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                        separator = limit = undefined;
                    }
                    limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                    if (!limit) {
                        return [];
                    }
                    string = toString(string);
                    if (string && (
                            typeof separator == 'string' ||
                            (separator != null && !isRegExp(separator))
                        )) {
                        separator += '';
                        if (separator == '' && reHasComplexSymbol.test(string)) {
                            return castSlice(stringToArray(string), 0, limit);
                        }
                    }
                    return nativeSplit.call(string, separator, limit);
                }

                /**
                 * Converts `string` to
                 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
                 *
                 * @static
                 * @memberOf _
                 * @since 3.1.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the start cased string.
                 * @example
                 *
                 * _.startCase('--foo-bar--');
                 * // => 'Foo Bar'
                 *
                 * _.startCase('fooBar');
                 * // => 'Foo Bar'
                 *
                 * _.startCase('__FOO_BAR__');
                 * // => 'FOO BAR'
                 */
                var startCase = createCompounder(function(result, word, index) {
                    return result + (index ? ' ' : '') + upperFirst(word);
                });

                /**
                 * Checks if `string` starts with the given target string.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to search.
                 * @param {string} [target] The string to search for.
                 * @param {number} [position=0] The position to search from.
                 * @returns {boolean} Returns `true` if `string` starts with `target`,
                 *  else `false`.
                 * @example
                 *
                 * _.startsWith('abc', 'a');
                 * // => true
                 *
                 * _.startsWith('abc', 'b');
                 * // => false
                 *
                 * _.startsWith('abc', 'b', 1);
                 * // => true
                 */
                function startsWith(string, target, position) {
                    string = toString(string);
                    position = baseClamp(toInteger(position), 0, string.length);
                    return string.lastIndexOf(target, position) == position;
                }

                /**
                 * Creates a compiled template function that can interpolate data properties
                 * in "interpolate" delimiters, HTML-escape interpolated data properties in
                 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
                 * properties may be accessed as free variables in the template. If a setting
                 * object is given, it takes precedence over `_.templateSettings` values.
                 *
                 * **Note:** In the development build `_.template` utilizes
                 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
                 * for easier debugging.
                 *
                 * For more information on precompiling templates see
                 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
                 *
                 * For more information on Chrome extension sandboxes see
                 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category String
                 * @param {string} [string=''] The template string.
                 * @param {Object} [options={}] The options object.
                 * @param {RegExp} [options.escape=_.templateSettings.escape]
                 *  The HTML "escape" delimiter.
                 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
                 *  The "evaluate" delimiter.
                 * @param {Object} [options.imports=_.templateSettings.imports]
                 *  An object to import into the template as free variables.
                 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
                 *  The "interpolate" delimiter.
                 * @param {string} [options.sourceURL='lodash.templateSources[n]']
                 *  The sourceURL of the compiled template.
                 * @param {string} [options.variable='obj']
                 *  The data object variable name.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Function} Returns the compiled template function.
                 * @example
                 *
                 * // Use the "interpolate" delimiter to create a compiled template.
                 * var compiled = _.template('hello <%= user %>!');
                 * compiled({ 'user': 'fred' });
                 * // => 'hello fred!'
                 *
                 * // Use the HTML "escape" delimiter to escape data property values.
                 * var compiled = _.template('<b><%- value %></b>');
                 * compiled({ 'value': '<script>' });
                 * // => '<b>&lt;script&gt;</b>'
                 *
                 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
                 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
                 * compiled({ 'users': ['fred', 'barney'] });
                 * // => '<li>fred</li><li>barney</li>'
                 *
                 * // Use the internal `print` function in "evaluate" delimiters.
                 * var compiled = _.template('<% print("hello " + user); %>!');
                 * compiled({ 'user': 'barney' });
                 * // => 'hello barney!'
                 *
                 * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
                 * var compiled = _.template('hello ${ user }!');
                 * compiled({ 'user': 'pebbles' });
                 * // => 'hello pebbles!'
                 *
                 * // Use custom template delimiters.
                 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
                 * var compiled = _.template('hello {{ user }}!');
                 * compiled({ 'user': 'mustache' });
                 * // => 'hello mustache!'
                 *
                 * // Use backslashes to treat delimiters as plain text.
                 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
                 * compiled({ 'value': 'ignored' });
                 * // => '<%- value %>'
                 *
                 * // Use the `imports` option to import `jQuery` as `jq`.
                 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
                 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
                 * compiled({ 'users': ['fred', 'barney'] });
                 * // => '<li>fred</li><li>barney</li>'
                 *
                 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
                 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
                 * compiled(data);
                 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
                 *
                 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
                 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
                 * compiled.source;
                 * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
                 *
                 * // Use the `source` property to inline compiled templates for meaningful
                 * // line numbers in error messages and stack traces.
                 * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                 *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
                 * ');
                 */
                function template(string, options, guard) {
                    // Based on John Resig's `tmpl` implementation
                    // (http://ejohn.org/blog/javascript-micro-templating/)
                    // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                    var settings = lodash.templateSettings;

                    if (guard && isIterateeCall(string, options, guard)) {
                        options = undefined;
                    }
                    string = toString(string);
                    options = assignInWith({}, options, settings, assignInDefaults);

                    var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
                        importsKeys = keys(imports),
                        importsValues = baseValues(imports, importsKeys);

                    var isEscaping,
                        isEvaluating,
                        index = 0,
                        interpolate = options.interpolate || reNoMatch,
                        source = "__p += '";

                    // Compile the regexp to match each delimiter.
                    var reDelimiters = RegExp(
                        (options.escape || reNoMatch).source + '|' +
                        interpolate.source + '|' +
                        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                        (options.evaluate || reNoMatch).source + '|$'
                        , 'g');

                    // Use a sourceURL for easier debugging.
                    var sourceURL = '//# sourceURL=' +
                        ('sourceURL' in options
                                ? options.sourceURL
                                : ('lodash.templateSources[' + (++templateCounter) + ']')
                        ) + '\n';

                    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                        interpolateValue || (interpolateValue = esTemplateValue);

                        // Escape characters that can't be included in string literals.
                        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                        // Replace delimiters with snippets.
                        if (escapeValue) {
                            isEscaping = true;
                            source += "' +\n__e(" + escapeValue + ") +\n'";
                        }
                        if (evaluateValue) {
                            isEvaluating = true;
                            source += "';\n" + evaluateValue + ";\n__p += '";
                        }
                        if (interpolateValue) {
                            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                        }
                        index = offset + match.length;

                        // The JS engine embedded in Adobe products needs `match` returned in
                        // order to produce the correct `offset` value.
                        return match;
                    });

                    source += "';\n";

                    // If `variable` is not specified wrap a with-statement around the generated
                    // code to add the data object to the top of the scope chain.
                    var variable = options.variable;
                    if (!variable) {
                        source = 'with (obj) {\n' + source + '\n}\n';
                    }
                    // Cleanup code by stripping empty strings.
                    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                        .replace(reEmptyStringMiddle, '$1')
                        .replace(reEmptyStringTrailing, '$1;');

                    // Frame code as the function body.
                    source = 'function(' + (variable || 'obj') + ') {\n' +
                        (variable
                                ? ''
                                : 'obj || (obj = {});\n'
                        ) +
                        "var __t, __p = ''" +
                        (isEscaping
                                ? ', __e = _.escape'
                                : ''
                        ) +
                        (isEvaluating
                                ? ', __j = Array.prototype.join;\n' +
                            "function print() { __p += __j.call(arguments, '') }\n"
                                : ';\n'
                        ) +
                        source +
                        'return __p\n}';

                    var result = attempt(function() {
                        return Function(importsKeys, sourceURL + 'return ' + source)
                            .apply(undefined, importsValues);
                    });

                    // Provide the compiled function's source by its `toString` method or
                    // the `source` property as a convenience for inlining compiled templates.
                    result.source = source;
                    if (isError(result)) {
                        throw result;
                    }
                    return result;
                }

                /**
                 * Converts `string`, as a whole, to lower case just like
                 * [String#toLowerCase](https://mdn.io/toLowerCase).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the lower cased string.
                 * @example
                 *
                 * _.toLower('--Foo-Bar--');
                 * // => '--foo-bar--'
                 *
                 * _.toLower('fooBar');
                 * // => 'foobar'
                 *
                 * _.toLower('__FOO_BAR__');
                 * // => '__foo_bar__'
                 */
                function toLower(value) {
                    return toString(value).toLowerCase();
                }

                /**
                 * Converts `string`, as a whole, to upper case just like
                 * [String#toUpperCase](https://mdn.io/toUpperCase).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the upper cased string.
                 * @example
                 *
                 * _.toUpper('--foo-bar--');
                 * // => '--FOO-BAR--'
                 *
                 * _.toUpper('fooBar');
                 * // => 'FOOBAR'
                 *
                 * _.toUpper('__foo_bar__');
                 * // => '__FOO_BAR__'
                 */
                function toUpper(value) {
                    return toString(value).toUpperCase();
                }

                /**
                 * Removes leading and trailing whitespace or specified characters from `string`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to trim.
                 * @param {string} [chars=whitespace] The characters to trim.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {string} Returns the trimmed string.
                 * @example
                 *
                 * _.trim('  abc  ');
                 * // => 'abc'
                 *
                 * _.trim('-_-abc-_-', '_-');
                 * // => 'abc'
                 *
                 * _.map(['  foo  ', '  bar  '], _.trim);
                 * // => ['foo', 'bar']
                 */
                function trim(string, chars, guard) {
                    string = toString(string);
                    if (!string) {
                        return string;
                    }
                    if (guard || chars === undefined) {
                        return string.replace(reTrim, '');
                    }
                    if (!(chars += '')) {
                        return string;
                    }
                    var strSymbols = stringToArray(string),
                        chrSymbols = stringToArray(chars),
                        start = charsStartIndex(strSymbols, chrSymbols),
                        end = charsEndIndex(strSymbols, chrSymbols) + 1;

                    return castSlice(strSymbols, start, end).join('');
                }

                /**
                 * Removes trailing whitespace or specified characters from `string`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to trim.
                 * @param {string} [chars=whitespace] The characters to trim.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {string} Returns the trimmed string.
                 * @example
                 *
                 * _.trimEnd('  abc  ');
                 * // => '  abc'
                 *
                 * _.trimEnd('-_-abc-_-', '_-');
                 * // => '-_-abc'
                 */
                function trimEnd(string, chars, guard) {
                    string = toString(string);
                    if (!string) {
                        return string;
                    }
                    if (guard || chars === undefined) {
                        return string.replace(reTrimEnd, '');
                    }
                    if (!(chars += '')) {
                        return string;
                    }
                    var strSymbols = stringToArray(string),
                        end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

                    return castSlice(strSymbols, 0, end).join('');
                }

                /**
                 * Removes leading whitespace or specified characters from `string`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to trim.
                 * @param {string} [chars=whitespace] The characters to trim.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {string} Returns the trimmed string.
                 * @example
                 *
                 * _.trimStart('  abc  ');
                 * // => 'abc  '
                 *
                 * _.trimStart('-_-abc-_-', '_-');
                 * // => 'abc-_-'
                 */
                function trimStart(string, chars, guard) {
                    string = toString(string);
                    if (!string) {
                        return string;
                    }
                    if (guard || chars === undefined) {
                        return string.replace(reTrimStart, '');
                    }
                    if (!(chars += '')) {
                        return string;
                    }
                    var strSymbols = stringToArray(string),
                        start = charsStartIndex(strSymbols, stringToArray(chars));

                    return castSlice(strSymbols, start).join('');
                }

                /**
                 * Truncates `string` if it's longer than the given maximum string length.
                 * The last characters of the truncated string are replaced with the omission
                 * string which defaults to "...".
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to truncate.
                 * @param {Object} [options={}] The options object.
                 * @param {number} [options.length=30] The maximum string length.
                 * @param {string} [options.omission='...'] The string to indicate text is omitted.
                 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
                 * @returns {string} Returns the truncated string.
                 * @example
                 *
                 * _.truncate('hi-diddly-ho there, neighborino');
                 * // => 'hi-diddly-ho there, neighbo...'
                 *
                 * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
                 * // => 'hi-diddly-ho there,...'
                 *
                 * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
                 * // => 'hi-diddly-ho there...'
                 *
                 * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
                 * // => 'hi-diddly-ho there, neig [...]'
                 */
                function truncate(string, options) {
                    var length = DEFAULT_TRUNC_LENGTH,
                        omission = DEFAULT_TRUNC_OMISSION;

                    if (isObject(options)) {
                        var separator = 'separator' in options ? options.separator : separator;
                        length = 'length' in options ? toInteger(options.length) : length;
                        omission = 'omission' in options ? toString(options.omission) : omission;
                    }
                    string = toString(string);

                    var strLength = string.length;
                    if (reHasComplexSymbol.test(string)) {
                        var strSymbols = stringToArray(string);
                        strLength = strSymbols.length;
                    }
                    if (length >= strLength) {
                        return string;
                    }
                    var end = length - stringSize(omission);
                    if (end < 1) {
                        return omission;
                    }
                    var result = strSymbols
                        ? castSlice(strSymbols, 0, end).join('')
                        : string.slice(0, end);

                    if (separator === undefined) {
                        return result + omission;
                    }
                    if (strSymbols) {
                        end += (result.length - end);
                    }
                    if (isRegExp(separator)) {
                        if (string.slice(end).search(separator)) {
                            var match,
                                substring = result;

                            if (!separator.global) {
                                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                            }
                            separator.lastIndex = 0;
                            while ((match = separator.exec(substring))) {
                                var newEnd = match.index;
                            }
                            result = result.slice(0, newEnd === undefined ? end : newEnd);
                        }
                    } else if (string.indexOf(separator, end) != end) {
                        var index = result.lastIndexOf(separator);
                        if (index > -1) {
                            result = result.slice(0, index);
                        }
                    }
                    return result + omission;
                }

                /**
                 * The inverse of `_.escape`; this method converts the HTML entities
                 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
                 * their corresponding characters.
                 *
                 * **Note:** No other HTML entities are unescaped. To unescape additional
                 * HTML entities use a third-party library like [_he_](https://mths.be/he).
                 *
                 * @static
                 * @memberOf _
                 * @since 0.6.0
                 * @category String
                 * @param {string} [string=''] The string to unescape.
                 * @returns {string} Returns the unescaped string.
                 * @example
                 *
                 * _.unescape('fred, barney, &amp; pebbles');
                 * // => 'fred, barney, & pebbles'
                 */
                function unescape(string) {
                    string = toString(string);
                    return (string && reHasEscapedHtml.test(string))
                        ? string.replace(reEscapedHtml, unescapeHtmlChar)
                        : string;
                }

                /**
                 * Converts `string`, as space separated words, to upper case.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the upper cased string.
                 * @example
                 *
                 * _.upperCase('--foo-bar');
                 * // => 'FOO BAR'
                 *
                 * _.upperCase('fooBar');
                 * // => 'FOO BAR'
                 *
                 * _.upperCase('__foo_bar__');
                 * // => 'FOO BAR'
                 */
                var upperCase = createCompounder(function(result, word, index) {
                    return result + (index ? ' ' : '') + word.toUpperCase();
                });

                /**
                 * Converts the first character of `string` to upper case.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category String
                 * @param {string} [string=''] The string to convert.
                 * @returns {string} Returns the converted string.
                 * @example
                 *
                 * _.upperFirst('fred');
                 * // => 'Fred'
                 *
                 * _.upperFirst('FRED');
                 * // => 'FRED'
                 */
                var upperFirst = createCaseFirst('toUpperCase');

                /**
                 * Splits `string` into an array of its words.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category String
                 * @param {string} [string=''] The string to inspect.
                 * @param {RegExp|string} [pattern] The pattern to match words.
                 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                 * @returns {Array} Returns the words of `string`.
                 * @example
                 *
                 * _.words('fred, barney, & pebbles');
                 * // => ['fred', 'barney', 'pebbles']
                 *
                 * _.words('fred, barney, & pebbles', /[^, ]+/g);
                 * // => ['fred', 'barney', '&', 'pebbles']
                 */
                function words(string, pattern, guard) {
                    string = toString(string);
                    pattern = guard ? undefined : pattern;

                    if (pattern === undefined) {
                        pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
                    }
                    return string.match(pattern) || [];
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Attempts to invoke `func`, returning either the result or the caught error
                 * object. Any additional arguments are provided to `func` when it's invoked.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Util
                 * @param {Function} func The function to attempt.
                 * @param {...*} [args] The arguments to invoke `func` with.
                 * @returns {*} Returns the `func` result or error object.
                 * @example
                 *
                 * // Avoid throwing errors for invalid selectors.
                 * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
                 *
                 * if (_.isError(elements)) {
     *   elements = [];
     * }
                 */
                var attempt = rest(function(func, args) {
                    try {
                        return apply(func, undefined, args);
                    } catch (e) {
                        return isError(e) ? e : new Error(e);
                    }
                });

                /**
                 * Binds methods of an object to the object itself, overwriting the existing
                 * method.
                 *
                 * **Note:** This method doesn't set the "length" property of bound functions.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {Object} object The object to bind and assign the bound methods to.
                 * @param {...(string|string[])} methodNames The object method names to bind.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
                 *
                 * _.bindAll(view, 'onClick');
                 * jQuery(element).on('click', view.onClick);
                 * // => Logs 'clicked docs' when clicked.
                 */
                var bindAll = rest(function(object, methodNames) {
                    arrayEach(baseFlatten(methodNames, 1), function(key) {
                        object[key] = bind(object[key], object);
                    });
                    return object;
                });

                /**
                 * Creates a function that iterates over `pairs` and invokes the corresponding
                 * function of the first predicate to return truthy. The predicate-function
                 * pairs are invoked with the `this` binding and arguments of the created
                 * function.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {Array} pairs The predicate-function pairs.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var func = _.cond([
                 *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
                 *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
                 *   [_.constant(true),                _.constant('no match')]
                 * ]);
                 *
                 * func({ 'a': 1, 'b': 2 });
                 * // => 'matches A'
                 *
                 * func({ 'a': 0, 'b': 1 });
                 * // => 'matches B'
                 *
                 * func({ 'a': '1', 'b': '2' });
                 * // => 'no match'
                 */
                function cond(pairs) {
                    var length = pairs ? pairs.length : 0,
                        toIteratee = getIteratee();

                    pairs = !length ? [] : arrayMap(pairs, function(pair) {
                        if (typeof pair[1] != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return [toIteratee(pair[0]), pair[1]];
                    });

                    return rest(function(args) {
                        var index = -1;
                        while (++index < length) {
                            var pair = pairs[index];
                            if (apply(pair[0], this, args)) {
                                return apply(pair[1], this, args);
                            }
                        }
                    });
                }

                /**
                 * Creates a function that invokes the predicate properties of `source` with
                 * the corresponding property values of a given object, returning `true` if
                 * all predicates return truthy, else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {Object} source The object of property predicates to conform to.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36 },
                 *   { 'user': 'fred',   'age': 40 }
                 * ];
                 *
                 * _.filter(users, _.conforms({ 'age': _.partial(_.gt, _, 38) }));
                 * // => [{ 'user': 'fred', 'age': 40 }]
                 */
                function conforms(source) {
                    return baseConforms(baseClone(source, true));
                }

                /**
                 * Creates a function that returns `value`.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Util
                 * @param {*} value The value to return from the new function.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var object = { 'user': 'fred' };
                 * var getter = _.constant(object);
                 *
                 * getter() === object;
                 * // => true
                 */
                function constant(value) {
                    return function() {
                        return value;
                    };
                }

                /**
                 * Creates a function that returns the result of invoking the given functions
                 * with the `this` binding of the created function, where each successive
                 * invocation is supplied the return value of the previous.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Util
                 * @param {...(Function|Function[])} [funcs] Functions to invoke.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * function square(n) {
     *   return n * n;
     * }
                 *
                 * var addSquare = _.flow(_.add, square);
                 * addSquare(1, 2);
                 * // => 9
                 */
                var flow = createFlow();

                /**
                 * This method is like `_.flow` except that it creates a function that
                 * invokes the given functions from right to left.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {...(Function|Function[])} [funcs] Functions to invoke.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * function square(n) {
     *   return n * n;
     * }
                 *
                 * var addSquare = _.flowRight(square, _.add);
                 * addSquare(1, 2);
                 * // => 9
                 */
                var flowRight = createFlow(true);

                /**
                 * This method returns the first argument given to it.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {*} value Any value.
                 * @returns {*} Returns `value`.
                 * @example
                 *
                 * var object = { 'user': 'fred' };
                 *
                 * _.identity(object) === object;
                 * // => true
                 */
                function identity(value) {
                    return value;
                }

                /**
                 * Creates a function that invokes `func` with the arguments of the created
                 * function. If `func` is a property name, the created function returns the
                 * property value for a given element. If `func` is an array or object, the
                 * created function returns `true` for elements that contain the equivalent
                 * source properties, otherwise it returns `false`.
                 *
                 * @static
                 * @since 4.0.0
                 * @memberOf _
                 * @category Util
                 * @param {*} [func=_.identity] The value to convert to a callback.
                 * @returns {Function} Returns the callback.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': true },
                 *   { 'user': 'fred',   'age': 40, 'active': false }
                 * ];
                 *
                 * // The `_.matches` iteratee shorthand.
                 * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
                 * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
                 *
                 * // The `_.matchesProperty` iteratee shorthand.
                 * _.filter(users, _.iteratee(['user', 'fred']));
                 * // => [{ 'user': 'fred', 'age': 40 }]
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.map(users, _.iteratee('user'));
                 * // => ['barney', 'fred']
                 *
                 * // Create custom iteratee shorthands.
                 * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
                 *
                 * _.filter(['abc', 'def'], /ef/);
                 * // => ['def']
                 */
                function iteratee(func) {
                    return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
                }

                /**
                 * Creates a function that performs a partial deep comparison between a given
                 * object and `source`, returning `true` if the given object has equivalent
                 * property values, else `false`. The created function is equivalent to
                 * `_.isMatch` with a `source` partially applied.
                 *
                 * **Note:** This method supports comparing the same values as `_.isEqual`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Util
                 * @param {Object} source The object of property values to match.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney', 'age': 36, 'active': true },
                 *   { 'user': 'fred',   'age': 40, 'active': false }
                 * ];
                 *
                 * _.filter(users, _.matches({ 'age': 40, 'active': false }));
                 * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
                 */
                function matches(source) {
                    return baseMatches(baseClone(source, true));
                }

                /**
                 * Creates a function that performs a partial deep comparison between the
                 * value at `path` of a given object to `srcValue`, returning `true` if the
                 * object value is equivalent, else `false`.
                 *
                 * **Note:** This method supports comparing the same values as `_.isEqual`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.2.0
                 * @category Util
                 * @param {Array|string} path The path of the property to get.
                 * @param {*} srcValue The value to match.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var users = [
                 *   { 'user': 'barney' },
                 *   { 'user': 'fred' }
                 * ];
                 *
                 * _.find(users, _.matchesProperty('user', 'fred'));
                 * // => { 'user': 'fred' }
                 */
                function matchesProperty(path, srcValue) {
                    return baseMatchesProperty(path, baseClone(srcValue, true));
                }

                /**
                 * Creates a function that invokes the method at `path` of a given object.
                 * Any additional arguments are provided to the invoked method.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Util
                 * @param {Array|string} path The path of the method to invoke.
                 * @param {...*} [args] The arguments to invoke the method with.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': { 'b': _.constant(2) } },
                 *   { 'a': { 'b': _.constant(1) } }
                 * ];
                 *
                 * _.map(objects, _.method('a.b'));
                 * // => [2, 1]
                 *
                 * _.map(objects, _.method(['a', 'b']));
                 * // => [2, 1]
                 */
                var method = rest(function(path, args) {
                    return function(object) {
                        return baseInvoke(object, path, args);
                    };
                });

                /**
                 * The opposite of `_.method`; this method creates a function that invokes
                 * the method at a given path of `object`. Any additional arguments are
                 * provided to the invoked method.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.7.0
                 * @category Util
                 * @param {Object} object The object to query.
                 * @param {...*} [args] The arguments to invoke the method with.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var array = _.times(3, _.constant),
                 *     object = { 'a': array, 'b': array, 'c': array };
                 *
                 * _.map(['a[2]', 'c[0]'], _.methodOf(object));
                 * // => [2, 0]
                 *
                 * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
                 * // => [2, 0]
                 */
                var methodOf = rest(function(object, args) {
                    return function(path) {
                        return baseInvoke(object, path, args);
                    };
                });

                /**
                 * Adds all own enumerable string keyed function properties of a source
                 * object to the destination object. If `object` is a function, then methods
                 * are added to its prototype as well.
                 *
                 * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
                 * avoid conflicts caused by modifying the original.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {Function|Object} [object=lodash] The destination object.
                 * @param {Object} source The object of functions to add.
                 * @param {Object} [options={}] The options object.
                 * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
                 * @returns {Function|Object} Returns `object`.
                 * @example
                 *
                 * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
                 *
                 * _.mixin({ 'vowels': vowels });
                 * _.vowels('fred');
                 * // => ['e']
                 *
                 * _('fred').vowels().value();
                 * // => ['e']
                 *
                 * _.mixin({ 'vowels': vowels }, { 'chain': false });
                 * _('fred').vowels();
                 * // => ['e']
                 */
                function mixin(object, source, options) {
                    var props = keys(source),
                        methodNames = baseFunctions(source, props);

                    if (options == null &&
                        !(isObject(source) && (methodNames.length || !props.length))) {
                        options = source;
                        source = object;
                        object = this;
                        methodNames = baseFunctions(source, keys(source));
                    }
                    var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
                        isFunc = isFunction(object);

                    arrayEach(methodNames, function(methodName) {
                        var func = source[methodName];
                        object[methodName] = func;
                        if (isFunc) {
                            object.prototype[methodName] = function() {
                                var chainAll = this.__chain__;
                                if (chain || chainAll) {
                                    var result = object(this.__wrapped__),
                                        actions = result.__actions__ = copyArray(this.__actions__);

                                    actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                                    result.__chain__ = chainAll;
                                    return result;
                                }
                                return func.apply(object, arrayPush([this.value()], arguments));
                            };
                        }
                    });

                    return object;
                }

                /**
                 * Reverts the `_` variable to its previous value and returns a reference to
                 * the `lodash` function.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @returns {Function} Returns the `lodash` function.
                 * @example
                 *
                 * var lodash = _.noConflict();
                 */
                function noConflict() {
                    if (root._ === this) {
                        root._ = oldDash;
                    }
                    return this;
                }

                /**
                 * A no-operation function that returns `undefined` regardless of the
                 * arguments it receives.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.3.0
                 * @category Util
                 * @example
                 *
                 * var object = { 'user': 'fred' };
                 *
                 * _.noop(object) === undefined;
                 * // => true
                 */
                function noop() {
                    // No operation performed.
                }

                /**
                 * Creates a function that returns its nth argument. If `n` is negative,
                 * the nth argument from the end is returned.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {number} [n=0] The index of the argument to return.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var func = _.nthArg(1);
                 * func('a', 'b', 'c', 'd');
                 * // => 'b'
                 *
                 * var func = _.nthArg(-2);
                 * func('a', 'b', 'c', 'd');
                 * // => 'c'
                 */
                function nthArg(n) {
                    n = toInteger(n);
                    return rest(function(args) {
                        return baseNth(args, n);
                    });
                }

                /**
                 * Creates a function that invokes `iteratees` with the arguments it receives
                 * and returns their results.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
                 *  [iteratees=[_.identity]] The iteratees to invoke.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var func = _.over(Math.max, Math.min);
                 *
                 * func(1, 2, 3, 4);
                 * // => [4, 1]
                 */
                var over = createOver(arrayMap);

                /**
                 * Creates a function that checks if **all** of the `predicates` return
                 * truthy when invoked with the arguments it receives.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
                 *  [predicates=[_.identity]] The predicates to check.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var func = _.overEvery(Boolean, isFinite);
                 *
                 * func('1');
                 * // => true
                 *
                 * func(null);
                 * // => false
                 *
                 * func(NaN);
                 * // => false
                 */
                var overEvery = createOver(arrayEvery);

                /**
                 * Creates a function that checks if **any** of the `predicates` return
                 * truthy when invoked with the arguments it receives.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
                 *  [predicates=[_.identity]] The predicates to check.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var func = _.overSome(Boolean, isFinite);
                 *
                 * func('1');
                 * // => true
                 *
                 * func(null);
                 * // => true
                 *
                 * func(NaN);
                 * // => false
                 */
                var overSome = createOver(arraySome);

                /**
                 * Creates a function that returns the value at `path` of a given object.
                 *
                 * @static
                 * @memberOf _
                 * @since 2.4.0
                 * @category Util
                 * @param {Array|string} path The path of the property to get.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var objects = [
                 *   { 'a': { 'b': 2 } },
                 *   { 'a': { 'b': 1 } }
                 * ];
                 *
                 * _.map(objects, _.property('a.b'));
                 * // => [2, 1]
                 *
                 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
                 * // => [1, 2]
                 */
                function property(path) {
                    return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
                }

                /**
                 * The opposite of `_.property`; this method creates a function that returns
                 * the value at a given path of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.0.0
                 * @category Util
                 * @param {Object} object The object to query.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var array = [0, 1, 2],
                 *     object = { 'a': array, 'b': array, 'c': array };
                 *
                 * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
                 * // => [2, 0]
                 *
                 * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
                 * // => [2, 0]
                 */
                function propertyOf(object) {
                    return function(path) {
                        return object == null ? undefined : baseGet(object, path);
                    };
                }

                /**
                 * Creates an array of numbers (positive and/or negative) progressing from
                 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
                 * `start` is specified without an `end` or `step`. If `end` is not specified,
                 * it's set to `start` with `start` then set to `0`.
                 *
                 * **Note:** JavaScript follows the IEEE-754 standard for resolving
                 * floating-point values which can produce unexpected results.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {number} [start=0] The start of the range.
                 * @param {number} end The end of the range.
                 * @param {number} [step=1] The value to increment or decrement by.
                 * @returns {Array} Returns the new array of numbers.
                 * @example
                 *
                 * _.range(4);
                 * // => [0, 1, 2, 3]
                 *
                 * _.range(-4);
                 * // => [0, -1, -2, -3]
                 *
                 * _.range(1, 5);
                 * // => [1, 2, 3, 4]
                 *
                 * _.range(0, 20, 5);
                 * // => [0, 5, 10, 15]
                 *
                 * _.range(0, -4, -1);
                 * // => [0, -1, -2, -3]
                 *
                 * _.range(1, 4, 0);
                 * // => [1, 1, 1]
                 *
                 * _.range(0);
                 * // => []
                 */
                var range = createRange();

                /**
                 * This method is like `_.range` except that it populates values in
                 * descending order.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {number} [start=0] The start of the range.
                 * @param {number} end The end of the range.
                 * @param {number} [step=1] The value to increment or decrement by.
                 * @returns {Array} Returns the new array of numbers.
                 * @example
                 *
                 * _.rangeRight(4);
                 * // => [3, 2, 1, 0]
                 *
                 * _.rangeRight(-4);
                 * // => [-3, -2, -1, 0]
                 *
                 * _.rangeRight(1, 5);
                 * // => [4, 3, 2, 1]
                 *
                 * _.rangeRight(0, 20, 5);
                 * // => [15, 10, 5, 0]
                 *
                 * _.rangeRight(0, -4, -1);
                 * // => [-3, -2, -1, 0]
                 *
                 * _.rangeRight(1, 4, 0);
                 * // => [1, 1, 1]
                 *
                 * _.rangeRight(0);
                 * // => []
                 */
                var rangeRight = createRange(true);

                /**
                 * Invokes the iteratee `n` times, returning an array of the results of
                 * each invocation. The iteratee is invoked with one argument; (index).
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {number} n The number of times to invoke `iteratee`.
                 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                 * @returns {Array} Returns the array of results.
                 * @example
                 *
                 * _.times(3, String);
                 * // => ['0', '1', '2']
                 *
                 *  _.times(4, _.constant(true));
                 * // => [true, true, true, true]
                 */
                function times(n, iteratee) {
                    n = toInteger(n);
                    if (n < 1 || n > MAX_SAFE_INTEGER) {
                        return [];
                    }
                    var index = MAX_ARRAY_LENGTH,
                        length = nativeMin(n, MAX_ARRAY_LENGTH);

                    iteratee = getIteratee(iteratee);
                    n -= MAX_ARRAY_LENGTH;

                    var result = baseTimes(length, iteratee);
                    while (++index < n) {
                        iteratee(index);
                    }
                    return result;
                }

                /**
                 * Converts `value` to a property path array.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Util
                 * @param {*} value The value to convert.
                 * @returns {Array} Returns the new property path array.
                 * @example
                 *
                 * _.toPath('a.b.c');
                 * // => ['a', 'b', 'c']
                 *
                 * _.toPath('a[0].b.c');
                 * // => ['a', '0', 'b', 'c']
                 *
                 * var path = ['a', 'b', 'c'],
                 *     newPath = _.toPath(path);
                 *
                 * console.log(newPath);
                 * // => ['a', 'b', 'c']
                 *
                 * console.log(path === newPath);
                 * // => false
                 */
                function toPath(value) {
                    if (isArray(value)) {
                        return arrayMap(value, toKey);
                    }
                    return isSymbol(value) ? [value] : copyArray(stringToPath(value));
                }

                /**
                 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Util
                 * @param {string} [prefix=''] The value to prefix the ID with.
                 * @returns {string} Returns the unique ID.
                 * @example
                 *
                 * _.uniqueId('contact_');
                 * // => 'contact_104'
                 *
                 * _.uniqueId();
                 * // => '105'
                 */
                function uniqueId(prefix) {
                    var id = ++idCounter;
                    return toString(prefix) + id;
                }

                /*------------------------------------------------------------------------*/

                /**
                 * Adds two numbers.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.4.0
                 * @category Math
                 * @param {number} augend The first number in an addition.
                 * @param {number} addend The second number in an addition.
                 * @returns {number} Returns the total.
                 * @example
                 *
                 * _.add(6, 4);
                 * // => 10
                 */
                var add = createMathOperation(function(augend, addend) {
                    return augend + addend;
                });

                /**
                 * Computes `number` rounded up to `precision`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.10.0
                 * @category Math
                 * @param {number} number The number to round up.
                 * @param {number} [precision=0] The precision to round up to.
                 * @returns {number} Returns the rounded up number.
                 * @example
                 *
                 * _.ceil(4.006);
                 * // => 5
                 *
                 * _.ceil(6.004, 2);
                 * // => 6.01
                 *
                 * _.ceil(6040, -2);
                 * // => 6100
                 */
                var ceil = createRound('ceil');

                /**
                 * Divide two numbers.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Math
                 * @param {number} dividend The first number in a division.
                 * @param {number} divisor The second number in a division.
                 * @returns {number} Returns the quotient.
                 * @example
                 *
                 * _.divide(6, 4);
                 * // => 1.5
                 */
                var divide = createMathOperation(function(dividend, divisor) {
                    return dividend / divisor;
                });

                /**
                 * Computes `number` rounded down to `precision`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.10.0
                 * @category Math
                 * @param {number} number The number to round down.
                 * @param {number} [precision=0] The precision to round down to.
                 * @returns {number} Returns the rounded down number.
                 * @example
                 *
                 * _.floor(4.006);
                 * // => 4
                 *
                 * _.floor(0.046, 2);
                 * // => 0.04
                 *
                 * _.floor(4060, -2);
                 * // => 4000
                 */
                var floor = createRound('floor');

                /**
                 * Computes the maximum value of `array`. If `array` is empty or falsey,
                 * `undefined` is returned.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @returns {*} Returns the maximum value.
                 * @example
                 *
                 * _.max([4, 2, 8, 6]);
                 * // => 8
                 *
                 * _.max([]);
                 * // => undefined
                 */
                function max(array) {
                    return (array && array.length)
                        ? baseExtremum(array, identity, gt)
                        : undefined;
                }

                /**
                 * This method is like `_.max` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the criterion by which
                 * the value is ranked. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {*} Returns the maximum value.
                 * @example
                 *
                 * var objects = [{ 'n': 1 }, { 'n': 2 }];
                 *
                 * _.maxBy(objects, function(o) { return o.n; });
                 * // => { 'n': 2 }
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.maxBy(objects, 'n');
                 * // => { 'n': 2 }
                 */
                function maxBy(array, iteratee) {
                    return (array && array.length)
                        ? baseExtremum(array, getIteratee(iteratee), gt)
                        : undefined;
                }

                /**
                 * Computes the mean of the values in `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @returns {number} Returns the mean.
                 * @example
                 *
                 * _.mean([4, 2, 8, 6]);
                 * // => 5
                 */
                function mean(array) {
                    return baseMean(array, identity);
                }

                /**
                 * This method is like `_.mean` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the value to be averaged.
                 * The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {number} Returns the mean.
                 * @example
                 *
                 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
                 *
                 * _.meanBy(objects, function(o) { return o.n; });
                 * // => 5
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.meanBy(objects, 'n');
                 * // => 5
                 */
                function meanBy(array, iteratee) {
                    return baseMean(array, getIteratee(iteratee));
                }

                /**
                 * Computes the minimum value of `array`. If `array` is empty or falsey,
                 * `undefined` is returned.
                 *
                 * @static
                 * @since 0.1.0
                 * @memberOf _
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @returns {*} Returns the minimum value.
                 * @example
                 *
                 * _.min([4, 2, 8, 6]);
                 * // => 2
                 *
                 * _.min([]);
                 * // => undefined
                 */
                function min(array) {
                    return (array && array.length)
                        ? baseExtremum(array, identity, lt)
                        : undefined;
                }

                /**
                 * This method is like `_.min` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the criterion by which
                 * the value is ranked. The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {*} Returns the minimum value.
                 * @example
                 *
                 * var objects = [{ 'n': 1 }, { 'n': 2 }];
                 *
                 * _.minBy(objects, function(o) { return o.n; });
                 * // => { 'n': 1 }
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.minBy(objects, 'n');
                 * // => { 'n': 1 }
                 */
                function minBy(array, iteratee) {
                    return (array && array.length)
                        ? baseExtremum(array, getIteratee(iteratee), lt)
                        : undefined;
                }

                /**
                 * Multiply two numbers.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.7.0
                 * @category Math
                 * @param {number} multiplier The first number in a multiplication.
                 * @param {number} multiplicand The second number in a multiplication.
                 * @returns {number} Returns the product.
                 * @example
                 *
                 * _.multiply(6, 4);
                 * // => 24
                 */
                var multiply = createMathOperation(function(multiplier, multiplicand) {
                    return multiplier * multiplicand;
                });

                /**
                 * Computes `number` rounded to `precision`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.10.0
                 * @category Math
                 * @param {number} number The number to round.
                 * @param {number} [precision=0] The precision to round to.
                 * @returns {number} Returns the rounded number.
                 * @example
                 *
                 * _.round(4.006);
                 * // => 4
                 *
                 * _.round(4.006, 2);
                 * // => 4.01
                 *
                 * _.round(4060, -2);
                 * // => 4100
                 */
                var round = createRound('round');

                /**
                 * Subtract two numbers.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {number} minuend The first number in a subtraction.
                 * @param {number} subtrahend The second number in a subtraction.
                 * @returns {number} Returns the difference.
                 * @example
                 *
                 * _.subtract(6, 4);
                 * // => 2
                 */
                var subtract = createMathOperation(function(minuend, subtrahend) {
                    return minuend - subtrahend;
                });

                /**
                 * Computes the sum of the values in `array`.
                 *
                 * @static
                 * @memberOf _
                 * @since 3.4.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @returns {number} Returns the sum.
                 * @example
                 *
                 * _.sum([4, 2, 8, 6]);
                 * // => 20
                 */
                function sum(array) {
                    return (array && array.length)
                        ? baseSum(array, identity)
                        : 0;
                }

                /**
                 * This method is like `_.sum` except that it accepts `iteratee` which is
                 * invoked for each element in `array` to generate the value to be summed.
                 * The iteratee is invoked with one argument: (value).
                 *
                 * @static
                 * @memberOf _
                 * @since 4.0.0
                 * @category Math
                 * @param {Array} array The array to iterate over.
                 * @param {Array|Function|Object|string} [iteratee=_.identity]
                 *  The iteratee invoked per element.
                 * @returns {number} Returns the sum.
                 * @example
                 *
                 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
                 *
                 * _.sumBy(objects, function(o) { return o.n; });
                 * // => 20
                 *
                 * // The `_.property` iteratee shorthand.
                 * _.sumBy(objects, 'n');
                 * // => 20
                 */
                function sumBy(array, iteratee) {
                    return (array && array.length)
                        ? baseSum(array, getIteratee(iteratee))
                        : 0;
                }

                /*------------------------------------------------------------------------*/

                // Add methods that return wrapped values in chain sequences.
                lodash.after = after;
                lodash.ary = ary;
                lodash.assign = assign;
                lodash.assignIn = assignIn;
                lodash.assignInWith = assignInWith;
                lodash.assignWith = assignWith;
                lodash.at = at;
                lodash.before = before;
                lodash.bind = bind;
                lodash.bindAll = bindAll;
                lodash.bindKey = bindKey;
                lodash.castArray = castArray;
                lodash.chain = chain;
                lodash.chunk = chunk;
                lodash.compact = compact;
                lodash.concat = concat;
                lodash.cond = cond;
                lodash.conforms = conforms;
                lodash.constant = constant;
                lodash.countBy = countBy;
                lodash.create = create;
                lodash.curry = curry;
                lodash.curryRight = curryRight;
                lodash.debounce = debounce;
                lodash.defaults = defaults;
                lodash.defaultsDeep = defaultsDeep;
                lodash.defer = defer;
                lodash.delay = delay;
                lodash.difference = difference;
                lodash.differenceBy = differenceBy;
                lodash.differenceWith = differenceWith;
                lodash.drop = drop;
                lodash.dropRight = dropRight;
                lodash.dropRightWhile = dropRightWhile;
                lodash.dropWhile = dropWhile;
                lodash.fill = fill;
                lodash.filter = filter;
                lodash.flatMap = flatMap;
                lodash.flatMapDeep = flatMapDeep;
                lodash.flatMapDepth = flatMapDepth;
                lodash.flatten = flatten;
                lodash.flattenDeep = flattenDeep;
                lodash.flattenDepth = flattenDepth;
                lodash.flip = flip;
                lodash.flow = flow;
                lodash.flowRight = flowRight;
                lodash.fromPairs = fromPairs;
                lodash.functions = functions;
                lodash.functionsIn = functionsIn;
                lodash.groupBy = groupBy;
                lodash.initial = initial;
                lodash.intersection = intersection;
                lodash.intersectionBy = intersectionBy;
                lodash.intersectionWith = intersectionWith;
                lodash.invert = invert;
                lodash.invertBy = invertBy;
                lodash.invokeMap = invokeMap;
                lodash.iteratee = iteratee;
                lodash.keyBy = keyBy;
                lodash.keys = keys;
                lodash.keysIn = keysIn;
                lodash.map = map;
                lodash.mapKeys = mapKeys;
                lodash.mapValues = mapValues;
                lodash.matches = matches;
                lodash.matchesProperty = matchesProperty;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.mergeWith = mergeWith;
                lodash.method = method;
                lodash.methodOf = methodOf;
                lodash.mixin = mixin;
                lodash.negate = negate;
                lodash.nthArg = nthArg;
                lodash.omit = omit;
                lodash.omitBy = omitBy;
                lodash.once = once;
                lodash.orderBy = orderBy;
                lodash.over = over;
                lodash.overArgs = overArgs;
                lodash.overEvery = overEvery;
                lodash.overSome = overSome;
                lodash.partial = partial;
                lodash.partialRight = partialRight;
                lodash.partition = partition;
                lodash.pick = pick;
                lodash.pickBy = pickBy;
                lodash.property = property;
                lodash.propertyOf = propertyOf;
                lodash.pull = pull;
                lodash.pullAll = pullAll;
                lodash.pullAllBy = pullAllBy;
                lodash.pullAllWith = pullAllWith;
                lodash.pullAt = pullAt;
                lodash.range = range;
                lodash.rangeRight = rangeRight;
                lodash.rearg = rearg;
                lodash.reject = reject;
                lodash.remove = remove;
                lodash.rest = rest;
                lodash.reverse = reverse;
                lodash.sampleSize = sampleSize;
                lodash.set = set;
                lodash.setWith = setWith;
                lodash.shuffle = shuffle;
                lodash.slice = slice;
                lodash.sortBy = sortBy;
                lodash.sortedUniq = sortedUniq;
                lodash.sortedUniqBy = sortedUniqBy;
                lodash.split = split;
                lodash.spread = spread;
                lodash.tail = tail;
                lodash.take = take;
                lodash.takeRight = takeRight;
                lodash.takeRightWhile = takeRightWhile;
                lodash.takeWhile = takeWhile;
                lodash.tap = tap;
                lodash.throttle = throttle;
                lodash.thru = thru;
                lodash.toArray = toArray;
                lodash.toPairs = toPairs;
                lodash.toPairsIn = toPairsIn;
                lodash.toPath = toPath;
                lodash.toPlainObject = toPlainObject;
                lodash.transform = transform;
                lodash.unary = unary;
                lodash.union = union;
                lodash.unionBy = unionBy;
                lodash.unionWith = unionWith;
                lodash.uniq = uniq;
                lodash.uniqBy = uniqBy;
                lodash.uniqWith = uniqWith;
                lodash.unset = unset;
                lodash.unzip = unzip;
                lodash.unzipWith = unzipWith;
                lodash.update = update;
                lodash.updateWith = updateWith;
                lodash.values = values;
                lodash.valuesIn = valuesIn;
                lodash.without = without;
                lodash.words = words;
                lodash.wrap = wrap;
                lodash.xor = xor;
                lodash.xorBy = xorBy;
                lodash.xorWith = xorWith;
                lodash.zip = zip;
                lodash.zipObject = zipObject;
                lodash.zipObjectDeep = zipObjectDeep;
                lodash.zipWith = zipWith;

                // Add aliases.
                lodash.entries = toPairs;
                lodash.entriesIn = toPairsIn;
                lodash.extend = assignIn;
                lodash.extendWith = assignInWith;

                // Add methods to `lodash.prototype`.
                mixin(lodash, lodash);

                /*------------------------------------------------------------------------*/

                // Add methods that return unwrapped values in chain sequences.
                lodash.add = add;
                lodash.attempt = attempt;
                lodash.camelCase = camelCase;
                lodash.capitalize = capitalize;
                lodash.ceil = ceil;
                lodash.clamp = clamp;
                lodash.clone = clone;
                lodash.cloneDeep = cloneDeep;
                lodash.cloneDeepWith = cloneDeepWith;
                lodash.cloneWith = cloneWith;
                lodash.deburr = deburr;
                lodash.divide = divide;
                lodash.endsWith = endsWith;
                lodash.eq = eq;
                lodash.escape = escape;
                lodash.escapeRegExp = escapeRegExp;
                lodash.every = every;
                lodash.find = find;
                lodash.findIndex = findIndex;
                lodash.findKey = findKey;
                lodash.findLast = findLast;
                lodash.findLastIndex = findLastIndex;
                lodash.findLastKey = findLastKey;
                lodash.floor = floor;
                lodash.forEach = forEach;
                lodash.forEachRight = forEachRight;
                lodash.forIn = forIn;
                lodash.forInRight = forInRight;
                lodash.forOwn = forOwn;
                lodash.forOwnRight = forOwnRight;
                lodash.get = get;
                lodash.gt = gt;
                lodash.gte = gte;
                lodash.has = has;
                lodash.hasIn = hasIn;
                lodash.head = head;
                lodash.identity = identity;
                lodash.includes = includes;
                lodash.indexOf = indexOf;
                lodash.inRange = inRange;
                lodash.invoke = invoke;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray;
                lodash.isArrayBuffer = isArrayBuffer;
                lodash.isArrayLike = isArrayLike;
                lodash.isArrayLikeObject = isArrayLikeObject;
                lodash.isBoolean = isBoolean;
                lodash.isBuffer = isBuffer;
                lodash.isDate = isDate;
                lodash.isElement = isElement;
                lodash.isEmpty = isEmpty;
                lodash.isEqual = isEqual;
                lodash.isEqualWith = isEqualWith;
                lodash.isError = isError;
                lodash.isFinite = isFinite;
                lodash.isFunction = isFunction;
                lodash.isInteger = isInteger;
                lodash.isLength = isLength;
                lodash.isMap = isMap;
                lodash.isMatch = isMatch;
                lodash.isMatchWith = isMatchWith;
                lodash.isNaN = isNaN;
                lodash.isNative = isNative;
                lodash.isNil = isNil;
                lodash.isNull = isNull;
                lodash.isNumber = isNumber;
                lodash.isObject = isObject;
                lodash.isObjectLike = isObjectLike;
                lodash.isPlainObject = isPlainObject;
                lodash.isRegExp = isRegExp;
                lodash.isSafeInteger = isSafeInteger;
                lodash.isSet = isSet;
                lodash.isString = isString;
                lodash.isSymbol = isSymbol;
                lodash.isTypedArray = isTypedArray;
                lodash.isUndefined = isUndefined;
                lodash.isWeakMap = isWeakMap;
                lodash.isWeakSet = isWeakSet;
                lodash.join = join;
                lodash.kebabCase = kebabCase;
                lodash.last = last;
                lodash.lastIndexOf = lastIndexOf;
                lodash.lowerCase = lowerCase;
                lodash.lowerFirst = lowerFirst;
                lodash.lt = lt;
                lodash.lte = lte;
                lodash.max = max;
                lodash.maxBy = maxBy;
                lodash.mean = mean;
                lodash.meanBy = meanBy;
                lodash.min = min;
                lodash.minBy = minBy;
                lodash.multiply = multiply;
                lodash.nth = nth;
                lodash.noConflict = noConflict;
                lodash.noop = noop;
                lodash.now = now;
                lodash.pad = pad;
                lodash.padEnd = padEnd;
                lodash.padStart = padStart;
                lodash.parseInt = parseInt;
                lodash.random = random;
                lodash.reduce = reduce;
                lodash.reduceRight = reduceRight;
                lodash.repeat = repeat;
                lodash.replace = replace;
                lodash.result = result;
                lodash.round = round;
                lodash.runInContext = runInContext;
                lodash.sample = sample;
                lodash.size = size;
                lodash.snakeCase = snakeCase;
                lodash.some = some;
                lodash.sortedIndex = sortedIndex;
                lodash.sortedIndexBy = sortedIndexBy;
                lodash.sortedIndexOf = sortedIndexOf;
                lodash.sortedLastIndex = sortedLastIndex;
                lodash.sortedLastIndexBy = sortedLastIndexBy;
                lodash.sortedLastIndexOf = sortedLastIndexOf;
                lodash.startCase = startCase;
                lodash.startsWith = startsWith;
                lodash.subtract = subtract;
                lodash.sum = sum;
                lodash.sumBy = sumBy;
                lodash.template = template;
                lodash.times = times;
                lodash.toInteger = toInteger;
                lodash.toLength = toLength;
                lodash.toLower = toLower;
                lodash.toNumber = toNumber;
                lodash.toSafeInteger = toSafeInteger;
                lodash.toString = toString;
                lodash.toUpper = toUpper;
                lodash.trim = trim;
                lodash.trimEnd = trimEnd;
                lodash.trimStart = trimStart;
                lodash.truncate = truncate;
                lodash.unescape = unescape;
                lodash.uniqueId = uniqueId;
                lodash.upperCase = upperCase;
                lodash.upperFirst = upperFirst;

                // Add aliases.
                lodash.each = forEach;
                lodash.eachRight = forEachRight;
                lodash.first = head;

                mixin(lodash, (function() {
                    var source = {};
                    baseForOwn(lodash, function(func, methodName) {
                        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                            source[methodName] = func;
                        }
                    });
                    return source;
                }()), { 'chain': false });

                /*------------------------------------------------------------------------*/

                /**
                 * The semantic version number.
                 *
                 * @static
                 * @memberOf _
                 * @type {string}
                 */
                lodash.VERSION = VERSION;

                // Assign default placeholders.
                arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
                    lodash[methodName].placeholder = lodash;
                });

                // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                arrayEach(['drop', 'take'], function(methodName, index) {
                    LazyWrapper.prototype[methodName] = function(n) {
                        var filtered = this.__filtered__;
                        if (filtered && !index) {
                            return new LazyWrapper(this);
                        }
                        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

                        var result = this.clone();
                        if (filtered) {
                            result.__takeCount__ = nativeMin(n, result.__takeCount__);
                        } else {
                            result.__views__.push({
                                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                            });
                        }
                        return result;
                    };

                    LazyWrapper.prototype[methodName + 'Right'] = function(n) {
                        return this.reverse()[methodName](n).reverse();
                    };
                });

                // Add `LazyWrapper` methods that accept an `iteratee` value.
                arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
                    var type = index + 1,
                        isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

                    LazyWrapper.prototype[methodName] = function(iteratee) {
                        var result = this.clone();
                        result.__iteratees__.push({
                            'iteratee': getIteratee(iteratee, 3),
                            'type': type
                        });
                        result.__filtered__ = result.__filtered__ || isFilter;
                        return result;
                    };
                });

                // Add `LazyWrapper` methods for `_.head` and `_.last`.
                arrayEach(['head', 'last'], function(methodName, index) {
                    var takeName = 'take' + (index ? 'Right' : '');

                    LazyWrapper.prototype[methodName] = function() {
                        return this[takeName](1).value()[0];
                    };
                });

                // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
                arrayEach(['initial', 'tail'], function(methodName, index) {
                    var dropName = 'drop' + (index ? '' : 'Right');

                    LazyWrapper.prototype[methodName] = function() {
                        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                    };
                });

                LazyWrapper.prototype.compact = function() {
                    return this.filter(identity);
                };

                LazyWrapper.prototype.find = function(predicate) {
                    return this.filter(predicate).head();
                };

                LazyWrapper.prototype.findLast = function(predicate) {
                    return this.reverse().find(predicate);
                };

                LazyWrapper.prototype.invokeMap = rest(function(path, args) {
                    if (typeof path == 'function') {
                        return new LazyWrapper(this);
                    }
                    return this.map(function(value) {
                        return baseInvoke(value, path, args);
                    });
                });

                LazyWrapper.prototype.reject = function(predicate) {
                    predicate = getIteratee(predicate, 3);
                    return this.filter(function(value) {
                        return !predicate(value);
                    });
                };

                LazyWrapper.prototype.slice = function(start, end) {
                    start = toInteger(start);

                    var result = this;
                    if (result.__filtered__ && (start > 0 || end < 0)) {
                        return new LazyWrapper(result);
                    }
                    if (start < 0) {
                        result = result.takeRight(-start);
                    } else if (start) {
                        result = result.drop(start);
                    }
                    if (end !== undefined) {
                        end = toInteger(end);
                        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                    }
                    return result;
                };

                LazyWrapper.prototype.takeRightWhile = function(predicate) {
                    return this.reverse().takeWhile(predicate).reverse();
                };

                LazyWrapper.prototype.toArray = function() {
                    return this.take(MAX_ARRAY_LENGTH);
                };

                // Add `LazyWrapper` methods to `lodash.prototype`.
                baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                        isTaker = /^(?:head|last)$/.test(methodName),
                        lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
                        retUnwrapped = isTaker || /^find/.test(methodName);

                    if (!lodashFunc) {
                        return;
                    }
                    lodash.prototype[methodName] = function() {
                        var value = this.__wrapped__,
                            args = isTaker ? [1] : arguments,
                            isLazy = value instanceof LazyWrapper,
                            iteratee = args[0],
                            useLazy = isLazy || isArray(value);

                        var interceptor = function(value) {
                            var result = lodashFunc.apply(lodash, arrayPush([value], args));
                            return (isTaker && chainAll) ? result[0] : result;
                        };

                        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                            // Avoid lazy use if the iteratee has a "length" value other than `1`.
                            isLazy = useLazy = false;
                        }
                        var chainAll = this.__chain__,
                            isHybrid = !!this.__actions__.length,
                            isUnwrapped = retUnwrapped && !chainAll,
                            onlyLazy = isLazy && !isHybrid;

                        if (!retUnwrapped && useLazy) {
                            value = onlyLazy ? value : new LazyWrapper(this);
                            var result = func.apply(value, args);
                            result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
                            return new LodashWrapper(result, chainAll);
                        }
                        if (isUnwrapped && onlyLazy) {
                            return func.apply(this, args);
                        }
                        result = this.thru(interceptor);
                        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
                    };
                });

                // Add `Array` methods to `lodash.prototype`.
                arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
                    var func = arrayProto[methodName],
                        chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                        retUnwrapped = /^(?:pop|shift)$/.test(methodName);

                    lodash.prototype[methodName] = function() {
                        var args = arguments;
                        if (retUnwrapped && !this.__chain__) {
                            var value = this.value();
                            return func.apply(isArray(value) ? value : [], args);
                        }
                        return this[chainName](function(value) {
                            return func.apply(isArray(value) ? value : [], args);
                        });
                    };
                });

                // Map minified method names to their real names.
                baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var lodashFunc = lodash[methodName];
                    if (lodashFunc) {
                        var key = (lodashFunc.name + ''),
                            names = realNames[key] || (realNames[key] = []);

                        names.push({ 'name': methodName, 'func': lodashFunc });
                    }
                });

                realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
                    'name': 'wrapper',
                    'func': undefined
                }];

                // Add methods to `LazyWrapper`.
                LazyWrapper.prototype.clone = lazyClone;
                LazyWrapper.prototype.reverse = lazyReverse;
                LazyWrapper.prototype.value = lazyValue;

                // Add chain sequence methods to the `lodash` wrapper.
                lodash.prototype.at = wrapperAt;
                lodash.prototype.chain = wrapperChain;
                lodash.prototype.commit = wrapperCommit;
                lodash.prototype.next = wrapperNext;
                lodash.prototype.plant = wrapperPlant;
                lodash.prototype.reverse = wrapperReverse;
                lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

                if (iteratorSymbol) {
                    lodash.prototype[iteratorSymbol] = wrapperToIterator;
                }
                return lodash;
            }

            /*--------------------------------------------------------------------------*/

            // Export lodash.
            var _ = runInContext();

            // Expose lodash on the free variable `window` or `self` when available. This
            // prevents errors in cases where lodash is loaded by a script tag in the presence
            // of an AMD loader. See http://requirejs.org/docs/errors.html#mismatch for more details.
            (freeWindow || freeSelf || {})._ = _;

            // Some AMD build optimizers like r.js check for condition patterns like the following:
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                // Define as an anonymous module so, through path mapping, it can be
                // referenced as the "underscore" module.
                define(function() {
                    return _;
                });
            }
            // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
            else if (freeExports && freeModule) {
                // Export for Node.js.
                if (moduleExports) {
                    (freeModule.exports = _)._ = _;
                }
                // Export for CommonJS support.
                freeExports._ = _;
            }
            else {
                // Export to the global object.
                root._ = _;
            }
        }.call(this));

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],82:[function(require,module,exports){
    module.exports = compile;

    var BaseFuncs = require("boolbase"),
        trueFunc  = BaseFuncs.trueFunc,
        falseFunc = BaseFuncs.falseFunc;

    /*
     returns a function that checks if an elements index matches the given rule
     highly optimized to return the fastest solution
     */
    function compile(parsed){
        var a = parsed[0],
            b = parsed[1] - 1;

        //when b <= 0, a*n won't be possible for any matches when a < 0
        //besides, the specification says that no element is matched when a and b are 0
        if(b < 0 && a <= 0) return falseFunc;

        //when a is in the range -1..1, it matches any element (so only b is checked)
        if(a ===-1) return function(pos){ return pos <= b; };
        if(a === 0) return function(pos){ return pos === b; };
        //when b <= 0 and a === 1, they match any element
        if(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };

        //when a > 0, modulo can be used to check if there is a match
        var bMod = b % a;
        if(bMod < 0) bMod += a;

        if(a > 1){
            return function(pos){
                return pos >= b && pos % a === bMod;
            };
        }

        a *= -1; //make `a` positive

        return function(pos){
            return pos <= b && pos % a === bMod;
        };
    }
},{"boolbase":26}],83:[function(require,module,exports){
    var parse = require("./parse.js"),
        compile = require("./compile.js");

    module.exports = function nthCheck(formula){
        return compile(parse(formula));
    };

    module.exports.parse = parse;
    module.exports.compile = compile;
},{"./compile.js":82,"./parse.js":84}],84:[function(require,module,exports){
    module.exports = parse;

//following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo

//[ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
    var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;

    /*
     parses a nth-check formula, returns an array of two numbers
     */
    function parse(formula){
        formula = formula.trim().toLowerCase();

        if(formula === "even"){
            return [2, 0];
        } else if(formula === "odd"){
            return [2, 1];
        } else {
            var parsed = formula.match(re_nthElement);

            if(!parsed){
                throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
            }

            var a;

            if(parsed[1]){
                a = parseInt(parsed[1], 10);
                if(isNaN(a)){
                    if(parsed[1].charAt(0) === "-") a = -1;
                    else a = 1;
                }
            } else a = 0;

            return [
                a,
                parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
            ];
        }
    }

},{}],85:[function(require,module,exports){
    "use strict";
    var TileLayerDirectiveController = (function () {
        function TileLayerDirectiveController() {
        }
        TileLayerDirectiveController.$inject = ['$scope'];
        return TileLayerDirectiveController;
    }());
    exports.TileLayerDirectiveController = TileLayerDirectiveController;
    var TileLayerDirective = (function () {
        function TileLayerDirective() {
            this.restrict = 'E';
            this.require = '^^yagaMap';
            this.replace = false;
            this.scope = {
                attribution: '=?',
                name: '=',
                opacity: '=?',
                url: '='
            };
        }
        TileLayerDirective.factory = function () {
            return new TileLayerDirective();
        };
        TileLayerDirective.prototype.compile = function () {
            return {
                pre: function (scope, element, attributes, mapController) {
                    var tileLayer = new mapController.yagaDriverService['tile-layer'].TileLayer({
                        attribution: scope.attribution,
                        name: scope.name,
                        opacity: scope.opacity,
                        type: 'tile',
                        url: scope.url
                    });
                    tileLayer.on('watch:url', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.url = value;
                                });
                            }, 0);
                        }
                    });
                    tileLayer.on('watch:attribution', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.attribution = value;
                                });
                            }, 0);
                        }
                    });
                    tileLayer.on('watch:opacity', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.opacity = value;
                                });
                            }, 0);
                        }
                    });
                    scope.$watch('url', function () {
                        tileLayer.setUrl(scope.url, [scope]);
                    });
                    scope.$watch('attribution', function () {
                        tileLayer.setAttribution(scope.attribution, [scope]);
                    });
                    scope.$watch('opacity', function () {
                        tileLayer.setOpacity(scope.opacity, [scope]);
                    });
                    scope.$on('$destroy', function () {
                        tileLayer.map.removeLayer(tileLayer);
                    });
                    mapController.map.addLayer(tileLayer);
                }
            };
        };
        return TileLayerDirective;
    }());
    exports.TileLayerDirective = TileLayerDirective;
    TileLayerDirective.factory.$inject = [];
    angular.module('org.yagajs.tile-layer', ['org.yagajs.map'])
        .directive('yagaTileLayer', TileLayerDirective.factory);

},{}],86:[function(require,module,exports){
    "use strict";
    var WmsLayerDirectiveController = (function () {
        function WmsLayerDirectiveController() {
        }
        WmsLayerDirectiveController.$inject = ['$scope'];
        return WmsLayerDirectiveController;
    }());
    exports.WmsLayerDirectiveController = WmsLayerDirectiveController;
    var WmsLayerDirective = (function () {
        function WmsLayerDirective() {
            this.restrict = 'E';
            this.require = '^^yagaMap';
            this.replace = false;
            this.scope = {
                attribution: '=?',
                name: '=',
                opacity: '=?',
                url: '='
            };
        }
        WmsLayerDirective.factory = function () {
            return new WmsLayerDirective();
        };
        WmsLayerDirective.prototype.compile = function () {
            return {
                pre: function (scope, element, attributes, mapController) {
                    var wmsLayer = new mapController.yagaDriverService['wms-layer'].WmsLayer({
                        attribution: scope.attribution,
                        name: scope.name,
                        opacity: scope.opacity,
                        type: 'wms',
                        url: scope.url
                    });
                    wmsLayer.on('watch:url', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.url = value;
                                });
                            }, 0);
                        }
                    });
                    wmsLayer.on('watch:attribution', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.attribution = value;
                                });
                            }, 0);
                        }
                    });
                    wmsLayer.on('watch:opacity', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.opacity = value;
                                });
                            }, 0);
                        }
                    });
                    wmsLayer.on('watch:layers', function (value, origin) {
                        if (origin.indexOf(scope) === -1) {
                            mapController.timeoutServiceHelper(function () {
                                scope.$apply(function () {
                                    scope.layers = value;
                                });
                            }, 0);
                        }
                    });
                    scope.$watch('url', function () {
                        wmsLayer.setUrl(scope.url, [scope]);
                    });
                    scope.$watch('attribution', function () {
                        wmsLayer.setAttribution(scope.attribution, [scope]);
                    });
                    scope.$watch('opacity', function () {
                        wmsLayer.setOpacity(scope.opacity, [scope]);
                    });
                    scope.$watch('layers', function () {
                        if (scope.layers) {
                            console.log('layers', scope.layers);
                            wmsLayer.setLayers(scope.layers, [scope]);
                        }
                    });
                    scope.$on('$destroy', function () {
                        wmsLayer.map.removeLayer(wmsLayer);
                    });
                    mapController.map.addLayer(wmsLayer);
                }
            };
        };
        return WmsLayerDirective;
    }());
    exports.WmsLayerDirective = WmsLayerDirective;
    WmsLayerDirective.factory.$inject = [];
    angular.module('org.yagajs.wms-layer', ['org.yagajs.map'])
        .directive('yagaWmsLayer', WmsLayerDirective.factory);

},{}],87:[function(require,module,exports){
    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    ;(function (exports) {
        'use strict';

        var Arr = (typeof Uint8Array !== 'undefined')
            ? Uint8Array
            : Array

        var PLUS   = '+'.charCodeAt(0)
        var SLASH  = '/'.charCodeAt(0)
        var NUMBER = '0'.charCodeAt(0)
        var LOWER  = 'a'.charCodeAt(0)
        var UPPER  = 'A'.charCodeAt(0)
        var PLUS_URL_SAFE = '-'.charCodeAt(0)
        var SLASH_URL_SAFE = '_'.charCodeAt(0)

        function decode (elt) {
            var code = elt.charCodeAt(0)
            if (code === PLUS ||
                code === PLUS_URL_SAFE)
                return 62 // '+'
            if (code === SLASH ||
                code === SLASH_URL_SAFE)
                return 63 // '/'
            if (code < NUMBER)
                return -1 //no match
            if (code < NUMBER + 10)
                return code - NUMBER + 26 + 26
            if (code < UPPER + 26)
                return code - UPPER
            if (code < LOWER + 26)
                return code - LOWER + 26
        }

        function b64ToByteArray (b64) {
            var i, j, l, tmp, placeHolders, arr

            if (b64.length % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // the number of equal signs (place holders)
            // if there are two placeholders, than the two characters before it
            // represent one byte
            // if there is only one, then the three characters before it represent 2 bytes
            // this is just a cheap hack to not do indexOf twice
            var len = b64.length
            placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

            // base64 is 4/3 + up to two characters of the original data
            arr = new Arr(b64.length * 3 / 4 - placeHolders)

            // if there are placeholders, only get up to the last complete 4 chars
            l = placeHolders > 0 ? b64.length - 4 : b64.length

            var L = 0

            function push (v) {
                arr[L++] = v
            }

            for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
                push((tmp & 0xFF0000) >> 16)
                push((tmp & 0xFF00) >> 8)
                push(tmp & 0xFF)
            }

            if (placeHolders === 2) {
                tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
                push(tmp & 0xFF)
            } else if (placeHolders === 1) {
                tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
                push((tmp >> 8) & 0xFF)
                push(tmp & 0xFF)
            }

            return arr
        }

        function uint8ToBase64 (uint8) {
            var i,
                extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                output = "",
                temp, length

            function encode (num) {
                return lookup.charAt(num)
            }

            function tripletToBase64 (num) {
                return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
            }

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                output += tripletToBase64(temp)
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            switch (extraBytes) {
                case 1:
                    temp = uint8[uint8.length - 1]
                    output += encode(temp >> 2)
                    output += encode((temp << 4) & 0x3F)
                    output += '=='
                    break
                case 2:
                    temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
                    output += encode(temp >> 10)
                    output += encode((temp >> 4) & 0x3F)
                    output += encode((temp << 2) & 0x3F)
                    output += '='
                    break
            }

            return output
        }

        exports.toByteArray = b64ToByteArray
        exports.fromByteArray = uint8ToBase64
    }(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],88:[function(require,module,exports){

},{}],89:[function(require,module,exports){
    (function (global){
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */
        /* eslint-disable no-proto */

        var base64 = require('base64-js')
        var ieee754 = require('ieee754')
        var isArray = require('isarray')

        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50
        Buffer.poolSize = 8192 // not used by this implementation

        var rootParent = {}

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Due to various browser bugs, sometimes the Object implementation will be used even
         * when the browser supports typed arrays.
         *
         * Note:
         *
         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
         *     on objects.
         *
         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *     incorrect length in some situations.

         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
         * get the Object implementation, which is slower but behaves correctly.
         */
        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
            ? global.TYPED_ARRAY_SUPPORT
            : typedArraySupport()

        function typedArraySupport () {
            function Bar () {}
            try {
                var arr = new Uint8Array(1)
                arr.foo = function () { return 42 }
                arr.constructor = Bar
                return arr.foo() === 42 && // typed array instances can be augmented
                    arr.constructor === Bar && // constructor can be set
                    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                    arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
            } catch (e) {
                return false
            }
        }

        function kMaxLength () {
            return Buffer.TYPED_ARRAY_SUPPORT
                ? 0x7fffffff
                : 0x3fffffff
        }

        /**
         * Class: Buffer
         * =============
         *
         * The Buffer constructor returns instances of `Uint8Array` that are augmented
         * with function properties for all the node `Buffer` API functions. We use
         * `Uint8Array` so that square bracket notation works as expected -- it returns
         * a single octet.
         *
         * By augmenting the instances, we can avoid modifying the `Uint8Array`
         * prototype.
         */
        function Buffer (arg) {
            if (!(this instanceof Buffer)) {
                // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
                if (arguments.length > 1) return new Buffer(arg, arguments[1])
                return new Buffer(arg)
            }

            this.length = 0
            this.parent = undefined

            // Common case.
            if (typeof arg === 'number') {
                return fromNumber(this, arg)
            }

            // Slightly less common case.
            if (typeof arg === 'string') {
                return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
            }

            // Unusual.
            return fromObject(this, arg)
        }

        function fromNumber (that, length) {
            that = allocate(that, length < 0 ? 0 : checked(length) | 0)
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < length; i++) {
                    that[i] = 0
                }
            }
            return that
        }

        function fromString (that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

            // Assumption: byteLength() return value is always < kMaxLength.
            var length = byteLength(string, encoding) | 0
            that = allocate(that, length)

            that.write(string, encoding)
            return that
        }

        function fromObject (that, object) {
            if (Buffer.isBuffer(object)) return fromBuffer(that, object)

            if (isArray(object)) return fromArray(that, object)

            if (object == null) {
                throw new TypeError('must start with number, buffer, array or string')
            }

            if (typeof ArrayBuffer !== 'undefined') {
                if (object.buffer instanceof ArrayBuffer) {
                    return fromTypedArray(that, object)
                }
                if (object instanceof ArrayBuffer) {
                    return fromArrayBuffer(that, object)
                }
            }

            if (object.length) return fromArrayLike(that, object)

            return fromJsonObject(that, object)
        }

        function fromBuffer (that, buffer) {
            var length = checked(buffer.length) | 0
            that = allocate(that, length)
            buffer.copy(that, 0, 0, length)
            return that
        }

        function fromArray (that, array) {
            var length = checked(array.length) | 0
            that = allocate(that, length)
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255
            }
            return that
        }

// Duplicate of fromArray() to keep fromArray() monomorphic.
        function fromTypedArray (that, array) {
            var length = checked(array.length) | 0
            that = allocate(that, length)
            // Truncating the elements is probably not what people expect from typed
            // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
            // of the old Buffer constructor.
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255
            }
            return that
        }

        function fromArrayBuffer (that, array) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                array.byteLength
                that = Buffer._augment(new Uint8Array(array))
            } else {
                // Fallback: Return an object instance of the Buffer class
                that = fromTypedArray(that, new Uint8Array(array))
            }
            return that
        }

        function fromArrayLike (that, array) {
            var length = checked(array.length) | 0
            that = allocate(that, length)
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255
            }
            return that
        }

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
        function fromJsonObject (that, object) {
            var array
            var length = 0

            if (object.type === 'Buffer' && isArray(object.data)) {
                array = object.data
                length = checked(array.length) | 0
            }
            that = allocate(that, length)

            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255
            }
            return that
        }

        if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype
            Buffer.__proto__ = Uint8Array
        }

        function allocate (that, length) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = Buffer._augment(new Uint8Array(length))
                that.__proto__ = Buffer.prototype
            } else {
                // Fallback: Return an object instance of the Buffer class
                that.length = length
                that._isBuffer = true
            }

            var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
            if (fromPool) that.parent = rootParent

            return that
        }

        function checked (length) {
            // Note: cannot use `length < kMaxLength` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= kMaxLength()) {
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                    'size: 0x' + kMaxLength().toString(16) + ' bytes')
            }
            return length | 0
        }

        function SlowBuffer (subject, encoding) {
            if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

            var buf = new Buffer(subject, encoding)
            delete buf.parent
            return buf
        }

        Buffer.isBuffer = function isBuffer (b) {
            return !!(b != null && b._isBuffer)
        }

        Buffer.compare = function compare (a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError('Arguments must be Buffers')
            }

            if (a === b) return 0

            var x = a.length
            var y = b.length

            var i = 0
            var len = Math.min(x, y)
            while (i < len) {
                if (a[i] !== b[i]) break

                ++i
            }

            if (i !== len) {
                x = a[i]
                y = b[i]
            }

            if (x < y) return -1
            if (y < x) return 1
            return 0
        }

        Buffer.isEncoding = function isEncoding (encoding) {
            switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'raw':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    return true
                default:
                    return false
            }
        }

        Buffer.concat = function concat (list, length) {
            if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

            if (list.length === 0) {
                return new Buffer(0)
            }

            var i
            if (length === undefined) {
                length = 0
                for (i = 0; i < list.length; i++) {
                    length += list[i].length
                }
            }

            var buf = new Buffer(length)
            var pos = 0
            for (i = 0; i < list.length; i++) {
                var item = list[i]
                item.copy(buf, pos)
                pos += item.length
            }
            return buf
        }

        function byteLength (string, encoding) {
            if (typeof string !== 'string') string = '' + string

            var len = string.length
            if (len === 0) return 0

            // Use a for loop to avoid recursion
            var loweredCase = false
            for (;;) {
                switch (encoding) {
                    case 'ascii':
                    case 'binary':
                    // Deprecated
                    case 'raw':
                    case 'raws':
                        return len
                    case 'utf8':
                    case 'utf-8':
                        return utf8ToBytes(string).length
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return len * 2
                    case 'hex':
                        return len >>> 1
                    case 'base64':
                        return base64ToBytes(string).length
                    default:
                        if (loweredCase) return utf8ToBytes(string).length // assume utf8
                        encoding = ('' + encoding).toLowerCase()
                        loweredCase = true
                }
            }
        }
        Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
        Buffer.prototype.length = undefined
        Buffer.prototype.parent = undefined

        function slowToString (encoding, start, end) {
            var loweredCase = false

            start = start | 0
            end = end === undefined || end === Infinity ? this.length : end | 0

            if (!encoding) encoding = 'utf8'
            if (start < 0) start = 0
            if (end > this.length) end = this.length
            if (end <= start) return ''

            while (true) {
                switch (encoding) {
                    case 'hex':
                        return hexSlice(this, start, end)

                    case 'utf8':
                    case 'utf-8':
                        return utf8Slice(this, start, end)

                    case 'ascii':
                        return asciiSlice(this, start, end)

                    case 'binary':
                        return binarySlice(this, start, end)

                    case 'base64':
                        return base64Slice(this, start, end)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return utf16leSlice(this, start, end)

                    default:
                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = (encoding + '').toLowerCase()
                        loweredCase = true
                }
            }
        }

        Buffer.prototype.toString = function toString () {
            var length = this.length | 0
            if (length === 0) return ''
            if (arguments.length === 0) return utf8Slice(this, 0, length)
            return slowToString.apply(this, arguments)
        }

        Buffer.prototype.equals = function equals (b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
            if (this === b) return true
            return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function inspect () {
            var str = ''
            var max = exports.INSPECT_MAX_BYTES
            if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                if (this.length > max) str += ' ... '
            }
            return '<Buffer ' + str + '>'
        }

        Buffer.prototype.compare = function compare (b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
            if (this === b) return 0
            return Buffer.compare(this, b)
        }

        Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
            if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
            else if (byteOffset < -0x80000000) byteOffset = -0x80000000
            byteOffset >>= 0

            if (this.length === 0) return -1
            if (byteOffset >= this.length) return -1

            // Negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

            if (typeof val === 'string') {
                if (val.length === 0) return -1 // special case: looking for empty string always fails
                return String.prototype.indexOf.call(this, val, byteOffset)
            }
            if (Buffer.isBuffer(val)) {
                return arrayIndexOf(this, val, byteOffset)
            }
            if (typeof val === 'number') {
                if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                    return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
                }
                return arrayIndexOf(this, [ val ], byteOffset)
            }

            function arrayIndexOf (arr, val, byteOffset) {
                var foundIndex = -1
                for (var i = 0; byteOffset + i < arr.length; i++) {
                    if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                        if (foundIndex === -1) foundIndex = i
                        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
                    } else {
                        foundIndex = -1
                    }
                }
                return -1
            }

            throw new TypeError('val must be string, number or Buffer')
        }

// `get` is deprecated
        Buffer.prototype.get = function get (offset) {
            console.log('.get() is deprecated. Access using array indexes instead.')
            return this.readUInt8(offset)
        }

// `set` is deprecated
        Buffer.prototype.set = function set (v, offset) {
            console.log('.set() is deprecated. Access using array indexes instead.')
            return this.writeUInt8(v, offset)
        }

        function hexWrite (buf, string, offset, length) {
            offset = Number(offset) || 0
            var remaining = buf.length - offset
            if (!length) {
                length = remaining
            } else {
                length = Number(length)
                if (length > remaining) {
                    length = remaining
                }
            }

            // must be an even number of digits
            var strLen = string.length
            if (strLen % 2 !== 0) throw new Error('Invalid hex string')

            if (length > strLen / 2) {
                length = strLen / 2
            }
            for (var i = 0; i < length; i++) {
                var parsed = parseInt(string.substr(i * 2, 2), 16)
                if (isNaN(parsed)) throw new Error('Invalid hex string')
                buf[offset + i] = parsed
            }
            return i
        }

        function utf8Write (buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        }

        function asciiWrite (buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function binaryWrite (buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length)
        }

        function base64Write (buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write (buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
        }

        Buffer.prototype.write = function write (string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
                encoding = 'utf8'
                length = this.length
                offset = 0
                // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
                encoding = offset
                length = this.length
                offset = 0
                // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
                offset = offset | 0
                if (isFinite(length)) {
                    length = length | 0
                    if (encoding === undefined) encoding = 'utf8'
                } else {
                    encoding = length
                    length = undefined
                }
                // legacy write(string, encoding, offset, length) - remove in v0.13
            } else {
                var swap = encoding
                encoding = offset
                offset = length | 0
                length = swap
            }

            var remaining = this.length - offset
            if (length === undefined || length > remaining) length = remaining

            if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError('attempt to write outside buffer bounds')
            }

            if (!encoding) encoding = 'utf8'

            var loweredCase = false
            for (;;) {
                switch (encoding) {
                    case 'hex':
                        return hexWrite(this, string, offset, length)

                    case 'utf8':
                    case 'utf-8':
                        return utf8Write(this, string, offset, length)

                    case 'ascii':
                        return asciiWrite(this, string, offset, length)

                    case 'binary':
                        return binaryWrite(this, string, offset, length)

                    case 'base64':
                        // Warning: maxLength not taken into account in base64Write
                        return base64Write(this, string, offset, length)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return ucs2Write(this, string, offset, length)

                    default:
                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = ('' + encoding).toLowerCase()
                        loweredCase = true
                }
            }
        }

        Buffer.prototype.toJSON = function toJSON () {
            return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }

        function base64Slice (buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf)
            } else {
                return base64.fromByteArray(buf.slice(start, end))
            }
        }

        function utf8Slice (buf, start, end) {
            end = Math.min(buf.length, end)
            var res = []

            var i = start
            while (i < end) {
                var firstByte = buf[i]
                var codePoint = null
                var bytesPerSequence = (firstByte > 0xEF) ? 4
                    : (firstByte > 0xDF) ? 3
                    : (firstByte > 0xBF) ? 2
                    : 1

                if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint

                    switch (bytesPerSequence) {
                        case 1:
                            if (firstByte < 0x80) {
                                codePoint = firstByte
                            }
                            break
                        case 2:
                            secondByte = buf[i + 1]
                            if ((secondByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                if (tempCodePoint > 0x7F) {
                                    codePoint = tempCodePoint
                                }
                            }
                            break
                        case 3:
                            secondByte = buf[i + 1]
                            thirdByte = buf[i + 2]
                            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                    codePoint = tempCodePoint
                                }
                            }
                            break
                        case 4:
                            secondByte = buf[i + 1]
                            thirdByte = buf[i + 2]
                            fourthByte = buf[i + 3]
                            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                    codePoint = tempCodePoint
                                }
                            }
                    }
                }

                if (codePoint === null) {
                    // we did not generate a valid codePoint so insert a
                    // replacement char (U+FFFD) and advance only 1 byte
                    codePoint = 0xFFFD
                    bytesPerSequence = 1
                } else if (codePoint > 0xFFFF) {
                    // encode to utf16 (surrogate pair dance)
                    codePoint -= 0x10000
                    res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                    codePoint = 0xDC00 | codePoint & 0x3FF
                }

                res.push(codePoint)
                i += bytesPerSequence
            }

            return decodeCodePointsArray(res)
        }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray (codePoints) {
            var len = codePoints.length
            if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = ''
            var i = 0
            while (i < len) {
                res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                )
            }
            return res
        }

        function asciiSlice (buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i] & 0x7F)
            }
            return ret
        }

        function binarySlice (buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i])
            }
            return ret
        }

        function hexSlice (buf, start, end) {
            var len = buf.length

            if (!start || start < 0) start = 0
            if (!end || end < 0 || end > len) end = len

            var out = ''
            for (var i = start; i < end; i++) {
                out += toHex(buf[i])
            }
            return out
        }

        function utf16leSlice (buf, start, end) {
            var bytes = buf.slice(start, end)
            var res = ''
            for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
            }
            return res
        }

        Buffer.prototype.slice = function slice (start, end) {
            var len = this.length
            start = ~~start
            end = end === undefined ? len : ~~end

            if (start < 0) {
                start += len
                if (start < 0) start = 0
            } else if (start > len) {
                start = len
            }

            if (end < 0) {
                end += len
                if (end < 0) end = 0
            } else if (end > len) {
                end = len
            }

            if (end < start) end = start

            var newBuf
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = Buffer._augment(this.subarray(start, end))
            } else {
                var sliceLen = end - start
                newBuf = new Buffer(sliceLen, undefined)
                for (var i = 0; i < sliceLen; i++) {
                    newBuf[i] = this[i + start]
                }
            }

            if (newBuf.length) newBuf.parent = this.parent || this

            return newBuf
        }

        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */
        function checkOffset (offset, ext, length) {
            if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
        }

        Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul
            }

            return val
        }

        Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) {
                checkOffset(offset, byteLength, this.length)
            }

            var val = this[offset + --byteLength]
            var mul = 1
            while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul
            }

            return val
        }

        Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length)
            return this[offset]
        }

        Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return ((this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16)) +
                (this[offset + 3] * 0x1000000)
        }

        Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
        }

        Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
        }

        Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var i = byteLength
            var mul = 1
            var val = this[offset + --i]
            while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
        }

        Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length)
            if (!(this[offset] & 0x80)) return (this[offset])
            return ((0xff - this[offset] + 1) * -1)
        }

        Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset] | (this[offset + 1] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset + 1] | (this[offset] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
        }

        Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
        }

        Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt (buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
            if (value > max || value < min) throw new RangeError('value is out of bounds')
            if (offset + ext > buf.length) throw new RangeError('index out of range')
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

            var mul = 1
            var i = 0
            this[offset] = value & 0xFF
            while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

            var i = byteLength - 1
            var mul = 1
            this[offset + i] = value & 0xFF
            while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
            this[offset] = (value & 0xff)
            return offset + 1
        }

        function objectWriteUInt16 (buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffff + value + 1
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                    (littleEndian ? i : 1 - i) * 8
            }
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
            } else {
                objectWriteUInt16(this, value, offset, true)
            }
            return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8)
                this[offset + 1] = (value & 0xff)
            } else {
                objectWriteUInt16(this, value, offset, false)
            }
            return offset + 2
        }

        function objectWriteUInt32 (buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffffffff + value + 1
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
            }
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = (value >>> 24)
                this[offset + 2] = (value >>> 16)
                this[offset + 1] = (value >>> 8)
                this[offset] = (value & 0xff)
            } else {
                objectWriteUInt32(this, value, offset, true)
            }
            return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = (value & 0xff)
            } else {
                objectWriteUInt32(this, value, offset, false)
            }
            return offset + 4
        }

        Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1)

                checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = 0
            var mul = 1
            var sub = value < 0 ? 1 : 0
            this[offset] = value & 0xFF
            while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1)

                checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = byteLength - 1
            var mul = 1
            var sub = value < 0 ? 1 : 0
            this[offset + i] = value & 0xFF
            while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
            if (value < 0) value = 0xff + value + 1
            this[offset] = (value & 0xff)
            return offset + 1
        }

        Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
            } else {
                objectWriteUInt16(this, value, offset, true)
            }
            return offset + 2
        }

        Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8)
                this[offset + 1] = (value & 0xff)
            } else {
                objectWriteUInt16(this, value, offset, false)
            }
            return offset + 2
        }

        Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
                this[offset + 2] = (value >>> 16)
                this[offset + 3] = (value >>> 24)
            } else {
                objectWriteUInt32(this, value, offset, true)
            }
            return offset + 4
        }

        Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (value < 0) value = 0xffffffff + value + 1
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = (value & 0xff)
            } else {
                objectWriteUInt32(this, value, offset, false)
            }
            return offset + 4
        }

        function checkIEEE754 (buf, value, offset, ext, max, min) {
            if (value > max || value < min) throw new RangeError('value is out of bounds')
            if (offset + ext > buf.length) throw new RangeError('index out of range')
            if (offset < 0) throw new RangeError('index out of range')
        }

        function writeFloat (buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4)
            return offset + 4
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble (buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8)
            return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert)
        }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy (target, targetStart, start, end) {
            if (!start) start = 0
            if (!end && end !== 0) end = this.length
            if (targetStart >= target.length) targetStart = target.length
            if (!targetStart) targetStart = 0
            if (end > 0 && end < start) end = start

            // Copy 0 bytes; we're done
            if (end === start) return 0
            if (target.length === 0 || this.length === 0) return 0

            // Fatal error conditions
            if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds')
            }
            if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
            if (end < 0) throw new RangeError('sourceEnd out of bounds')

            // Are we oob?
            if (end > this.length) end = this.length
            if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start
            }

            var len = end - start
            var i

            if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (i = len - 1; i >= 0; i--) {
                    target[i + targetStart] = this[i + start]
                }
            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                // ascending copy from start
                for (i = 0; i < len; i++) {
                    target[i + targetStart] = this[i + start]
                }
            } else {
                target._set(this.subarray(start, start + len), targetStart)
            }

            return len
        }

// fill(value, start=0, end=buffer.length)
        Buffer.prototype.fill = function fill (value, start, end) {
            if (!value) value = 0
            if (!start) start = 0
            if (!end) end = this.length

            if (end < start) throw new RangeError('end < start')

            // Fill 0 bytes; we're done
            if (end === start) return
            if (this.length === 0) return

            if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
            if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

            var i
            if (typeof value === 'number') {
                for (i = start; i < end; i++) {
                    this[i] = value
                }
            } else {
                var bytes = utf8ToBytes(value.toString())
                var len = bytes.length
                for (i = start; i < end; i++) {
                    this[i] = bytes[i % len]
                }
            }

            return this
        }

        /**
         * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
         * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
         */
        Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
            if (typeof Uint8Array !== 'undefined') {
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    return (new Buffer(this)).buffer
                } else {
                    var buf = new Uint8Array(this.length)
                    for (var i = 0, len = buf.length; i < len; i += 1) {
                        buf[i] = this[i]
                    }
                    return buf.buffer
                }
            } else {
                throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
            }
        }

// HELPER FUNCTIONS
// ================

        var BP = Buffer.prototype

        /**
         * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
         */
        Buffer._augment = function _augment (arr) {
            arr.constructor = Buffer
            arr._isBuffer = true

            // save reference to original Uint8Array set method before overwriting
            arr._set = arr.set

            // deprecated
            arr.get = BP.get
            arr.set = BP.set

            arr.write = BP.write
            arr.toString = BP.toString
            arr.toLocaleString = BP.toString
            arr.toJSON = BP.toJSON
            arr.equals = BP.equals
            arr.compare = BP.compare
            arr.indexOf = BP.indexOf
            arr.copy = BP.copy
            arr.slice = BP.slice
            arr.readUIntLE = BP.readUIntLE
            arr.readUIntBE = BP.readUIntBE
            arr.readUInt8 = BP.readUInt8
            arr.readUInt16LE = BP.readUInt16LE
            arr.readUInt16BE = BP.readUInt16BE
            arr.readUInt32LE = BP.readUInt32LE
            arr.readUInt32BE = BP.readUInt32BE
            arr.readIntLE = BP.readIntLE
            arr.readIntBE = BP.readIntBE
            arr.readInt8 = BP.readInt8
            arr.readInt16LE = BP.readInt16LE
            arr.readInt16BE = BP.readInt16BE
            arr.readInt32LE = BP.readInt32LE
            arr.readInt32BE = BP.readInt32BE
            arr.readFloatLE = BP.readFloatLE
            arr.readFloatBE = BP.readFloatBE
            arr.readDoubleLE = BP.readDoubleLE
            arr.readDoubleBE = BP.readDoubleBE
            arr.writeUInt8 = BP.writeUInt8
            arr.writeUIntLE = BP.writeUIntLE
            arr.writeUIntBE = BP.writeUIntBE
            arr.writeUInt16LE = BP.writeUInt16LE
            arr.writeUInt16BE = BP.writeUInt16BE
            arr.writeUInt32LE = BP.writeUInt32LE
            arr.writeUInt32BE = BP.writeUInt32BE
            arr.writeIntLE = BP.writeIntLE
            arr.writeIntBE = BP.writeIntBE
            arr.writeInt8 = BP.writeInt8
            arr.writeInt16LE = BP.writeInt16LE
            arr.writeInt16BE = BP.writeInt16BE
            arr.writeInt32LE = BP.writeInt32LE
            arr.writeInt32BE = BP.writeInt32BE
            arr.writeFloatLE = BP.writeFloatLE
            arr.writeFloatBE = BP.writeFloatBE
            arr.writeDoubleLE = BP.writeDoubleLE
            arr.writeDoubleBE = BP.writeDoubleBE
            arr.fill = BP.fill
            arr.inspect = BP.inspect
            arr.toArrayBuffer = BP.toArrayBuffer

            return arr
        }

        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

        function base64clean (str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, '')
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return ''
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
                str = str + '='
            }
            return str
        }

        function stringtrim (str) {
            if (str.trim) return str.trim()
            return str.replace(/^\s+|\s+$/g, '')
        }

        function toHex (n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
        }

        function utf8ToBytes (string, units) {
            units = units || Infinity
            var codePoint
            var length = string.length
            var leadSurrogate = null
            var bytes = []

            for (var i = 0; i < length; i++) {
                codePoint = string.charCodeAt(i)

                // is surrogate component
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                    // last char was a lead
                    if (!leadSurrogate) {
                        // no lead yet
                        if (codePoint > 0xDBFF) {
                            // unexpected trail
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            continue
                        } else if (i + 1 === length) {
                            // unpaired lead
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            continue
                        }

                        // valid lead
                        leadSurrogate = codePoint

                        continue
                    }

                    // 2 leads in a row
                    if (codePoint < 0xDC00) {
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        leadSurrogate = codePoint
                        continue
                    }

                    // valid surrogate pair
                    codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                } else if (leadSurrogate) {
                    // valid bmp char, but last char was a lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                }

                leadSurrogate = null

                // encode utf8
                if (codePoint < 0x80) {
                    if ((units -= 1) < 0) break
                    bytes.push(codePoint)
                } else if (codePoint < 0x800) {
                    if ((units -= 2) < 0) break
                    bytes.push(
                        codePoint >> 0x6 | 0xC0,
                        codePoint & 0x3F | 0x80
                    )
                } else if (codePoint < 0x10000) {
                    if ((units -= 3) < 0) break
                    bytes.push(
                        codePoint >> 0xC | 0xE0,
                        codePoint >> 0x6 & 0x3F | 0x80,
                        codePoint & 0x3F | 0x80
                    )
                } else if (codePoint < 0x110000) {
                    if ((units -= 4) < 0) break
                    bytes.push(
                        codePoint >> 0x12 | 0xF0,
                        codePoint >> 0xC & 0x3F | 0x80,
                        codePoint >> 0x6 & 0x3F | 0x80,
                        codePoint & 0x3F | 0x80
                    )
                } else {
                    throw new Error('Invalid code point')
                }
            }

            return bytes
        }

        function asciiToBytes (str) {
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF)
            }
            return byteArray
        }

        function utf16leToBytes (str, units) {
            var c, hi, lo
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                if ((units -= 2) < 0) break

                c = str.charCodeAt(i)
                hi = c >> 8
                lo = c % 256
                byteArray.push(lo)
                byteArray.push(hi)
            }

            return byteArray
        }

        function base64ToBytes (str) {
            return base64.toByteArray(base64clean(str))
        }

        function blitBuffer (src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
                if ((i + offset >= dst.length) || (i >= src.length)) break
                dst[i + offset] = src[i]
            }
            return i
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":87,"ieee754":93,"isarray":90}],90:[function(require,module,exports){
    var toString = {}.toString;

    module.exports = Array.isArray || function (arr) {
            return toString.call(arr) == '[object Array]';
        };

},{}],91:[function(require,module,exports){
    (function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

        function isArray(arg) {
            if (Array.isArray) {
                return Array.isArray(arg);
            }
            return objectToString(arg) === '[object Array]';
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
            return (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||  // ES6 symbol
                typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = Buffer.isBuffer;

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }

    }).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":95}],92:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
        this._maxListeners = n;
        return this;
    };

    EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;

        if (!this._events)
            this._events = {};

        // If there is no 'error' event listener then throw.
        if (type === 'error') {
            if (!this._events.error ||
                (isObject(this._events.error) && !this._events.error.length)) {
                er = arguments[1];
                if (er instanceof Error) {
                    throw er; // Unhandled 'error' event
                }
                throw TypeError('Uncaught, unspecified "error" event.');
            }
        }

        handler = this._events[type];

        if (isUndefined(handler))
            return false;

        if (isFunction(handler)) {
            switch (arguments.length) {
                // fast cases
                case 1:
                    handler.call(this);
                    break;
                case 2:
                    handler.call(this, arguments[1]);
                    break;
                case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;
                // slower
                default:
                    args = Array.prototype.slice.call(arguments, 1);
                    handler.apply(this, args);
            }
        } else if (isObject(handler)) {
            args = Array.prototype.slice.call(arguments, 1);
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
        }

        return true;
    };

    EventEmitter.prototype.addListener = function(type, listener) {
        var m;

        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        if (!this._events)
            this._events = {};

        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (this._events.newListener)
            this.emit('newListener', type,
                isFunction(listener.listener) ?
                    listener.listener : listener);

        if (!this._events[type])
        // Optimize the case of one listener. Don't need the extra array object.
            this._events[type] = listener;
        else if (isObject(this._events[type]))
        // If we've already got an array, just append.
            this._events[type].push(listener);
        else
        // Adding the second element, need to change to array.
            this._events[type] = [this._events[type], listener];

        // Check for listener leak
        if (isObject(this._events[type]) && !this._events[type].warned) {
            if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
            } else {
                m = EventEmitter.defaultMaxListeners;
            }

            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
                if (typeof console.trace === 'function') {
                    // not supported in IE 10
                    console.trace();
                }
            }
        }

        return this;
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        var fired = false;

        function g() {
            this.removeListener(type, g);

            if (!fired) {
                fired = true;
                listener.apply(this, arguments);
            }
        }

        g.listener = listener;
        this.on(type, g);

        return this;
    };

// emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;

        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        if (!this._events || !this._events[type])
            return this;

        list = this._events[type];
        length = list.length;
        position = -1;

        if (list === listener ||
            (isFunction(list.listener) && list.listener === listener)) {
            delete this._events[type];
            if (this._events.removeListener)
                this.emit('removeListener', type, listener);

        } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
                if (list[i] === listener ||
                    (list[i].listener && list[i].listener === listener)) {
                    position = i;
                    break;
                }
            }

            if (position < 0)
                return this;

            if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
            } else {
                list.splice(position, 1);
            }

            if (this._events.removeListener)
                this.emit('removeListener', type, listener);
        }

        return this;
    };

    EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;

        if (!this._events)
            return this;

        // not listening for removeListener, no need to emit
        if (!this._events.removeListener) {
            if (arguments.length === 0)
                this._events = {};
            else if (this._events[type])
                delete this._events[type];
            return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
            for (key in this._events) {
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
        }

        listeners = this._events[type];

        if (isFunction(listeners)) {
            this.removeListener(type, listeners);
        } else if (listeners) {
            // LIFO order
            while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];

        return this;
    };

    EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type])
            ret = [];
        else if (isFunction(this._events[type]))
            ret = [this._events[type]];
        else
            ret = this._events[type].slice();
        return ret;
    };

    EventEmitter.prototype.listenerCount = function(type) {
        if (this._events) {
            var evlistener = this._events[type];

            if (isFunction(evlistener))
                return 1;
            else if (evlistener)
                return evlistener.length;
        }
        return 0;
    };

    EventEmitter.listenerCount = function(emitter, type) {
        return emitter.listenerCount(type);
    };

    function isFunction(arg) {
        return typeof arg === 'function';
    }

    function isNumber(arg) {
        return typeof arg === 'number';
    }

    function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
    }

    function isUndefined(arg) {
        return arg === void 0;
    }

},{}],93:[function(require,module,exports){
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m
        var eLen = nBytes * 8 - mLen - 1
        var eMax = (1 << eLen) - 1
        var eBias = eMax >> 1
        var nBits = -7
        var i = isLE ? (nBytes - 1) : 0
        var d = isLE ? -1 : 1
        var s = buffer[offset + i]

        i += d

        e = s & ((1 << (-nBits)) - 1)
        s >>= (-nBits)
        nBits += eLen
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1)
        e >>= (-nBits)
        nBits += mLen
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity)
        } else {
            m = m + Math.pow(2, mLen)
            e = e - eBias
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c
        var eLen = nBytes * 8 - mLen - 1
        var eMax = (1 << eLen) - 1
        var eBias = eMax >> 1
        var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
        var i = isLE ? 0 : (nBytes - 1)
        var d = isLE ? 1 : -1
        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

        value = Math.abs(value)

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0
            e = eMax
        } else {
            e = Math.floor(Math.log(value) / Math.LN2)
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--
                c *= 2
            }
            if (e + eBias >= 1) {
                value += rt / c
            } else {
                value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
                e++
                c /= 2
            }

            if (e + eBias >= eMax) {
                m = 0
                e = eMax
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen)
                e = e + eBias
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                e = 0
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m
        eLen += mLen
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128
    }

},{}],94:[function(require,module,exports){
    if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
        }
    }

},{}],95:[function(require,module,exports){
    /**
     * Determine if an object is Buffer
     *
     * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * License:  MIT
     *
     * `npm install is-buffer`
     */

    module.exports = function (obj) {
        return !!(obj != null &&
        (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
            (obj.constructor &&
            typeof obj.constructor.isBuffer === 'function' &&
            obj.constructor.isBuffer(obj))
        ))
    }

},{}],96:[function(require,module,exports){
    module.exports = Array.isArray || function (arr) {
            return Object.prototype.toString.call(arr) == '[object Array]';
        };

},{}],97:[function(require,module,exports){
    (function (process){
        'use strict';

        if (!process.version ||
            process.version.indexOf('v0.') === 0 ||
            process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
            module.exports = nextTick;
        } else {
            module.exports = process.nextTick;
        }

        function nextTick(fn) {
            var args = new Array(arguments.length - 1);
            var i = 0;
            while (i < args.length) {
                args[i++] = arguments[i];
            }
            process.nextTick(function afterTick() {
                fn.apply(null, args);
            });
        }

    }).call(this,require('_process'))
},{"_process":98}],98:[function(require,module,exports){
// shim for using process in browser

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

// v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };

},{}],99:[function(require,module,exports){
    module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":100}],100:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

    'use strict';

    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
            var keys = [];
            for (var key in obj) keys.push(key);
            return keys;
        }
    /*</replacement>*/


    module.exports = Duplex;

    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/



    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/

    var Readable = require('./_stream_readable');
    var Writable = require('./_stream_writable');

    util.inherits(Duplex, Readable);

    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
    }

    function Duplex(options) {
        if (!(this instanceof Duplex))
            return new Duplex(options);

        Readable.call(this, options);
        Writable.call(this, options);

        if (options && options.readable === false)
            this.readable = false;

        if (options && options.writable === false)
            this.writable = false;

        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false;

        this.once('end', onend);
    }

// the no-half-open enforcer
    function onend() {
        // if we allow half-open state, or if the writable side ended,
        // then we're ok.
        if (this.allowHalfOpen || this._writableState.ended)
            return;

        // no more data can be written.
        // But allow more writes to happen in this tick.
        processNextTick(onEndNT, this);
    }

    function onEndNT(self) {
        self.end();
    }

    function forEach (xs, f) {
        for (var i = 0, l = xs.length; i < l; i++) {
            f(xs[i], i);
        }
    }

},{"./_stream_readable":102,"./_stream_writable":104,"core-util-is":91,"inherits":94,"process-nextick-args":97}],101:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

    'use strict';

    module.exports = PassThrough;

    var Transform = require('./_stream_transform');

    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/

    util.inherits(PassThrough, Transform);

    function PassThrough(options) {
        if (!(this instanceof PassThrough))
            return new PassThrough(options);

        Transform.call(this, options);
    }

    PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
    };

},{"./_stream_transform":103,"core-util-is":91,"inherits":94}],102:[function(require,module,exports){
    (function (process){
        'use strict';

        module.exports = Readable;

        /*<replacement>*/
        var processNextTick = require('process-nextick-args');
        /*</replacement>*/


        /*<replacement>*/
        var isArray = require('isarray');
        /*</replacement>*/


        /*<replacement>*/
        var Buffer = require('buffer').Buffer;
        /*</replacement>*/

        Readable.ReadableState = ReadableState;

        var EE = require('events');

        /*<replacement>*/
        var EElistenerCount = function(emitter, type) {
            return emitter.listeners(type).length;
        };
        /*</replacement>*/



        /*<replacement>*/
        var Stream;
        (function (){try{
            Stream = require('st' + 'ream');
        }catch(_){}finally{
            if (!Stream)
                Stream = require('events').EventEmitter;
        }}())
        /*</replacement>*/

        var Buffer = require('buffer').Buffer;

        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/



        /*<replacement>*/
        var debugUtil = require('util');
        var debug;
        if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog('stream');
        } else {
            debug = function () {};
        }
        /*</replacement>*/

        var StringDecoder;

        util.inherits(Readable, Stream);

        function ReadableState(options, stream) {
            var Duplex = require('./_stream_duplex');

            options = options || {};

            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode;

            if (stream instanceof Duplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;

            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

            // cast to ints.
            this.highWaterMark = ~~this.highWaterMark;

            this.buffer = [];
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;

            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';

            // when piping, we only care about 'readable' events that happen
            // after read()ing all the bytes and not getting any pushback.
            this.ranOut = false;

            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0;

            // if true, a maybeReadMore has been scheduled
            this.readingMore = false;

            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
                if (!StringDecoder)
                    StringDecoder = require('string_decoder/').StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
            }
        }

        function Readable(options) {
            var Duplex = require('./_stream_duplex');

            if (!(this instanceof Readable))
                return new Readable(options);

            this._readableState = new ReadableState(options, this);

            // legacy
            this.readable = true;

            if (options && typeof options.read === 'function')
                this._read = options.read;

            Stream.call(this);
        }

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
        Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;

            if (!state.objectMode && typeof chunk === 'string') {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                    chunk = new Buffer(chunk, encoding);
                    encoding = '';
                }
            }

            return readableAddChunk(this, state, chunk, encoding, false);
        };

// Unshift should *always* be something directly out of read()
        Readable.prototype.unshift = function(chunk) {
            var state = this._readableState;
            return readableAddChunk(this, state, chunk, '', true);
        };

        Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false;
        };

        function readableAddChunk(stream, state, chunk, encoding, addToFront) {
            var er = chunkInvalid(state, chunk);
            if (er) {
                stream.emit('error', er);
            } else if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
            } else if (state.objectMode || chunk && chunk.length > 0) {
                if (state.ended && !addToFront) {
                    var e = new Error('stream.push() after EOF');
                    stream.emit('error', e);
                } else if (state.endEmitted && addToFront) {
                    var e = new Error('stream.unshift() after end event');
                    stream.emit('error', e);
                } else {
                    if (state.decoder && !addToFront && !encoding)
                        chunk = state.decoder.write(chunk);

                    if (!addToFront)
                        state.reading = false;

                    // if we want the data now, just emit it.
                    if (state.flowing && state.length === 0 && !state.sync) {
                        stream.emit('data', chunk);
                        stream.read(0);
                    } else {
                        // update the buffer info.
                        state.length += state.objectMode ? 1 : chunk.length;
                        if (addToFront)
                            state.buffer.unshift(chunk);
                        else
                            state.buffer.push(chunk);

                        if (state.needReadable)
                            emitReadable(stream);
                    }

                    maybeReadMore(stream, state);
                }
            } else if (!addToFront) {
                state.reading = false;
            }

            return needMoreData(state);
        }


// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
        function needMoreData(state) {
            return !state.ended &&
                (state.needReadable ||
                state.length < state.highWaterMark ||
                state.length === 0);
        }

// backwards compatibility.
        Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
        };

// Don't raise the hwm > 8MB
        var MAX_HWM = 0x800000;
        function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
                n = MAX_HWM;
            } else {
                // Get the next highest power of 2
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
            }
            return n;
        }

        function howMuchToRead(n, state) {
            if (state.length === 0 && state.ended)
                return 0;

            if (state.objectMode)
                return n === 0 ? 0 : 1;

            if (n === null || isNaN(n)) {
                // only flow one buffer at a time
                if (state.flowing && state.buffer.length)
                    return state.buffer[0].length;
                else
                    return state.length;
            }

            if (n <= 0)
                return 0;

            // If we're asking for more than the target buffer level,
            // then raise the water mark.  Bump up to the next highest
            // power of 2, to prevent increasing it excessively in tiny
            // amounts.
            if (n > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n);

            // don't have that much.  return null, unless we've ended.
            if (n > state.length) {
                if (!state.ended) {
                    state.needReadable = true;
                    return 0;
                } else {
                    return state.length;
                }
            }

            return n;
        }

// you can override either this method, or the async _read(n) below.
        Readable.prototype.read = function(n) {
            debug('read', n);
            var state = this._readableState;
            var nOrig = n;

            if (typeof n !== 'number' || n > 0)
                state.emittedReadable = false;

            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (n === 0 &&
                state.needReadable &&
                (state.length >= state.highWaterMark || state.ended)) {
                debug('read: emitReadable', state.length, state.ended);
                if (state.length === 0 && state.ended)
                    endReadable(this);
                else
                    emitReadable(this);
                return null;
            }

            n = howMuchToRead(n, state);

            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
                if (state.length === 0)
                    endReadable(this);
                return null;
            }

            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.

            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable;
            debug('need readable', doRead);

            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug('length less than watermark', doRead);
            }

            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
                doRead = false;
                debug('reading or ended', doRead);
            }

            if (doRead) {
                debug('do read');
                state.reading = true;
                state.sync = true;
                // if the length is currently zero, then we *need* a readable event.
                if (state.length === 0)
                    state.needReadable = true;
                // call internal read method
                this._read(state.highWaterMark);
                state.sync = false;
            }

            // If _read pushed data synchronously, then `reading` will be false,
            // and we need to re-evaluate how much data we can return to the user.
            if (doRead && !state.reading)
                n = howMuchToRead(nOrig, state);

            var ret;
            if (n > 0)
                ret = fromList(n, state);
            else
                ret = null;

            if (ret === null) {
                state.needReadable = true;
                n = 0;
            }

            state.length -= n;

            // If we have nothing in the buffer, then we want to know
            // as soon as we *do* get something into the buffer.
            if (state.length === 0 && !state.ended)
                state.needReadable = true;

            // If we tried to read() past the EOF, then emit end on the next tick.
            if (nOrig !== n && state.ended && state.length === 0)
                endReadable(this);

            if (ret !== null)
                this.emit('data', ret);

            return ret;
        };

        function chunkInvalid(state, chunk) {
            var er = null;
            if (!(Buffer.isBuffer(chunk)) &&
                typeof chunk !== 'string' &&
                chunk !== null &&
                chunk !== undefined &&
                !state.objectMode) {
                er = new TypeError('Invalid non-string/buffer chunk');
            }
            return er;
        }


        function onEofChunk(stream, state) {
            if (state.ended) return;
            if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                }
            }
            state.ended = true;

            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream);
        }

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
        function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
                debug('emitReadable', state.flowing);
                state.emittedReadable = true;
                if (state.sync)
                    processNextTick(emitReadable_, stream);
                else
                    emitReadable_(stream);
            }
        }

        function emitReadable_(stream) {
            debug('emit readable');
            stream.emit('readable');
            flow(stream);
        }


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
        function maybeReadMore(stream, state) {
            if (!state.readingMore) {
                state.readingMore = true;
                processNextTick(maybeReadMore_, stream, state);
            }
        }

        function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended &&
            state.length < state.highWaterMark) {
                debug('maybeReadMore read 0');
                stream.read(0);
                if (len === state.length)
                // didn't get any data, stop spinning.
                    break;
                else
                    len = state.length;
            }
            state.readingMore = false;
        }

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
        Readable.prototype._read = function(n) {
            this.emit('error', new Error('not implemented'));
        };

        Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;

            switch (state.pipesCount) {
                case 0:
                    state.pipes = dest;
                    break;
                case 1:
                    state.pipes = [state.pipes, dest];
                    break;
                default:
                    state.pipes.push(dest);
                    break;
            }
            state.pipesCount += 1;
            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

            var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                dest !== process.stdout &&
                dest !== process.stderr;

            var endFn = doEnd ? onend : cleanup;
            if (state.endEmitted)
                processNextTick(endFn);
            else
                src.once('end', endFn);

            dest.on('unpipe', onunpipe);
            function onunpipe(readable) {
                debug('onunpipe');
                if (readable === src) {
                    cleanup();
                }
            }

            function onend() {
                debug('onend');
                dest.end();
            }

            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);

            var cleanedUp = false;
            function cleanup() {
                debug('cleanup');
                // cleanup event handlers once the pipe is broken
                dest.removeListener('close', onclose);
                dest.removeListener('finish', onfinish);
                dest.removeListener('drain', ondrain);
                dest.removeListener('error', onerror);
                dest.removeListener('unpipe', onunpipe);
                src.removeListener('end', onend);
                src.removeListener('end', cleanup);
                src.removeListener('data', ondata);

                cleanedUp = true;

                // if the reader is waiting for a drain event from this
                // specific writer, then it would cause it to never start
                // flowing again.
                // So, if this is awaiting a drain, then we just call it now.
                // If we don't know, then assume that we are waiting for one.
                if (state.awaitDrain &&
                    (!dest._writableState || dest._writableState.needDrain))
                    ondrain();
            }

            src.on('data', ondata);
            function ondata(chunk) {
                debug('ondata');
                var ret = dest.write(chunk);
                if (false === ret) {
                    // If the user unpiped during `dest.write()`, it is possible
                    // to get stuck in a permanently paused state if that write
                    // also returned false.
                    if (state.pipesCount === 1 &&
                        state.pipes[0] === dest &&
                        src.listenerCount('data') === 1 &&
                        !cleanedUp) {
                        debug('false write response, pause', src._readableState.awaitDrain);
                        src._readableState.awaitDrain++;
                    }
                    src.pause();
                }
            }

            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
                debug('onerror', er);
                unpipe();
                dest.removeListener('error', onerror);
                if (EElistenerCount(dest, 'error') === 0)
                    dest.emit('error', er);
            }
            // This is a brutally ugly hack to make sure that our error handler
            // is attached before any userland ones.  NEVER DO THIS.
            if (!dest._events || !dest._events.error)
                dest.on('error', onerror);
            else if (isArray(dest._events.error))
                dest._events.error.unshift(onerror);
            else
                dest._events.error = [onerror, dest._events.error];


            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
                dest.removeListener('finish', onfinish);
                unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
                debug('onfinish');
                dest.removeListener('close', onclose);
                unpipe();
            }
            dest.once('finish', onfinish);

            function unpipe() {
                debug('unpipe');
                src.unpipe(dest);
            }

            // tell the dest that it's being piped to
            dest.emit('pipe', src);

            // start the flow if it hasn't been started already.
            if (!state.flowing) {
                debug('pipe resume');
                src.resume();
            }

            return dest;
        };

        function pipeOnDrain(src) {
            return function() {
                var state = src._readableState;
                debug('pipeOnDrain', state.awaitDrain);
                if (state.awaitDrain)
                    state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                    state.flowing = true;
                    flow(src);
                }
            };
        }


        Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;

            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0)
                return this;

            // just one destination.  most common case.
            if (state.pipesCount === 1) {
                // passed in one, but it's not the right one.
                if (dest && dest !== state.pipes)
                    return this;

                if (!dest)
                    dest = state.pipes;

                // got a match.
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                    dest.emit('unpipe', this);
                return this;
            }

            // slow case. multiple pipe destinations.

            if (!dest) {
                // remove all.
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;

                for (var i = 0; i < len; i++)
                    dests[i].emit('unpipe', this);
                return this;
            }

            // try to find the right one.
            var i = indexOf(state.pipes, dest);
            if (i === -1)
                return this;

            state.pipes.splice(i, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
                state.pipes = state.pipes[0];

            dest.emit('unpipe', this);

            return this;
        };

// set up data events if they are asked for
// Ensure readable listeners eventually get something
        Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);

            // If listening to data, and it has not explicitly been paused,
            // then call resume to start the flow of data on the next tick.
            if (ev === 'data' && false !== this._readableState.flowing) {
                this.resume();
            }

            if (ev === 'readable' && this.readable) {
                var state = this._readableState;
                if (!state.readableListening) {
                    state.readableListening = true;
                    state.emittedReadable = false;
                    state.needReadable = true;
                    if (!state.reading) {
                        processNextTick(nReadingNextTick, this);
                    } else if (state.length) {
                        emitReadable(this, state);
                    }
                }
            }

            return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;

        function nReadingNextTick(self) {
            debug('readable nexttick read 0');
            self.read(0);
        }

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
        Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
                debug('resume');
                state.flowing = true;
                resume(this, state);
            }
            return this;
        };

        function resume(stream, state) {
            if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                processNextTick(resume_, stream, state);
            }
        }

        function resume_(stream, state) {
            if (!state.reading) {
                debug('resume read 0');
                stream.read(0);
            }

            state.resumeScheduled = false;
            stream.emit('resume');
            flow(stream);
            if (state.flowing && !state.reading)
                stream.read(0);
        }

        Readable.prototype.pause = function() {
            debug('call pause flowing=%j', this._readableState.flowing);
            if (false !== this._readableState.flowing) {
                debug('pause');
                this._readableState.flowing = false;
                this.emit('pause');
            }
            return this;
        };

        function flow(stream) {
            var state = stream._readableState;
            debug('flow', state.flowing);
            if (state.flowing) {
                do {
                    var chunk = stream.read();
                } while (null !== chunk && state.flowing);
            }
        }

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
        Readable.prototype.wrap = function(stream) {
            var state = this._readableState;
            var paused = false;

            var self = this;
            stream.on('end', function() {
                debug('wrapped end');
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length)
                        self.push(chunk);
                }

                self.push(null);
            });

            stream.on('data', function(chunk) {
                debug('wrapped data');
                if (state.decoder)
                    chunk = state.decoder.write(chunk);

                // don't skip over falsy values in objectMode
                if (state.objectMode && (chunk === null || chunk === undefined))
                    return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                    return;

                var ret = self.push(chunk);
                if (!ret) {
                    paused = true;
                    stream.pause();
                }
            });

            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
                if (this[i] === undefined && typeof stream[i] === 'function') {
                    this[i] = function(method) { return function() {
                        return stream[method].apply(stream, arguments);
                    }; }(i);
                }
            }

            // proxy certain important events.
            var events = ['error', 'close', 'destroy', 'pause', 'resume'];
            forEach(events, function(ev) {
                stream.on(ev, self.emit.bind(self, ev));
            });

            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            self._read = function(n) {
                debug('wrapped _read', n);
                if (paused) {
                    paused = false;
                    stream.resume();
                }
            };

            return self;
        };


// exposed for testing purposes only.
        Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
        function fromList(n, state) {
            var list = state.buffer;
            var length = state.length;
            var stringMode = !!state.decoder;
            var objectMode = !!state.objectMode;
            var ret;

            // nothing in the list, definitely empty.
            if (list.length === 0)
                return null;

            if (length === 0)
                ret = null;
            else if (objectMode)
                ret = list.shift();
            else if (!n || n >= length) {
                // read it all, truncate the array.
                if (stringMode)
                    ret = list.join('');
                else if (list.length === 1)
                    ret = list[0];
                else
                    ret = Buffer.concat(list, length);
                list.length = 0;
            } else {
                // read just some of it.
                if (n < list[0].length) {
                    // just take a part of the first list item.
                    // slice is the same for buffers and strings.
                    var buf = list[0];
                    ret = buf.slice(0, n);
                    list[0] = buf.slice(n);
                } else if (n === list[0].length) {
                    // first list is a perfect match
                    ret = list.shift();
                } else {
                    // complex case.
                    // we have enough to cover it, but it spans past the first buffer.
                    if (stringMode)
                        ret = '';
                    else
                        ret = new Buffer(n);

                    var c = 0;
                    for (var i = 0, l = list.length; i < l && c < n; i++) {
                        var buf = list[0];
                        var cpy = Math.min(n - c, buf.length);

                        if (stringMode)
                            ret += buf.slice(0, cpy);
                        else
                            buf.copy(ret, c, 0, cpy);

                        if (cpy < buf.length)
                            list[0] = buf.slice(cpy);
                        else
                            list.shift();

                        c += cpy;
                    }
                }
            }

            return ret;
        }

        function endReadable(stream) {
            var state = stream._readableState;

            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
                throw new Error('endReadable called on non-empty stream');

            if (!state.endEmitted) {
                state.ended = true;
                processNextTick(endReadableNT, state, stream);
            }
        }

        function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit('end');
            }
        }

        function forEach (xs, f) {
            for (var i = 0, l = xs.length; i < l; i++) {
                f(xs[i], i);
            }
        }

        function indexOf (xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) return i;
            }
            return -1;
        }

    }).call(this,require('_process'))
},{"./_stream_duplex":100,"_process":98,"buffer":89,"core-util-is":91,"events":92,"inherits":94,"isarray":96,"process-nextick-args":97,"string_decoder/":110,"util":88}],103:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

    'use strict';

    module.exports = Transform;

    var Duplex = require('./_stream_duplex');

    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/

    util.inherits(Transform, Duplex);


    function TransformState(stream) {
        this.afterTransform = function(er, data) {
            return afterTransform(stream, er, data);
        };

        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
    }

    function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;

        var cb = ts.writecb;

        if (!cb)
            return stream.emit('error', new Error('no writecb in Transform class'));

        ts.writechunk = null;
        ts.writecb = null;

        if (data !== null && data !== undefined)
            stream.push(data);

        if (cb)
            cb(er);

        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
            stream._read(rs.highWaterMark);
        }
    }


    function Transform(options) {
        if (!(this instanceof Transform))
            return new Transform(options);

        Duplex.call(this, options);

        this._transformState = new TransformState(this);

        // when the writable side finishes, then flush out anything remaining.
        var stream = this;

        // start out asking for a readable event once data is transformed.
        this._readableState.needReadable = true;

        // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.
        this._readableState.sync = false;

        if (options) {
            if (typeof options.transform === 'function')
                this._transform = options.transform;

            if (typeof options.flush === 'function')
                this._flush = options.flush;
        }

        this.once('prefinish', function() {
            if (typeof this._flush === 'function')
                this._flush(function(er) {
                    done(stream, er);
                });
            else
                done(stream);
        });
    }

    Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
    };

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error('not implemented');
    };

    Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform ||
                rs.needReadable ||
                rs.length < rs.highWaterMark)
                this._read(rs.highWaterMark);
        }
    };

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
        var ts = this._transformState;

        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true;
        }
    };


    function done(stream, er) {
        if (er)
            return stream.emit('error', er);

        // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided
        var ws = stream._writableState;
        var ts = stream._transformState;

        if (ws.length)
            throw new Error('calling transform done when ws.length != 0');

        if (ts.transforming)
            throw new Error('calling transform done when still transforming');

        return stream.push(null);
    }

},{"./_stream_duplex":100,"core-util-is":91,"inherits":94}],104:[function(require,module,exports){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

    'use strict';

    module.exports = Writable;

    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/


    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/

    Writable.WritableState = WritableState;


    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/


    /*<replacement>*/
    var internalUtil = {
        deprecate: require('util-deprecate')
    };
    /*</replacement>*/



    /*<replacement>*/
    var Stream;
    (function (){try{
        Stream = require('st' + 'ream');
    }catch(_){}finally{
        if (!Stream)
            Stream = require('events').EventEmitter;
    }}())
    /*</replacement>*/

    var Buffer = require('buffer').Buffer;

    util.inherits(Writable, Stream);

    function nop() {}

    function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null;
    }

    function WritableState(options, stream) {
        var Duplex = require('./_stream_duplex');

        options = options || {};

        // object stream flag to indicate whether or not this stream
        // contains buffers or objects.
        this.objectMode = !!options.objectMode;

        if (stream instanceof Duplex)
            this.objectMode = this.objectMode || !!options.writableObjectMode;

        // the point at which write() starts returning false
        // Note: 0 is a valid value, means that we always return false if
        // the entire buffer is not flushed immediately on write()
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

        // cast to ints.
        this.highWaterMark = ~~this.highWaterMark;

        this.needDrain = false;
        // at the start of calling end()
        this.ending = false;
        // when end() has been called, and returned
        this.ended = false;
        // when 'finish' is emitted
        this.finished = false;

        // should we decode strings into buffers before passing to _write?
        // this is here so that some node-core streams can optimize string
        // handling at a lower level.
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;

        // Crypto is kind of old and crusty.  Historically, its default string
        // encoding is 'binary' so we have to make this configurable.
        // Everything else in the universe uses 'utf8', though.
        this.defaultEncoding = options.defaultEncoding || 'utf8';

        // not an actual buffer we keep track of, but a measurement
        // of how much we're waiting to get pushed to some underlying
        // socket or file.
        this.length = 0;

        // a flag to see when we're in the middle of a write.
        this.writing = false;

        // when true all writes will be buffered until .uncork() call
        this.corked = 0;

        // a flag to be able to tell if the onwrite cb is called immediately,
        // or on a later tick.  We set this to true at first, because any
        // actions that shouldn't happen until "later" should generally also
        // not happen before the first write call.
        this.sync = true;

        // a flag to know if we're processing previously buffered items, which
        // may call the _write() callback in the same tick, so that we don't
        // end up in an overlapped onwrite situation.
        this.bufferProcessing = false;

        // the callback that's passed to _write(chunk,cb)
        this.onwrite = function(er) {
            onwrite(stream, er);
        };

        // the callback that the user supplies to write(chunk,encoding,cb)
        this.writecb = null;

        // the amount that is being written when _write is called.
        this.writelen = 0;

        this.bufferedRequest = null;
        this.lastBufferedRequest = null;

        // number of pending user-supplied write callbacks
        // this must be 0 before 'finish' can be emitted
        this.pendingcb = 0;

        // emit prefinish if the only thing we're waiting for is _write cbs
        // This is relevant for synchronous Transform streams
        this.prefinished = false;

        // True if the error was already emitted and should not be thrown again
        this.errorEmitted = false;
    }

    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
            out.push(current);
            current = current.next;
        }
        return out;
    };

    (function (){try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
            get: internalUtil.deprecate(function() {
                return this.getBuffer();
            }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +
                'instead.')
        });
    }catch(_){}}());


    function Writable(options) {
        var Duplex = require('./_stream_duplex');

        // Writable ctor is applied to Duplexes, though they're not
        // instanceof Writable, they're instanceof Readable.
        if (!(this instanceof Writable) && !(this instanceof Duplex))
            return new Writable(options);

        this._writableState = new WritableState(options, this);

        // legacy.
        this.writable = true;

        if (options) {
            if (typeof options.write === 'function')
                this._write = options.write;

            if (typeof options.writev === 'function')
                this._writev = options.writev;
        }

        Stream.call(this);
    }

// Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
        this.emit('error', new Error('Cannot pipe. Not readable.'));
    };


    function writeAfterEnd(stream, cb) {
        var er = new Error('write after end');
        // TODO: defer error events consistently everywhere, not just the cb
        stream.emit('error', er);
        processNextTick(cb, er);
    }

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
        var valid = true;

        if (!(Buffer.isBuffer(chunk)) &&
            typeof chunk !== 'string' &&
            chunk !== null &&
            chunk !== undefined &&
            !state.objectMode) {
            var er = new TypeError('Invalid non-string/buffer chunk');
            stream.emit('error', er);
            processNextTick(cb, er);
            valid = false;
        }
        return valid;
    }

    Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;

        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = null;
        }

        if (Buffer.isBuffer(chunk))
            encoding = 'buffer';
        else if (!encoding)
            encoding = state.defaultEncoding;

        if (typeof cb !== 'function')
            cb = nop;

        if (state.ended)
            writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
            state.pendingcb++;
            ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }

        return ret;
    };

    Writable.prototype.cork = function() {
        var state = this._writableState;

        state.corked++;
    };

    Writable.prototype.uncork = function() {
        var state = this._writableState;

        if (state.corked) {
            state.corked--;

            if (!state.writing &&
                !state.corked &&
                !state.finished &&
                !state.bufferProcessing &&
                state.bufferedRequest)
                clearBuffer(this, state);
        }
    };

    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        // node::ParseEncoding() requires lower case.
        if (typeof encoding === 'string')
            encoding = encoding.toLowerCase();
        if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
                'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
                .indexOf((encoding + '').toLowerCase()) > -1))
            throw new TypeError('Unknown encoding: ' + encoding);
        this._writableState.defaultEncoding = encoding;
    };

    function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode &&
            state.decodeStrings !== false &&
            typeof chunk === 'string') {
            chunk = new Buffer(chunk, encoding);
        }
        return chunk;
    }

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
        chunk = decodeChunk(state, chunk, encoding);

        if (Buffer.isBuffer(chunk))
            encoding = 'buffer';
        var len = state.objectMode ? 1 : chunk.length;

        state.length += len;

        var ret = state.length < state.highWaterMark;
        // we must ensure that previous needDrain will not be reset to false.
        if (!ret)
            state.needDrain = true;

        if (state.writing || state.corked) {
            var last = state.lastBufferedRequest;
            state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
            if (last) {
                last.next = state.lastBufferedRequest;
            } else {
                state.bufferedRequest = state.lastBufferedRequest;
            }
        } else {
            doWrite(stream, state, false, len, chunk, encoding, cb);
        }

        return ret;
    }

    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev)
            stream._writev(chunk, state.onwrite);
        else
            stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
    }

    function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync)
            processNextTick(cb, er);
        else
            cb(er);

        stream._writableState.errorEmitted = true;
        stream.emit('error', er);
    }

    function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
    }

    function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;

        onwriteStateUpdate(state);

        if (er)
            onwriteError(stream, state, sync, er, cb);
        else {
            // Check if we're actually ready to finish, but don't emit yet
            var finished = needFinish(state);

            if (!finished &&
                !state.corked &&
                !state.bufferProcessing &&
                state.bufferedRequest) {
                clearBuffer(stream, state);
            }

            if (sync) {
                processNextTick(afterWrite, stream, state, finished, cb);
            } else {
                afterWrite(stream, state, finished, cb);
            }
        }
    }

    function afterWrite(stream, state, finished, cb) {
        if (!finished)
            onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
    }

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
            state.needDrain = false;
            stream.emit('drain');
        }
    }


// if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;

        if (stream._writev && entry && entry.next) {
            // Fast case, write everything using _writev()
            var buffer = [];
            var cbs = [];
            while (entry) {
                cbs.push(entry.callback);
                buffer.push(entry);
                entry = entry.next;
            }

            // count the one we are adding, as well.
            // TODO(isaacs) clean this up
            state.pendingcb++;
            state.lastBufferedRequest = null;
            doWrite(stream, state, true, state.length, buffer, '', function(err) {
                for (var i = 0; i < cbs.length; i++) {
                    state.pendingcb--;
                    cbs[i](err);
                }
            });

            // Clear buffer
        } else {
            // Slow case, write chunks one-by-one
            while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;

                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                    break;
                }
            }

            if (entry === null)
                state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
    }

    Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error('not implemented'));
    };

    Writable.prototype._writev = null;

    Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;

        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = null;
            encoding = null;
        } else if (typeof encoding === 'function') {
            cb = encoding;
            encoding = null;
        }

        if (chunk !== null && chunk !== undefined)
            this.write(chunk, encoding);

        // .end() fully uncorks
        if (state.corked) {
            state.corked = 1;
            this.uncork();
        }

        // ignore unnecessary end() calls.
        if (!state.ending && !state.finished)
            endWritable(this, state, cb);
    };


    function needFinish(state) {
        return (state.ending &&
        state.length === 0 &&
        state.bufferedRequest === null &&
        !state.finished &&
        !state.writing);
    }

    function prefinish(stream, state) {
        if (!state.prefinished) {
            state.prefinished = true;
            stream.emit('prefinish');
        }
    }

    function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
            if (state.pendingcb === 0) {
                prefinish(stream, state);
                state.finished = true;
                stream.emit('finish');
            } else {
                prefinish(stream, state);
            }
        }
        return need;
    }

    function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
            if (state.finished)
                processNextTick(cb);
            else
                stream.once('finish', cb);
        }
        state.ended = true;
    }

},{"./_stream_duplex":100,"buffer":89,"core-util-is":91,"events":92,"inherits":94,"process-nextick-args":97,"util-deprecate":111}],105:[function(require,module,exports){
    module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":101}],106:[function(require,module,exports){
    var Stream = (function (){
        try {
            return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
        } catch(_){}
    }());
    exports = module.exports = require('./lib/_stream_readable.js');
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require('./lib/_stream_writable.js');
    exports.Duplex = require('./lib/_stream_duplex.js');
    exports.Transform = require('./lib/_stream_transform.js');
    exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":100,"./lib/_stream_passthrough.js":101,"./lib/_stream_readable.js":102,"./lib/_stream_transform.js":103,"./lib/_stream_writable.js":104}],107:[function(require,module,exports){
    module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":103}],108:[function(require,module,exports){
    module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":104}],109:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    module.exports = Stream;

    var EE = require('events').EventEmitter;
    var inherits = require('inherits');

    inherits(Stream, EE);
    Stream.Readable = require('readable-stream/readable.js');
    Stream.Writable = require('readable-stream/writable.js');
    Stream.Duplex = require('readable-stream/duplex.js');
    Stream.Transform = require('readable-stream/transform.js');
    Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
    Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

    function Stream() {
        EE.call(this);
    }

    Stream.prototype.pipe = function(dest, options) {
        var source = this;

        function ondata(chunk) {
            if (dest.writable) {
                if (false === dest.write(chunk) && source.pause) {
                    source.pause();
                }
            }
        }

        source.on('data', ondata);

        function ondrain() {
            if (source.readable && source.resume) {
                source.resume();
            }
        }

        dest.on('drain', ondrain);

        // If the 'end' option is not supplied, dest.end() will be called when
        // source gets the 'end' or 'close' events.  Only dest.end() once.
        if (!dest._isStdio && (!options || options.end !== false)) {
            source.on('end', onend);
            source.on('close', onclose);
        }

        var didOnEnd = false;
        function onend() {
            if (didOnEnd) return;
            didOnEnd = true;

            dest.end();
        }


        function onclose() {
            if (didOnEnd) return;
            didOnEnd = true;

            if (typeof dest.destroy === 'function') dest.destroy();
        }

        // don't leave dangling pipes when there are errors.
        function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, 'error') === 0) {
                throw er; // Unhandled stream error in pipe.
            }
        }

        source.on('error', onerror);
        dest.on('error', onerror);

        // remove all the event listeners that were added.
        function cleanup() {
            source.removeListener('data', ondata);
            dest.removeListener('drain', ondrain);

            source.removeListener('end', onend);
            source.removeListener('close', onclose);

            source.removeListener('error', onerror);
            dest.removeListener('error', onerror);

            source.removeListener('end', cleanup);
            source.removeListener('close', cleanup);

            dest.removeListener('close', cleanup);
        }

        source.on('end', cleanup);
        source.on('close', cleanup);

        dest.on('close', cleanup);

        dest.emit('pipe', source);

        // Allow for unix-like usage: A.pipe(B).pipe(C)
        return dest;
    };

},{"events":92,"inherits":94,"readable-stream/duplex.js":99,"readable-stream/passthrough.js":105,"readable-stream/readable.js":106,"readable-stream/transform.js":107,"readable-stream/writable.js":108}],110:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    var Buffer = require('buffer').Buffer;

    var isBufferEncoding = Buffer.isEncoding
        || function(encoding) {
            switch (encoding && encoding.toLowerCase()) {
                case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
                default: return false;
            }
        }


    function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
            throw new Error('Unknown encoding: ' + encoding);
        }
    }

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
    var StringDecoder = exports.StringDecoder = function(encoding) {
        this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
        assertEncoding(encoding);
        switch (this.encoding) {
            case 'utf8':
                // CESU-8 represents each of Surrogate Pair by 3-bytes
                this.surrogateSize = 3;
                break;
            case 'ucs2':
            case 'utf16le':
                // UTF-16 represents each of Surrogate Pair by 2-bytes
                this.surrogateSize = 2;
                this.detectIncompleteChar = utf16DetectIncompleteChar;
                break;
            case 'base64':
                // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
                this.surrogateSize = 3;
                this.detectIncompleteChar = base64DetectIncompleteChar;
                break;
            default:
                this.write = passThroughWrite;
                return;
        }

        // Enough space to store all bytes of a single character. UTF-8 needs 4
        // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
        this.charBuffer = new Buffer(6);
        // Number of bytes received for the current incomplete multi-byte character.
        this.charReceived = 0;
        // Number of bytes expected for the current incomplete multi-byte character.
        this.charLength = 0;
    };


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
        var charStr = '';
        // if our last write ended with an incomplete multibyte character
        while (this.charLength) {
            // determine how many remaining bytes this buffer has to offer for this char
            var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
                buffer.length;

            // add the new bytes to the char buffer
            buffer.copy(this.charBuffer, this.charReceived, 0, available);
            this.charReceived += available;

            if (this.charReceived < this.charLength) {
                // still not enough chars in this buffer? wait for more ...
                return '';
            }

            // remove bytes belonging to the current character from the buffer
            buffer = buffer.slice(available, buffer.length);

            // get the character that was split
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

            // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                this.charLength += this.surrogateSize;
                charStr = '';
                continue;
            }
            this.charReceived = this.charLength = 0;

            // if there are no more bytes in this buffer, just emit our char
            if (buffer.length === 0) {
                return charStr;
            }
            break;
        }

        // determine and set charLength / charReceived
        this.detectIncompleteChar(buffer);

        var end = buffer.length;
        if (this.charLength) {
            // buffer the incomplete character bytes we got
            buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
            end -= this.charReceived;
        }

        charStr += buffer.toString(this.encoding, 0, end);

        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            buffer.copy(this.charBuffer, 0, 0, size);
            return charStr.substring(0, end);
        }

        // or just emit the charStr
        return charStr;
    };

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        // determine how many bytes we have to check at the end of this buffer
        var i = (buffer.length >= 3) ? 3 : buffer.length;

        // Figure out if one of the last i bytes of our buffer announces an
        // incomplete char.
        for (; i > 0; i--) {
            var c = buffer[buffer.length - i];

            // See http://en.wikipedia.org/wiki/UTF-8#Description

            // 110XXXXX
            if (i == 1 && c >> 5 == 0x06) {
                this.charLength = 2;
                break;
            }

            // 1110XXXX
            if (i <= 2 && c >> 4 == 0x0E) {
                this.charLength = 3;
                break;
            }

            // 11110XXX
            if (i <= 3 && c >> 3 == 0x1E) {
                this.charLength = 4;
                break;
            }
        }
        this.charReceived = i;
    };

    StringDecoder.prototype.end = function(buffer) {
        var res = '';
        if (buffer && buffer.length)
            res = this.write(buffer);

        if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
        }

        return res;
    };

    function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
    }

    function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
    }

    function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
    }

},{"buffer":89}],111:[function(require,module,exports){
    (function (global){

        /**
         * Module exports.
         */

        module.exports = deprecate;

        /**
         * Mark that a method should not be used.
         * Returns a modified function which warns once by default.
         *
         * If `localStorage.noDeprecation = true` is set, then it is a no-op.
         *
         * If `localStorage.throwDeprecation = true` is set, then deprecated functions
         * will throw an Error when invoked.
         *
         * If `localStorage.traceDeprecation = true` is set, then deprecated functions
         * will invoke `console.trace()` instead of `console.error()`.
         *
         * @param {Function} fn - the function to deprecate
         * @param {String} msg - the string to print to the console when `fn` is invoked
         * @returns {Function} a new "deprecated" version of `fn`
         * @api public
         */

        function deprecate (fn, msg) {
            if (config('noDeprecation')) {
                return fn;
            }

            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (config('throwDeprecation')) {
                        throw new Error(msg);
                    } else if (config('traceDeprecation')) {
                        console.trace(msg);
                    } else {
                        console.warn(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }

            return deprecated;
        }

        /**
         * Checks `localStorage` for boolean values for the given `name`.
         *
         * @param {String} name
         * @returns {Boolean}
         * @api private
         */

        function config (name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
                if (!global.localStorage) return false;
            } catch (_) {
                return false;
            }
            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === 'true';
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],112:[function(require,module,exports){
    module.exports = function isBuffer(arg) {
        return arg && typeof arg === 'object'
            && typeof arg.copy === 'function'
            && typeof arg.fill === 'function'
            && typeof arg.readUInt8 === 'function';
    }
},{}],113:[function(require,module,exports){
    (function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        var formatRegExp = /%[sdj%]/g;
        exports.format = function(f) {
            if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                    case '%s': return String(args[i++]);
                    case '%d': return Number(args[i++]);
                    case '%j':
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return '[Circular]';
                        }
                    default:
                        return x;
                }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                    str += ' ' + x;
                } else {
                    str += ' ' + inspect(x);
                }
            }
            return str;
        };


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
        exports.deprecate = function(fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
                return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
            }

            if (process.noDeprecation === true) {
                return fn;
            }

            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (process.throwDeprecation) {
                        throw new Error(msg);
                    } else if (process.traceDeprecation) {
                        console.trace(msg);
                    } else {
                        console.error(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }

            return deprecated;
        };


        var debugs = {};
        var debugEnviron;
        exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports.format.apply(exports, arguments);
                        console.error('%s %d: %s', set, pid, msg);
                    };
                } else {
                    debugs[set] = function() {};
                }
            }
            return debugs[set];
        };


        /**
         * Echos the value of a value. Trys to print the value out
         * in the best way possible given the different types.
         *
         * @param {Object} obj The object to print out.
         * @param {Object} opts Optional options object that alters the output.
         */
        /* legacy: obj, showHidden, depth, colors*/
        function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
            };
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
            } else if (opts) {
                // got an "options" object
                exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
            'bold' : [1, 22],
            'italic' : [3, 23],
            'underline' : [4, 24],
            'inverse' : [7, 27],
            'white' : [37, 39],
            'grey' : [90, 39],
            'black' : [30, 39],
            'blue' : [34, 39],
            'cyan' : [36, 39],
            'green' : [32, 39],
            'magenta' : [35, 39],
            'red' : [31, 39],
            'yellow' : [33, 39]
        };

// Don't use 'blue' not visible on cmd.exe
        inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
        };


        function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                    '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
                return str;
            }
        }


        function stylizeNoColor(str, styleType) {
            return str;
        }


        function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
                hash[val] = true;
            });

            return hash;
        }


        function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                // Filter out the util module, it's inspect function is special
                value.inspect !== exports.inspect &&
                // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
                return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value)
                && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                return formatError(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
                if (isFunction(value)) {
                    var name = value.name ? ': ' + value.name : '';
                    return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                    return formatError(value);
                }
            }

            var base = '', array = false, braces = ['{', '}'];

            // Make Array say that they are Array
            if (isArray(value)) {
                array = true;
                braces = ['[', ']'];
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
                base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                    return ctx.stylize('[Object]', 'special');
                }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
                output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
        }


        function formatPrimitive(ctx, value) {
            if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                        .replace(/'/g, "\\'")
                        .replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
                return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
                return ctx.stylize('' + value, 'boolean');
            // For some reason typeof null is "object", so special case here.
            if (isNull(value))
                return ctx.stylize('null', 'null');
        }


        function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
        }


        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        String(i), true));
                } else {
                    output.push('');
                }
            }
            keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        key, true));
                }
            });
            return output;
        }


        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
                if (desc.set) {
                    str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                    str = ctx.stylize('[Getter]', 'special');
                }
            } else {
                if (desc.set) {
                    str = ctx.stylize('[Setter]', 'special');
                }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
            }
            if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                        str = formatValue(ctx, desc.value, null);
                    } else {
                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf('\n') > -1) {
                        if (array) {
                            str = str.split('\n').map(function(line) {
                                return '  ' + line;
                            }).join('\n').substr(2);
                        } else {
                            str = '\n' + str.split('\n').map(function(line) {
                                    return '   ' + line;
                                }).join('\n');
                        }
                    }
                } else {
                    str = ctx.stylize('[Circular]', 'special');
                }
            }
            if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                    return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, 'name');
                } else {
                    name = name.replace(/'/g, "\\'")
                        .replace(/\\"/g, '"')
                        .replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, 'string');
                }
            }

            return name + ': ' + str;
        }


        function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);

            if (length > 60) {
                return braces[0] +
                    (base === '' ? '' : base + '\n ') +
                    ' ' +
                    output.join(',\n  ') +
                    ' ' +
                    braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
        }


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
            return isObject(e) &&
                (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||  // ES6 symbol
                typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = require('./support/isBuffer');

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }


        function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
        }


        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
            'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
        function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
        }


// log is just a thin wrapper to console.log that prepends a timestamp
        exports.log = function() {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
        };


        /**
         * Inherit the prototype methods from one constructor into another.
         *
         * The Function.prototype.inherits from lang.js rewritten as a standalone
         * function (not on Function.prototype). NOTE: If this file is to be loaded
         * during bootstrapping this function needs to be rewritten using some native
         * functions as prototype setup using normal JavaScript does not work as
         * expected during bootstrapping (see mirror.js in r114903).
         *
         * @param {function} ctor Constructor function which needs to inherit the
         *     prototype.
         * @param {function} superCtor Constructor function to inherit prototype from.
         */
        exports.inherits = require('inherits');

        exports._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
                origin[keys[i]] = add[keys[i]];
            }
            return origin;
        };

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }

    }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":112,"_process":98,"inherits":94}]},{},[1]);
